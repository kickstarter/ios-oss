import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Date: { input: any; output: any; }
  DateTime: { input: any; output: any; }
  Email: { input: any; output: any; }
  HTML: { input: any; output: any; }
  ISO8601DateTime: { input: any; output: any; }
  JSON: { input: any; output: any; }
  Ratio: { input: any; output: any; }
};

/** Autogenerated input type of AcceptOrRejectAddressSuggestion */
export type AcceptOrRejectAddressSuggestionInput = {
  associatedObjectId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  fulfillmentAddressId: Scalars['ID']['input'];
  source: AddressCreationSource;
  suggestionAccepted: Scalars['Boolean']['input'];
};

/** Autogenerated return type of AcceptOrRejectAddressSuggestion */
export type AcceptOrRejectAddressSuggestionPayload = {
  __typename?: 'AcceptOrRejectAddressSuggestionPayload';
  /** Object associated with the address */
  associatedObject?: Maybe<AddressAssociatedObject>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** A rule that specifies a resource that a user group can access and how they access it */
export type AccessRule = {
  __typename?: 'AccessRule';
  /** What percent backed the secret resource? */
  convertedUserPercentage: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  /** The resource this rule gives access to, e.g. a secret reward */
  resource: SecretResource;
  /** How the resource is accessed. Either via link or access is restricted to a predefined group */
  type: AccessRuleTypeEnum;
};

/** The type for an access rule */
export enum AccessRuleTypeEnum {
  /** link */
  Link = 'link',
  /** restricted */
  Restricted = 'restricted'
}

/** A project's account information. */
export type AccountInfo = {
  __typename?: 'AccountInfo';
  /** Payment sources available to the project. */
  availablePaymentSources: Array<Maybe<CreditCard>>;
  /** The account for funds. */
  depositAccount?: Maybe<DepositAccount>;
  /** A project's email contact. */
  email: Scalars['String']['output'];
  /** Whether or not a project's email contact has been verified. */
  isEmailVerified: Scalars['Boolean']['output'];
  /** Payment source for dispute resolution. */
  paymentSource?: Maybe<CreditCard>;
  paymentsOnboarding: PaymentsOnboarding;
  /** True if the project accepts an account holder name. */
  usesAccountHolderName: Scalars['Boolean']['output'];
  /** True if the project accepts a routing number. */
  usesRoutingNumber: Scalars['Boolean']['output'];
};

/** Autogenerated input type of AcknowledgeUpgrades */
export type AcknowledgeUpgradesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the order to acknowledge upgrades on */
  orderId: Scalars['ID']['input'];
};

/** Autogenerated return type of AcknowledgeUpgrades */
export type AcknowledgeUpgradesPayload = {
  __typename?: 'AcknowledgeUpgradesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The order that has been updated */
  order: Order;
};

/** Autogenerated input type of ActivateProjectPrelaunch */
export type ActivateProjectPrelaunchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ActivateProjectPrelaunch */
export type ActivateProjectPrelaunchPayload = {
  __typename?: 'ActivateProjectPrelaunchPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Needed for the verification of legal entities that have multiple owners */
export type AdditionalOwner = {
  __typename?: 'AdditionalOwner';
  address: AdditionalOwnerAddress;
  birthdate?: Maybe<AdditionalOwnerBirthdate>;
  firstName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  personalIdNumberProvided: Scalars['Boolean']['output'];
  verification: AdditionalOwnerVerification;
};

export type AdditionalOwnerAddress = {
  __typename?: 'AdditionalOwnerAddress';
  country?: Maybe<Scalars['String']['output']>;
};

export type AdditionalOwnerBirthdate = {
  __typename?: 'AdditionalOwnerBirthdate';
  day?: Maybe<Scalars['Int']['output']>;
  month?: Maybe<Scalars['Int']['output']>;
  year?: Maybe<Scalars['Int']['output']>;
};

export type AdditionalOwnerVerification = {
  __typename?: 'AdditionalOwnerVerification';
  details?: Maybe<Scalars['String']['output']>;
  detailsCode?: Maybe<Scalars['String']['output']>;
  document?: Maybe<Scalars['String']['output']>;
  documentBack?: Maybe<Scalars['String']['output']>;
  state: AsynchronousVerificationState;
};

/** A user's shipping address */
export type Address = Node & {
  __typename?: 'Address';
  /** Address line 1 (Street address/PO Box/Company name) */
  addressLine1: Scalars['String']['output'];
  /** Address line 2 (Apartment/Suite/Unit/Building) */
  addressLine2?: Maybe<Scalars['String']['output']>;
  /** City */
  city: Scalars['String']['output'];
  /** 2-letter country code */
  countryCode: CountryCode;
  /** The name of the country associated with the country code */
  countryName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The number of non updatable survey responses to this address */
  nonUpdatableSurveyResponsesCount: Scalars['Int']['output'];
  /** Recipient's phone number */
  phoneNumber?: Maybe<Scalars['String']['output']>;
  /** ZIP or postal code */
  postalCode?: Maybe<Scalars['String']['output']>;
  /** Is this the user's primary address? */
  primary: Scalars['Boolean']['output'];
  /** The title of projects with updatable survey responses */
  projectsWithUpdatableSurveyResponses: Array<Scalars['String']['output']>;
  /** The title of projects with non updatable survey responses */
  projectsWithoutUpdatableSurveyResponses: Array<Scalars['String']['output']>;
  /** Address recipient name */
  recipientName?: Maybe<Scalars['String']['output']>;
  /** Address reference or nickname */
  referenceName?: Maybe<Scalars['String']['output']>;
  /** State/County/Province/Region. */
  region?: Maybe<Scalars['String']['output']>;
  /** The number of current updatable survey responses to this address */
  updatableSurveyResponsesCount: Scalars['Int']['output'];
  /** The user associated with the shipping address */
  user?: Maybe<User>;
};

/** Objects that can be associated with an address */
export type AddressAssociatedObject = Backing | Order | Project | StockLocation;

/** The connection type for Address. */
export type AddressConnection = {
  __typename?: 'AddressConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AddressEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Address>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** Source of address creation */
export enum AddressCreationSource {
  PledgeRedemption = 'pledge_redemption',
  PledgeRedemptionEdit = 'pledge_redemption_edit',
  StockLocationCreate = 'stock_location_create',
  StockLocationEdit = 'stock_location_edit',
  Survey = 'survey',
  UserSettings = 'user_settings'
}

/** An edge in a connection. */
export type AddressEdge = {
  __typename?: 'AddressEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Address>;
};

/** The adjusted reward. */
export type AdjustedReward = {
  __typename?: 'AdjustedReward';
  /** The total amount refunded for the reward */
  amount: Scalars['String']['output'];
  /** The name of the reward */
  name: Scalars['String']['output'];
};

/** Current state of a backing after all adjustments are applied. */
export type AdjustedSummary = {
  __typename?: 'AdjustedSummary';
  /** list of rewards, original total costs, and totals after adjustments */
  allRewards: Array<AdjustmentReward>;
  /** current total amount for backing */
  amount: Scalars['Int']['output'];
  /** current bonus amount for backing */
  bonusAmount?: Maybe<AdjustmentAmount>;
  /** current shipping amount for backing */
  shippingAmount?: Maybe<AdjustmentAmount>;
  /** current backing status */
  status: BackingState;
};

/** Adjustment to an order, created to issue a refund. */
export type Adjustment = {
  __typename?: 'Adjustment';
  /** Timestamp at which adjustment was created */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Adjustment ID */
  id: Scalars['String']['output'];
  /** Metadata for the adjustment, including refunds and removals */
  metadata: AdjustmentMetadata;
  /** State of associated refund checkout */
  refundCheckoutState?: Maybe<RefundCheckoutState>;
  /** Timestamp at which adjustment was last updated */
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** A hash containing the original, refunded, and remaining amounts. */
export type AdjustmentAmount = {
  __typename?: 'AdjustmentAmount';
  /** original total amount */
  originalTotal: Scalars['Int']['output'];
  /** amount that has been refunded after all adjustments are applied */
  refundedTotal: Scalars['Int']['output'];
  /** amount remaining after all adjustments are applied */
  remainingTotal: Scalars['Int']['output'];
  /** whether the reward has been removed from the backing */
  removed?: Maybe<Scalars['Boolean']['output']>;
};

/** Parameters to create adjustment to a backing's order, created when issuing a refund. */
export type AdjustmentInput = {
  /** Reason for adjustment */
  reason: RefundReasonType;
  /** Refunds to be issued */
  refunds: Array<RefundInput>;
  /** Objects to be removed from order */
  removals: Array<RemovalInput>;
};

/** Metadata for adjustment to order */
export type AdjustmentMetadata = {
  __typename?: 'AdjustmentMetadata';
  /** Reason for adjustment */
  reason: RefundReasonType;
  /** ID of associated RefundCheckout */
  refundCheckoutId: Scalars['String']['output'];
  /** Refunds to be issued in adjustment */
  refunds: Array<AdjustmentRefund>;
  /** Objects to be removed from order in adjustment */
  removals: Array<AdjustmentRemoval>;
};

/** A refund issued as part of an adjustment. */
export type AdjustmentRefund = {
  __typename?: 'AdjustmentRefund';
  /** amount to be refunded */
  amount: Scalars['Int']['output'];
  /** id of object to be refunded */
  id: Scalars['ID']['output'];
  /** type of refund */
  type: RefundAdjustmentType;
};

/** An object removed as part of an adjustment. */
export type AdjustmentRemoval = {
  __typename?: 'AdjustmentRemoval';
  /** id of object to be removed */
  id: Scalars['ID']['output'];
  /** type of object to be removed (reward, reward item, or order item) */
  type: RefundAdjustmentType;
};

/** A reward that is modified by an adjustment. */
export type AdjustmentReward = {
  __typename?: 'AdjustmentReward';
  /** original total amount */
  originalTotal: Scalars['Int']['output'];
  /** uuid for the refund item */
  refundItemId: Scalars['ID']['output'];
  /** amount that has been refunded after all adjustments are applied */
  refundedTotal: Scalars['Int']['output'];
  /** amount remaining after all adjustments are applied */
  remainingTotal: Scalars['Int']['output'];
  /** whether the reward has been removed from the backing */
  removed?: Maybe<Scalars['Boolean']['output']>;
  /**  graphql id of reward to be refunded */
  rewardId: Scalars['String']['output'];
};

/** An adjustment summary. */
export type AdjustmentSummary = Node & {
  __typename?: 'AdjustmentSummary';
  /** The associated backing/order */
  adjustable: Backing;
  /** The current state of the backing or order */
  adjustedSummary?: Maybe<AdjustedSummary>;
  /** An array of adjustments associated with the AdjustmentSummary */
  adjustments: Array<Adjustment>;
  id: Scalars['ID']['output'];
  /** The sum of all refunded amounts on the adjustable */
  refundedAmount?: Maybe<Scalars['Int']['output']>;
};

/** An AI disclosure. */
export type AiDisclosure = Node & {
  __typename?: 'AiDisclosure';
  fundingForAiAttribution?: Maybe<Scalars['Boolean']['output']>;
  fundingForAiConsent?: Maybe<Scalars['Boolean']['output']>;
  fundingForAiOption?: Maybe<Scalars['Boolean']['output']>;
  generatedByAiConsent?: Maybe<Scalars['String']['output']>;
  generatedByAiDetails?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  involvesAi: Scalars['Boolean']['output'];
  involvesFunding: Scalars['Boolean']['output'];
  involvesGeneration: Scalars['Boolean']['output'];
  involvesOther: Scalars['Boolean']['output'];
  otherAiDetails?: Maybe<Scalars['String']['output']>;
};

export type AiDisclosureInput = {
  fundingForAiAttribution?: InputMaybe<Scalars['Boolean']['input']>;
  fundingForAiConsent?: InputMaybe<Scalars['Boolean']['input']>;
  fundingForAiOption?: InputMaybe<Scalars['Boolean']['input']>;
  generatedByAiConsent?: InputMaybe<Scalars['String']['input']>;
  generatedByAiDetails?: InputMaybe<Scalars['String']['input']>;
  otherAiDetails?: InputMaybe<Scalars['String']['input']>;
};

/** An answer associated with one of the following: LineItem, Cart, BackingAddon, CartReward */
export type Answer = {
  __typename?: 'Answer';
  /** The object associated with the answer (e.g. Item, Project, Reward) */
  answerable: Answerable;
  id: Scalars['ID']['output'];
  /** The associated question */
  question: Question;
  /** The response to the question */
  response: Array<Scalars['String']['output']>;
};

/** Answer associated with a particular question and answerable. */
export type AnswerInput = {
  answerableId?: InputMaybe<Scalars['ID']['input']>;
  questionId: Scalars['ID']['input'];
  response?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated input type of AnswerProjectFeedbackQuestion */
export type AnswerProjectFeedbackQuestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  questionAnswer: Scalars['String']['input'];
  questionName: Scalars['String']['input'];
};

/** Autogenerated return type of AnswerProjectFeedbackQuestion */
export type AnswerProjectFeedbackQuestionPayload = {
  __typename?: 'AnswerProjectFeedbackQuestionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  feedback?: Maybe<ProjectFeedback>;
};

/** An object that can be associated with an answer */
export type Answerable = BackingAddon | Cart | CartReward | LineItem;

/** Parameters for sharing app data and device information with the Conversions API */
export type AppDataInput = {
  /** Use this field to specify ATT permission on an iOS 14.5+ device. */
  advertiserTrackingEnabled: Scalars['Boolean']['input'];
  /** A person can choose to enable ad tracking on an app level. Your SDK should allow an app developer to put an opt-out setting into their app. Use this field to specify the person's choice. */
  applicationTrackingEnabled: Scalars['Boolean']['input'];
  /** Extended device information, such as screen width and height. Required only for native. */
  extinfo: Array<Scalars['String']['input']>;
};

/** Necessary fields for Apple Pay */
export type ApplePayInput = {
  paymentInstrumentName: Scalars['String']['input'];
  paymentNetwork: Scalars['String']['input'];
  /** Stripe token */
  token: Scalars['String']['input'];
  transactionIdentifier: Scalars['String']['input'];
};

/** Autogenerated input type of ApplyPaymentSourceToCheckout */
export type ApplyPaymentSourceToCheckoutInput = {
  checkoutId: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  incremental?: InputMaybe<Scalars['Boolean']['input']>;
  intentClientSecret?: InputMaybe<Scalars['String']['input']>;
  paymentSourceId: Scalars['String']['input'];
};

/** Autogenerated return type of ApplyPaymentSourceToCheckout */
export type ApplyPaymentSourceToCheckoutPayload = {
  __typename?: 'ApplyPaymentSourceToCheckoutPayload';
  checkout: Checkout;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** An article block for Editorial pages */
export type Article = {
  __typename?: 'Article';
  /** AdminUI: Rich Text Editor property for attachableAssoc. */
  attachableAssoc: Scalars['String']['output'];
  /** AdminUI: Rich Text Editor property for attachableId. */
  attachableId: Scalars['String']['output'];
  /** The html body of the article. */
  body: Scalars['String']['output'];
  /** The author of the article. Can be an empty string. */
  byline: Scalars['String']['output'];
  /** Determines if the byline should be displayed at the top of the article */
  displayTopByline: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** The date this article is published on. This date is only informative and won't affect module visibility. */
  publicationDate: Scalars['Date']['output'];
  /** The subtitle of the article. Can be an empty string. */
  subtitle: Scalars['String']['output'];
  /** The title of the article. Can be an empty string. */
  title?: Maybe<Scalars['String']['output']>;
};

/** All available asset upload states */
export enum AssetEncodingState {
  /** Processing the asset successfully completed */
  Encoded = 'ENCODED',
  /** Initial, incomplete status of an asset upload */
  Encoding = 'ENCODING',
  /** Processing the asset failed */
  Failed = 'FAILED'
}

/** All available asset states */
export enum AssetState {
  /** The asset file has been deleted */
  Deleted = 'DELETED',
  /** A missing asset */
  Missing = 'MISSING',
  /** Incomplete status of an asset */
  Processing = 'PROCESSING',
  /** Processing the asset file successfully completed */
  Successful = 'SUCCESSFUL'
}

export type AsynchronousVerification = {
  __typename?: 'AsynchronousVerification';
  /** If it didn't pass verification, this array will contain the names of the attributes that failed (e.g., for a Company: ['address.line1']) */
  fieldsNeeded: Array<Scalars['String']['output']>;
  state: AsynchronousVerificationState;
};

/** Something that is expected to eventually become either 'verified' or 'unverified', but may remain 'pending' for an indefinite amount of time */
export enum AsynchronousVerificationState {
  Pending = 'pending',
  Unverified = 'unverified',
  Verified = 'verified'
}

/** An object that can be associated with uploaded assets */
export type Attachable = FreeformPost | InterviewAnswer | Project | Survey;

export type AttachedAudio = Node & {
  __typename?: 'AttachedAudio';
  id: Scalars['ID']['output'];
  /** Upload status of the audio */
  status: AssetEncodingState;
  url?: Maybe<Scalars['String']['output']>;
};

/** Attached Media */
export type AttachedMedia = AttachedAudio | AttachedVideo | Photo;

export type AttachedVideo = Node & {
  __typename?: 'AttachedVideo';
  formats?: Maybe<Array<Maybe<AttachedVideoFormat>>>;
  id: Scalars['ID']['output'];
  /** Image preview url */
  poster?: Maybe<Scalars['String']['output']>;
  /** The rendered HTML player for a video asset */
  renderedHtml?: Maybe<Scalars['String']['output']>;
  /** Upload status of the video */
  status: AssetEncodingState;
  /** Original video url */
  url?: Maybe<Scalars['String']['output']>;
};


export type AttachedVideoRenderedHtmlArgs = {
  assetWidth?: InputMaybe<Scalars['Int']['input']>;
};

export type AttachedVideoFormat = {
  __typename?: 'AttachedVideoFormat';
  encoding: Scalars['String']['output'];
  height: Scalars['String']['output'];
  profile: Scalars['String']['output'];
  url: Scalars['String']['output'];
  width: Scalars['String']['output'];
};

/** The audience for the resource */
export enum AudienceEnum {
  /** everyone */
  Everyone = 'everyone',
  /** link */
  Link = 'link',
  /** restricted */
  Restricted = 'restricted'
}

/** Input related to setting the resource audience */
export type AudienceInput = {
  audience: AudienceEnum;
  token?: InputMaybe<Scalars['String']['input']>;
};

/** A backer survey that a creator sends */
export type BackerSurvey = {
  __typename?: 'BackerSurvey';
  /** Project- and reward- level survey questions */
  backerQuestions: Array<Question>;
  /** The number of backers who have not answered the survey */
  backersRemaining: Scalars['Int']['output'];
  /** Whether the survey has at least one question or option */
  hasBackerQuestionsOrItemOptions: Scalars['Boolean']['output'];
  /** Whether the survey has at least one item-level question or option */
  hasItemQuestionsOrOptions: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** An optional introduction to the backer survey. */
  intro?: Maybe<Scalars['HTML']['output']>;
  /** When the survey was sent */
  sentAt?: Maybe<Scalars['DateTime']['output']>;
  /** The percentage of surveys that have been completed */
  surveyCompletePercentage: Scalars['Float']['output'];
};


/** A backer survey that a creator sends */
export type BackerSurveyIntroArgs = {
  assetWidth?: InputMaybe<Scalars['Int']['input']>;
  forEditor?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A backing */
export type Backing = Node & {
  __typename?: 'Backing';
  /** The add-ons that the backer selected */
  addOns?: Maybe<RewardTotalCountConnection>;
  /** The add-ons that the backer selected */
  addOnsWithQuantity?: Maybe<Array<BackingAddon>>;
  /** A summary of refunds and removal issued by the creator */
  adjustmentSummary?: Maybe<AdjustmentSummary>;
  /** Countries that the backing's reward can be shipped to. If null, the backing's reward can be shipped to any country. */
  allowedCountries?: Maybe<Array<CountryCode>>;
  /** Total amount pledged by the backer to the project, including shipping. */
  amount: Money;
  /** Add-ons available to be added at Pledge Redemption */
  availableCrossSells: Array<Reward>;
  /** Base rewards available to upgrade to */
  availableUpgradeableRewards: Array<Reward>;
  /** The backer */
  backer?: Maybe<User>;
  /** If the backer_completed_at is set or not */
  backerCompleted: Scalars['Boolean']['output'];
  /** Backer's note regarding their backing */
  backerNote?: Maybe<Scalars['String']['output']>;
  /** The sentiment feedback the backer has submitted for the backing, if any */
  backerSentiment?: Maybe<Scalars['String']['output']>;
  /** URL/path for the backing details page */
  backingDetailsPageRoute: Scalars['String']['output'];
  /** The backing rewards on a backing */
  backingRewards?: Maybe<Array<BackingAddon>>;
  /** A link to the backing information */
  backingUrl: Scalars['String']['output'];
  /** Extra amount the backer pledged on top of the minimum. */
  bonusAmount: Money;
  /** Whether or not the creator can perform a partial refund now */
  canAcceptPartialRefund: Scalars['Boolean']['output'];
  /** Whether or not the creator can perform a pledge manager refund now */
  canAcceptPledgeManagerRefund: Scalars['Boolean']['output'];
  /** If the backing can be cancelled */
  cancelable: Scalars['Boolean']['output'];
  /** Contains the backer's item preferences and responses to survey questions */
  cart?: Maybe<Cart>;
  /** If `requires_action` is true, `client_secret` should be used to initiate additional client-side authentication steps */
  clientSecret?: Maybe<Scalars['String']['output']>;
  /** When the backing was completed */
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Refund attempts performed by the creator */
  completedRefundAttempts: Array<Refund>;
  /** Message thread between backer and creator */
  conversation?: Maybe<Conversation>;
  /** The delivery address associated with the backing */
  deliveryAddress?: Maybe<Address>;
  /** Digital Access Resources provided by a creator to fulfill digital rewards */
  digitalAccessResources: Array<DigitalAccessResource>;
  /** The reason for an errored backing */
  errorReason?: Maybe<Scalars['String']['output']>;
  /** The fulfillment status of a backing. */
  fulfillmentStatus: FulfillmentStatusDisplayOptions;
  /** Whether or not the backing has any open flaggings */
  hasFlaggings: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** If the backing was incremental, ie pledged over time */
  incremental: Scalars['Boolean']['output'];
  /** Whether or not the backing is a late pledge */
  isLatePledge: Scalars['Boolean']['output'];
  /** Is this backing a late pledge or did it occur during the crowdfunding campaign? */
  isPostCampaign: Scalars['Boolean']['output'];
  /** If present, the most recent setup_intent data from Stripe. */
  latestSetupIntent?: Maybe<SetupIntent>;
  /** The backing location. */
  location?: Maybe<Location>;
  /** The order associated with the backing */
  order?: Maybe<Order>;
  /** The original or upgraded backer reward */
  originalOrUpgradedReward?: Maybe<Reward>;
  /** Scheduled incremental payments */
  paymentIncrements?: Maybe<Array<PaymentIncrement>>;
  /** Payment source used on a backing. */
  paymentSource?: Maybe<PaymentSource>;
  /** If the payout for the backing has happened */
  payoutStarted: Scalars['Boolean']['output'];
  /** When the backing was created */
  pledgedOn?: Maybe<Scalars['DateTime']['output']>;
  /** Is this pledge processing? */
  processing?: Maybe<Scalars['Boolean']['output']>;
  /** The project */
  project?: Maybe<Project>;
  /** URL for redeeming the backing */
  redemptionPageUrl: Scalars['String']['output'];
  /** If the backing was refunded */
  refunded: Scalars['Boolean']['output'];
  /** How much the backer paid on their base reward, after refunds */
  remainingTotalOnBackerReward?: Maybe<Money>;
  /** Whether or not a removal request task is marked as nonissue */
  removalRequestIsNonissue: Scalars['Boolean']['output'];
  /** Whether this checkout requires additional client-side authentication steps (e.g. 3DS2) to complete the on-session pledge flow */
  requiresAction?: Maybe<Scalars['Boolean']['output']>;
  /** The reward the backer is expecting */
  reward?: Maybe<Reward>;
  /** Amount pledged for all rewards, the sum off all minimums, excluding shipping */
  rewardsAmount: Money;
  /** Admin tree for the associated Rosie Pledge */
  rosiePledgeAdminTree?: Maybe<Scalars['String']['output']>;
  /** Sequence of the backing */
  sequence?: Maybe<Scalars['Int']['output']>;
  /** Shipping amount for the rewards chosen by the backer for their location */
  shippingAmount?: Maybe<Money>;
  /** A brief description of shipping selections for backing */
  shippingSummary?: Maybe<Scalars['String']['output']>;
  /** The status of a backing */
  status: BackingState;
  /** Refunds */
  successfulRefunds: Array<Scalars['String']['output']>;
  surveyResponses?: Maybe<Array<SurveyResponse>>;
  /** All of the backer's saved addresses that match the backing country */
  usableBackerAddresses?: Maybe<Array<Address>>;
};


/** A backing */
export type BackingAddOnsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A backing */
export type BackingBackingDetailsPageRouteArgs = {
  tab?: InputMaybe<BackingDetailsPageTab>;
  type: Route;
};

/** An add-on reward included in a backing. */
export type BackingAddon = {
  __typename?: 'BackingAddon';
  /** Amount the add-on costs. */
  amount: Money;
  /** The addon reward */
  backerReward: Reward;
  /** The add-on description. */
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Items in the add-on. */
  items: RewardItemsConnection;
  /** The add-on name. */
  name?: Maybe<Scalars['String']['output']>;
  /** Amount for claiming this add-on during the campaign. */
  pledgeAmount: Money;
  /** The quantity of the add-on included in a backing. */
  quantity: Scalars['Int']['output'];
};


/** An add-on reward included in a backing. */
export type BackingAddonItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export enum BackingDetailsPageTab {
  /** Details */
  Details = 'details',
  /** Digital rewards */
  DigitalRewards = 'digital_rewards',
  /** Messages */
  Messages = 'messages',
  /** Pledge redemption */
  PledgeRedemption = 'pledge_redemption',
  /** Survey responses */
  SurveyResponses = 'survey_responses'
}

/** An edge in a connection. */
export type BackingEdge = {
  __typename?: 'BackingEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Backing>;
};

export enum BackingNoteType {
  BackerBackingNote = 'BackerBackingNote',
  CreatorBackingNote = 'CreatorBackingNote'
}

/** Various backing states. */
export enum BackingState {
  AuthenticationRequired = 'authentication_required',
  Canceled = 'canceled',
  Collected = 'collected',
  Dropped = 'dropped',
  Dummy = 'dummy',
  Errored = 'errored',
  Pledged = 'pledged',
  Preauth = 'preauth'
}

export enum BackingsDashboardSortOptions {
  /** Sort by newest first */
  NewestFirst = 'NEWEST_FIRST',
  /** Sort by oldest first */
  OldestFirst = 'OLDEST_FIRST',
  /** Sort by relevancy */
  Relevancy = 'RELEVANCY'
}

/** A bank account. */
export type BankAccount = {
  __typename?: 'BankAccount';
  /** The bank name if available. */
  bankName?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  /** The last four digits of the account number. */
  lastFour: Scalars['String']['output'];
  /** The stripe bank account id */
  stripeCardId: Scalars['String']['output'];
};

/** The connection type for BankAccount. */
export type BankAccountConnection = {
  __typename?: 'BankAccountConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BankAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BankAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BankAccountEdge = {
  __typename?: 'BankAccountEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BankAccount>;
};

/** Autogenerated input type of BatchUpdateSurveyResponseAddresses */
export type BatchUpdateSurveyResponseAddressesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  fulfillmentAddressId: Scalars['ID']['input'];
};

/** Autogenerated return type of BatchUpdateSurveyResponseAddresses */
export type BatchUpdateSurveyResponseAddressesPayload = {
  __typename?: 'BatchUpdateSurveyResponseAddressesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The count of SurveyResponses that were successfully updated */
  updatedSurveyResponsesCount: Scalars['Int']['output'];
};

/** Maps directly to a specialty built React component */
export type BespokeComponent = {
  __typename?: 'BespokeComponent';
  /** Exact name of the React component (used to lookup the component) */
  component?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Language for which to display the React component */
  language?: Maybe<Scalars['String']['output']>;
  /** Data properties to be passed down to the React component */
  props?: Maybe<Scalars['JSON']['output']>;
};

/** The different bitly hashes for a project */
export enum BitlyHashes {
  /** A project's email share link */
  Email = 'EMAIL',
  /** A project's facebook share link */
  Facebook = 'FACEBOOK',
  /** A project's share link */
  Share = 'SHARE',
  /** A project's twitter share link */
  Tweet = 'TWEET'
}

/** Autogenerated input type of BlockUser */
export type BlockUserInput = {
  blockUserId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of BlockUser */
export type BlockUserPayload = {
  __typename?: 'BlockUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  currentUser?: Maybe<User>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of BulkEditQuestions */
export type BulkEditQuestionsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
  questions: Array<QuestionInput>;
};

/** Autogenerated return type of BulkEditQuestions */
export type BulkEditQuestionsPayload = {
  __typename?: 'BulkEditQuestionsPayload';
  /** The updated backer survey. */
  backerSurvey?: Maybe<BackerSurvey>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of BulkEditStockLocationMappings */
export type BulkEditStockLocationMappingsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  locationIds: Array<Scalars['ID']['input']>;
  stockLocationId: Scalars['ID']['input'];
};

/** Autogenerated return type of BulkEditStockLocationMappings */
export type BulkEditStockLocationMappingsPayload = {
  __typename?: 'BulkEditStockLocationMappingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated stock location */
  stockLocation: StockLocation;
};

/** Autogenerated input type of CancelBacking */
export type CancelBackingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the backing being canceled */
  id: Scalars['ID']['input'];
  /** Optional cancellation note */
  note?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CancelBacking */
export type CancelBackingPayload = {
  __typename?: 'CancelBackingPayload';
  backing: Backing;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CancelProject */
export type CancelProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  password: Scalars['String']['input'];
};

/** Autogenerated return type of CancelProject */
export type CancelProjectPayload = {
  __typename?: 'CancelProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** A language eligible for captions in video tracks. */
export type CaptionLanguage = {
  __typename?: 'CaptionLanguage';
  /** The code used as a key for the language. */
  code: CaptionLanguageCode;
  /** The name of the language. */
  name: Scalars['String']['output'];
};

/** Two letter language code for eligible caption languages */
export enum CaptionLanguageCode {
  /** العربية */
  Ar = 'AR',
  /** Català */
  Ca = 'CA',
  /** Čeština */
  Cs = 'CS',
  /** Dansk */
  Da = 'DA',
  /** Deutsch */
  De = 'DE',
  /** ελληνικά */
  El = 'EL',
  /** English */
  En = 'EN',
  /** Español (España) */
  EsEs = 'ES_ES',
  /** Español (México) */
  EsMx = 'ES_MX',
  /** Suomi */
  Fi = 'FI',
  /** Français */
  Fr = 'FR',
  /** Gaeilge */
  Ga = 'GA',
  /** עברית */
  He = 'HE',
  /** हिन्दी */
  Hi = 'HI',
  /** Hrvatski */
  Hr = 'HR',
  /** Magyar */
  Hu = 'HU',
  /** Bahasa Indonesia */
  Id = 'ID',
  /** Italiano */
  It = 'IT',
  /** 日本語 */
  Ja = 'JA',
  /** 한국어 */
  Ko = 'KO',
  /** Bahasa Melayu */
  Ms = 'MS',
  /** Norsk bokmål */
  Nb = 'NB',
  /** Nederlands */
  Nl = 'NL',
  /** नेपाली */
  Npi = 'NPI',
  /** Diné bizaad */
  Nv = 'NV',
  /** فارسی */
  Pes = 'PES',
  /** Polski */
  Pl = 'PL',
  /** دری */
  Prs = 'PRS',
  /** Português (Brasil) */
  PtBr = 'PT_BR',
  /** Português (Portugal) */
  PtPt = 'PT_PT',
  /** Română */
  Ro = 'RO',
  /** Русский */
  Ru = 'RU',
  /** Slovenčina */
  Sk = 'SK',
  /** Svenska */
  Sv = 'SV',
  /** ภาษาไทย */
  Th = 'TH',
  /** Türkçe */
  Tr = 'TR',
  /** українська */
  Uk = 'UK',
  /** tiếng Việt */
  Vi = 'VI',
  /** יידיש */
  Yi = 'YI',
  /** 简体中文 */
  ZhCn = 'ZH_CN',
  /** 繁體中文 */
  ZhTw = 'ZH_TW'
}

/** A cart associated with a backing */
export type Cart = {
  __typename?: 'Cart';
  /** The add-on questions */
  addOnQuestions: Array<CartQuestion>;
  /** Whether the cart required backer action or was finalized on creation */
  autoFinalized: Scalars['Boolean']['output'];
  /** Answers associated with a cart's backing rewards */
  backingRewardAnswers: Array<Answer>;
  /** The answers to reward-level questions */
  baseRewardAnswers: Array<Answer>;
  /** The base reward questions */
  baseRewardQuestions: Array<CartQuestion>;
  /** When the cart was finalized (i.e., when the backer submitted responses) */
  finalizedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether the cart has non-optional questions */
  hasNonOptionalQuestions: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** Whether the backer has begun answering their survey */
  inProgress: Scalars['Boolean']['output'];
  /** The associated line items */
  lineItems: Array<LineItem>;
  /** The answers to project-level questions */
  projectAnswers: Array<Answer>;
  /** The project-level questions */
  projectQuestions: Array<CartQuestion>;
  /** Whether or not this cart needs an address to be finalized */
  shouldCollectAddress: Scalars['Boolean']['output'];
};

/** A question associated with a cart, composed with an answer if one is present */
export type CartQuestion = {
  __typename?: 'CartQuestion';
  /** The answer to the question. Will return an "empty answer" if not yet answered. */
  answer: Answer;
  /** The cart question */
  question: Question;
};

/** A reward in the cart (currently scoped to cross-sell rewards only) */
export type CartReward = {
  __typename?: 'CartReward';
  /** The addon reward */
  backerReward: Reward;
  id: Scalars['ID']['output'];
  /** The add-on name. */
  name?: Maybe<Scalars['String']['output']>;
};

/** A project category. */
export type Category = Node & {
  __typename?: 'Category';
  /** Category name in English for analytics use. */
  analyticsName: Scalars['String']['output'];
  /** Advised maximum goal limit in USD */
  goalHelperLimit?: Maybe<Scalars['Float']['output']>;
  id: Scalars['ID']['output'];
  /** Category name. */
  name: Scalars['String']['output'];
  /** Category parent */
  parentCategory?: Maybe<Category>;
  /** Parent id of the category. */
  parentId?: Maybe<Scalars['ID']['output']>;
  /** The translatable phrase (e.g. "An art project")) */
  projectPhrase?: Maybe<Scalars['String']['output']>;
  /** Projects in a category. */
  projects?: Maybe<CategoryProjectsConnection>;
  /** Category slug. */
  slug: Scalars['String']['output'];
  /** Subcategories. */
  subcategories?: Maybe<CategorySubcategoriesConnection>;
  totalProjectCount: Scalars['Int']['output'];
  /** A URL to the category page. */
  url: Scalars['String']['output'];
};


/** A project category. */
export type CategoryProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  state: PublicProjectState;
};


/** A project category. */
export type CategorySubcategoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type CategoryEdge = {
  __typename?: 'CategoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Category>;
};

/** The connection type for Project. */
export type CategoryProjectsConnection = {
  __typename?: 'CategoryProjectsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** The connection type for Category. */
export type CategorySubcategoriesConnection = {
  __typename?: 'CategorySubcategoriesConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Category>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** Intermediary set of changes that have yet to be applied to a backing */
export type Checkout = Node & {
  __typename?: 'Checkout';
  /** The action that the backer is attempting to complete with this checkout */
  action: CheckoutAction;
  /** The addons that the backer has chosen */
  addOns: RewardTotalCountConnection;
  /** The backing that the checkout is modifying. */
  backing: Backing;
  /** Desired amount backer wishes to pledge to the project, including the shipping amount, converted to the backer’s chosen currency */
  convertedTotal: Money;
  /** Estimated shipping maximum for the reward/addons chosen by the backer for their location */
  estimatedShippingTotalMax?: Maybe<Money>;
  /** Estimated shipping minimum for the reward/addons chosen by the backer for their location */
  estimatedShippingTotalMin?: Maybe<Money>;
  /** The translated reason that a checkout might have failed */
  failedStateReason?: Maybe<Scalars['String']['output']>;
  /** Is true when the checkout was created by a guest account */
  guest: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** Whether this checkout should be given the option to pledge over time */
  isPledgeOverTimeEligible: Scalars['Boolean']['output'];
  /** Is true when more than one backer is checking out a limited/scarce reward at once */
  isRacing: Scalars['Boolean']['output'];
  /** Whether the project can accept a pledge with SEPA account as the payment source */
  isSepaEligible: Scalars['Boolean']['output'];
  /** Checks whether the checkout is valid prior to charging the user's card. */
  isValidForOnSessionCheckout: Validation;
  /** If the checkout contains a limited reward, returns an ISO8601 date for when the claim on the reward is expired */
  limitedRewardClaimedUntil?: Maybe<Scalars['ISO8601DateTime']['output']>;
  paymentUrl?: Maybe<Scalars['String']['output']>;
  /** Desired amount backer wishes to pledge to the project, excluding the shipping amount */
  pledgeTotal: Money;
  /** The URL to redirect to on a successful checkout */
  redirectUrl: Scalars['String']['output'];
  /** The reward the backer is expecting */
  reward?: Maybe<Reward>;
  /** Where the user is based. */
  shippingLocation?: Maybe<Location>;
  /** Shipping amount for the reward chosen by the backer for their location */
  shippingTotal: Money;
  /** The current state of the checkout */
  state: CheckoutState;
  /** The full URL to redirect to after an on_session payment via Stripe */
  stripeOnSessionPaymentRedirectUrl: Scalars['String']['output'];
  /** The full URL to redirect to after payment setup via Stripe */
  stripePaymentSetupRedirectUrl: Scalars['String']['output'];
  /** Desired amount backer wishes to pledge to the project, including the shipping amount */
  total: Money;
};


/** Intermediary set of changes that have yet to be applied to a backing */
export type CheckoutAddOnsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Intermediary set of changes that have yet to be applied to a backing */
export type CheckoutIsValidForOnSessionCheckoutArgs = {
  paymentIntentClientSecret: Scalars['String']['input'];
  stripePaymentMethodId: Scalars['String']['input'];
};

/** All actions a user may attempt to complete with a checkout */
export enum CheckoutAction {
  Adjustment = 'ADJUSTMENT',
  Authenticate = 'AUTHENTICATE',
  LatePledge = 'LATE_PLEDGE',
  Pledge = 'PLEDGE',
  Reauth = 'REAUTH',
  Source = 'SOURCE'
}

/** All available states for a checkout */
export enum CheckoutState {
  Authorizing = 'AUTHORIZING',
  Failed = 'FAILED',
  Successful = 'SUCCESSFUL',
  Verifying = 'VERIFYING'
}

/** The state of checkout, e.g. complete, in progress, incomplete. */
export enum CheckoutStateEnum {
  /** complete */
  Complete = 'complete',
  /** in_progress */
  InProgress = 'in_progress',
  /** not_started */
  NotStarted = 'not_started'
}

/** Represents the window during which backers can redeem their backing */
export type CheckoutWave = {
  __typename?: 'CheckoutWave';
  /** Whether the wave is currently active */
  active: Scalars['Boolean']['output'];
  /** Whether the wave can be closed */
  endable: Scalars['Boolean']['output'];
  /** When the wave can be closed */
  endableAt: Scalars['DateTime']['output'];
  /** Whether the wave has ended */
  ended: Scalars['Boolean']['output'];
  /** The end date of the wave */
  endsAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** The associated project */
  project: Project;
  /** The start date of the wave */
  startsAt: Scalars['DateTime']['output'];
};

/** Token, match_type, start, and end position of claims language. */
export type ClaimMatches = {
  __typename?: 'ClaimMatches';
  /** The end position of the token in the source text */
  end?: Maybe<Scalars['Int']['output']>;
  /** The matching strategy used to find the token (either 'POS' or 'regex'). */
  matchType?: Maybe<Scalars['String']['output']>;
  /** The start position of the token in the source text */
  start?: Maybe<Scalars['Int']['output']>;
  /** Token/phrase of matched claims language. */
  token?: Maybe<Scalars['String']['output']>;
};

/** Detect claims in text. */
export type Claims = {
  __typename?: 'Claims';
  /** The matched claims found in the text. */
  matches: Array<ClaimMatches>;
};

/** Autogenerated input type of ClearUserUnseenActivity */
export type ClearUserUnseenActivityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ClearUserUnseenActivity */
export type ClearUserUnseenActivityPayload = {
  __typename?: 'ClearUserUnseenActivityPayload';
  activityIndicatorCount: Scalars['Int']['output'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CloseWave */
export type CloseWaveInput = {
  /** The checkout wave id */
  checkoutWaveId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CloseWave */
export type CloseWavePayload = {
  __typename?: 'CloseWavePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** State of membership for a collaborator on a project */
export enum CollaboratorMembershipState {
  Active = 'active',
  Declined = 'declined',
  Inactive = 'inactive',
  Invited = 'invited'
}

/** A permission for a collaborator on a project */
export enum CollaboratorPermission {
  Comment = 'comment',
  ConfigurePledgeManager = 'configure_pledge_manager',
  EditFaq = 'edit_faq',
  EditProject = 'edit_project',
  Fulfillment = 'fulfillment',
  LaunchPledgeManager = 'launch_pledge_manager',
  Post = 'post',
  ViewPledges = 'view_pledges'
}

/** A comment */
export type Comment = Node & {
  __typename?: 'Comment';
  /** The author of the comment */
  author?: Maybe<User>;
  /** The author's backing information */
  authorBacking?: Maybe<Backing>;
  /** The badges for the comment author */
  authorBadges?: Maybe<Array<Maybe<CommentBadge>>>;
  /** Whether the author has canceled their pledge */
  authorCanceledPledge: Scalars['Boolean']['output'];
  /** The body of the comment */
  body: Scalars['String']['output'];
  /** Whether the current user can delete the comment */
  canDelete: Scalars['Boolean']['output'];
  /** Whether current user can pin a comment */
  canPin: Scalars['Boolean']['output'];
  /** Whether current user can report a comment */
  canReport: Scalars['Boolean']['output'];
  /** When was this comment posted */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether the comment is deleted */
  deleted: Scalars['Boolean']['output'];
  /** Whether the comment author is a deleted user and not the creator */
  deletedAuthor: Scalars['Boolean']['output'];
  /** Whether a comment has any flaggings */
  hasFlaggings: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** The ID of the parent comment */
  parentId?: Maybe<Scalars['String']['output']>;
  /** When the comment was pinned */
  pinnedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** Whether the comment author has been removed by kickstarter */
  removedPerGuidelines: Scalars['Boolean']['output'];
  /** The replies on a comment */
  replies?: Maybe<CommentConnection>;
  /** Is this comment spam */
  spam: Scalars['Boolean']['output'];
  /** Whether this comment has been reviewed and sustained by an admin */
  sustained: Scalars['Boolean']['output'];
};


/** A comment */
export type CommentRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** All available comment author badges */
export enum CommentBadge {
  /** Indicates the author is a collaborator */
  Collaborator = 'collaborator',
  /** Indicates the author is a creator */
  Creator = 'creator',
  /** Indicates the author is a superbacker */
  Superbacker = 'superbacker'
}

/** The connection type for Comment. */
export type CommentConnection = {
  __typename?: 'CommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Comment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CommentEdge = {
  __typename?: 'CommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Comment>;
};

/** Something that can be commented on */
export type Commentable = {
  /** True if the current user can comment (considers restrictions) */
  canComment: Scalars['Boolean']['output'];
  /** True if the current user can comment (does not consider restrictions) */
  canCommentSansRestrictions: Scalars['Boolean']['output'];
  /** Whether a user can request an update about this project from the Creator */
  canUserRequestUpdate: Scalars['Boolean']['output'];
  /** List of comments on the commentable */
  comments?: Maybe<CommentConnection>;
  /** Comment count - defaults to root level comments only */
  commentsCount: Scalars['Int']['output'];
  /** The root project id under which the comment is nested */
  projectRelayId: Scalars['ID']['output'];
};


/** Something that can be commented on */
export type CommentableCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Something that can be commented on */
export type CommentableCommentsCountArgs = {
  withReplies?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A deposit account's company. */
export type Company = {
  __typename?: 'Company';
  /** The company name. */
  name: Scalars['String']['output'];
  phoneNumber?: Maybe<Scalars['String']['output']>;
  streetAddress: StreetAddress;
  vatNumber?: Maybe<Scalars['String']['output']>;
  verification: AsynchronousVerification;
};

/** Autogenerated input type of CompleteOnSessionCheckout */
export type CompleteOnSessionCheckoutInput = {
  /** Apple pay attributes for creating a payment source (optional) */
  applePay?: InputMaybe<ApplePayInput>;
  /** The graphql relay id of the checkout (base64 encoded) */
  checkoutId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** the client_secret returned by createPaymentIntent, starts with `pi_` (the same secret passed to stripe) */
  paymentIntentClientSecret: Scalars['String']['input'];
  /** Kickstarter internal payment source id. Expects a number (not the stripe id starting with `pm_`). Pass in when using a saved card (optional) */
  paymentSourceId?: InputMaybe<Scalars['String']['input']>;
  /** If the payment source can be reused for future payments (optional) */
  paymentSourceReusable?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of CompleteOnSessionCheckout */
export type CompleteOnSessionCheckoutPayload = {
  __typename?: 'CompleteOnSessionCheckoutPayload';
  checkout?: Maybe<Checkout>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CompleteOrder */
export type CompleteOrderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The order id */
  orderId: Scalars['ID']['input'];
  /** List of accepted stripe payment method types */
  paymentMethodTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Kickstarter internal payment source id. Expects a number (not the stripe id starting with `pm_`). Pass in when using a saved card (optional) */
  paymentSourceId?: InputMaybe<Scalars['String']['input']>;
  /** If the new payment source can be reused for future payments (optional) */
  paymentSourceReusable?: InputMaybe<Scalars['Boolean']['input']>;
  /** The stripe confirmation token used to complete a payment (web only) */
  stripeConfirmationTokenId?: InputMaybe<Scalars['String']['input']>;
  /** The stripe payment method id, starting with either `card_` or `pm_` (mobile only) */
  stripePaymentMethodId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CompleteOrder */
export type CompleteOrderPayload = {
  __typename?: 'CompleteOrderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The stripe payment intent client secret used to complete a payment */
  clientSecret: Scalars['String']['output'];
  /** The stripe payment intent status (if requires_action, it will be) */
  status: OnSessionPaymentIntentStatus;
};

/** Autogenerated input type of CompleteZeroDollarOrder */
export type CompleteZeroDollarOrderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The order id */
  orderId: Scalars['ID']['input'];
};

/** Autogenerated return type of CompleteZeroDollarOrder */
export type CompleteZeroDollarOrderPayload = {
  __typename?: 'CompleteZeroDollarOrderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Whether the state transition succeeded */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of ConfirmOrderAddress */
export type ConfirmOrderAddressInput = {
  /** The address id */
  addressId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The order id */
  orderId: Scalars['ID']['input'];
};

/** Autogenerated return type of ConfirmOrderAddress */
export type ConfirmOrderAddressPayload = {
  __typename?: 'ConfirmOrderAddressPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  order: Order;
};

/** A conversation on Kickstarter. */
export type Conversation = Node & {
  __typename?: 'Conversation';
  /** The backing made by the backer on the project this conversation is about */
  backing?: Maybe<Backing>;
  /** When the first message was sent */
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** Are there unread messages for the current user */
  isUnread: Scalars['Boolean']['output'];
  /** Timestamp of the most recent message in the thread */
  lastReceivedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The number of messages between the backer and creator */
  messageCount: Scalars['Int']['output'];
  /** Messages that are part of this conversation */
  messages?: Maybe<ConversationMessagesConnection>;
  /** The other participant to this conversation */
  otherParticipant?: Maybe<User>;
  /** The project this conversation is about */
  project?: Maybe<Project>;
};


/** A conversation on Kickstarter. */
export type ConversationMessagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ConversationEdge = {
  __typename?: 'ConversationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Conversation>;
};

/** The connection type for Message. */
export type ConversationMessagesConnection = {
  __typename?: 'ConversationMessagesConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MessageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Message>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** Autogenerated input type of CopyRewardItems */
export type CopyRewardItemsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
  rewardId: Scalars['ID']['input'];
};

/** Autogenerated return type of CopyRewardItems */
export type CopyRewardItemsPayload = {
  __typename?: 'CopyRewardItemsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  items: Array<RewardItem>;
  reward: Reward;
};

/** A supported country. */
export type Country = {
  __typename?: 'Country';
  /** ISO ALPHA-2 code. */
  code: CountryCode;
  /** Country name. */
  name: Scalars['String']['output'];
  /** Regions part of this country */
  regions: Array<Maybe<Region>>;
  /** Regions that Stripe supports for Stripe Accounts */
  stripeAccountSupportedRegions: Array<Maybe<Region>>;
};

/** Two letter ISO code for a country. */
export enum CountryCode {
  Ad = 'AD',
  Ae = 'AE',
  Af = 'AF',
  Ag = 'AG',
  Ai = 'AI',
  Al = 'AL',
  Am = 'AM',
  An = 'AN',
  Ao = 'AO',
  Aq = 'AQ',
  Ar = 'AR',
  As = 'AS',
  At = 'AT',
  Au = 'AU',
  Aw = 'AW',
  Ax = 'AX',
  Az = 'AZ',
  Ba = 'BA',
  Bb = 'BB',
  Bd = 'BD',
  Be = 'BE',
  Bf = 'BF',
  Bg = 'BG',
  Bh = 'BH',
  Bi = 'BI',
  Bj = 'BJ',
  Bl = 'BL',
  Bm = 'BM',
  Bn = 'BN',
  Bo = 'BO',
  Bq = 'BQ',
  Br = 'BR',
  Bs = 'BS',
  Bt = 'BT',
  Bv = 'BV',
  Bw = 'BW',
  By = 'BY',
  Bz = 'BZ',
  Ca = 'CA',
  Cc = 'CC',
  Cd = 'CD',
  Cf = 'CF',
  Cg = 'CG',
  Ch = 'CH',
  Ci = 'CI',
  Ck = 'CK',
  Cl = 'CL',
  Cm = 'CM',
  Cn = 'CN',
  Co = 'CO',
  Cr = 'CR',
  Cu = 'CU',
  Cv = 'CV',
  Cw = 'CW',
  Cx = 'CX',
  Cy = 'CY',
  Cz = 'CZ',
  De = 'DE',
  Dj = 'DJ',
  Dk = 'DK',
  Dm = 'DM',
  Do = 'DO',
  Dz = 'DZ',
  Ec = 'EC',
  Ee = 'EE',
  Eg = 'EG',
  Eh = 'EH',
  Er = 'ER',
  Es = 'ES',
  Et = 'ET',
  Fi = 'FI',
  Fj = 'FJ',
  Fk = 'FK',
  Fm = 'FM',
  Fo = 'FO',
  Fr = 'FR',
  Ga = 'GA',
  Gb = 'GB',
  Gd = 'GD',
  Ge = 'GE',
  Gf = 'GF',
  Gg = 'GG',
  Gh = 'GH',
  Gi = 'GI',
  Gl = 'GL',
  Gm = 'GM',
  Gn = 'GN',
  Gp = 'GP',
  Gq = 'GQ',
  Gr = 'GR',
  Gs = 'GS',
  Gt = 'GT',
  Gu = 'GU',
  Gw = 'GW',
  Gy = 'GY',
  Hk = 'HK',
  Hm = 'HM',
  Hn = 'HN',
  Hr = 'HR',
  Ht = 'HT',
  Hu = 'HU',
  Id = 'ID',
  Ie = 'IE',
  Il = 'IL',
  Im = 'IM',
  In = 'IN',
  Io = 'IO',
  Iq = 'IQ',
  Ir = 'IR',
  Is = 'IS',
  It = 'IT',
  Je = 'JE',
  Jm = 'JM',
  Jo = 'JO',
  Jp = 'JP',
  Ke = 'KE',
  Kg = 'KG',
  Kh = 'KH',
  Ki = 'KI',
  Km = 'KM',
  Kn = 'KN',
  Kp = 'KP',
  Kr = 'KR',
  Kw = 'KW',
  Ky = 'KY',
  Kz = 'KZ',
  La = 'LA',
  Lb = 'LB',
  Lc = 'LC',
  Li = 'LI',
  Lk = 'LK',
  Lr = 'LR',
  Ls = 'LS',
  Lt = 'LT',
  Lu = 'LU',
  Lv = 'LV',
  Ly = 'LY',
  Ma = 'MA',
  Mc = 'MC',
  Md = 'MD',
  Me = 'ME',
  Mf = 'MF',
  Mg = 'MG',
  Mh = 'MH',
  Mk = 'MK',
  Ml = 'ML',
  Mm = 'MM',
  Mn = 'MN',
  Mo = 'MO',
  Mp = 'MP',
  Mq = 'MQ',
  Mr = 'MR',
  Ms = 'MS',
  Mt = 'MT',
  Mu = 'MU',
  Mv = 'MV',
  Mw = 'MW',
  Mx = 'MX',
  My = 'MY',
  Mz = 'MZ',
  Na = 'NA',
  Nc = 'NC',
  Ne = 'NE',
  Nf = 'NF',
  Ng = 'NG',
  Ni = 'NI',
  Nl = 'NL',
  No = 'NO',
  Np = 'NP',
  Nr = 'NR',
  Nu = 'NU',
  Nz = 'NZ',
  Om = 'OM',
  Pa = 'PA',
  Pe = 'PE',
  Pf = 'PF',
  Pg = 'PG',
  Ph = 'PH',
  Pk = 'PK',
  Pl = 'PL',
  Pm = 'PM',
  Pn = 'PN',
  Pr = 'PR',
  Ps = 'PS',
  Pt = 'PT',
  Pw = 'PW',
  Py = 'PY',
  Qa = 'QA',
  Re = 'RE',
  Ro = 'RO',
  Rs = 'RS',
  Ru = 'RU',
  Rw = 'RW',
  Sa = 'SA',
  Sb = 'SB',
  Sc = 'SC',
  Sd = 'SD',
  Se = 'SE',
  Sg = 'SG',
  Sh = 'SH',
  Si = 'SI',
  Sj = 'SJ',
  Sk = 'SK',
  Sl = 'SL',
  Sm = 'SM',
  Sn = 'SN',
  So = 'SO',
  Sr = 'SR',
  Ss = 'SS',
  St = 'ST',
  Sv = 'SV',
  Sx = 'SX',
  Sy = 'SY',
  Sz = 'SZ',
  Tc = 'TC',
  Td = 'TD',
  Tf = 'TF',
  Tg = 'TG',
  Th = 'TH',
  Tj = 'TJ',
  Tk = 'TK',
  Tl = 'TL',
  Tm = 'TM',
  Tn = 'TN',
  To = 'TO',
  Tr = 'TR',
  Tt = 'TT',
  Tv = 'TV',
  Tw = 'TW',
  Tz = 'TZ',
  Ua = 'UA',
  Ug = 'UG',
  Um = 'UM',
  Us = 'US',
  Uy = 'UY',
  Uz = 'UZ',
  Va = 'VA',
  Vc = 'VC',
  Ve = 'VE',
  Vg = 'VG',
  Vi = 'VI',
  Vn = 'VN',
  Vu = 'VU',
  Wf = 'WF',
  Ws = 'WS',
  Xk = 'XK',
  Ye = 'YE',
  Yt = 'YT',
  Za = 'ZA',
  Zm = 'ZM',
  Zw = 'ZW'
}

/** Autogenerated input type of CreateAddress */
export type CreateAddressInput = {
  addressLine1: Scalars['String']['input'];
  addressLine2?: InputMaybe<Scalars['String']['input']>;
  associatedObjectId?: InputMaybe<Scalars['ID']['input']>;
  city: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  countryCode: CountryCode;
  phoneNumber: Scalars['String']['input'];
  postalCode: Scalars['String']['input'];
  primary?: InputMaybe<Scalars['Boolean']['input']>;
  recipientName: Scalars['String']['input'];
  referenceName: Scalars['String']['input'];
  region?: InputMaybe<Scalars['String']['input']>;
  source: AddressCreationSource;
};

/** Autogenerated return type of CreateAddress */
export type CreateAddressPayload = {
  __typename?: 'CreateAddressPayload';
  /** Address that was created */
  address: Address;
  /** Object associated with the address */
  associatedObject?: Maybe<AddressAssociatedObject>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Address suggestion */
  suggestedAddress?: Maybe<Address>;
  /** Validation status for created address */
  validationStatus: ValidationStatus;
};

/** Autogenerated input type of CreateApplePayBacking */
export type CreateApplePayBackingInput = {
  amount?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  locationId?: InputMaybe<Scalars['String']['input']>;
  paymentInstrumentName: Scalars['String']['input'];
  paymentNetwork: Scalars['String']['input'];
  projectId: Scalars['ID']['input'];
  refParam?: InputMaybe<Scalars['String']['input']>;
  rewardId?: InputMaybe<Scalars['ID']['input']>;
  token: Scalars['String']['input'];
  transactionIdentifier: Scalars['String']['input'];
};

/** Autogenerated return type of CreateApplePayBacking */
export type CreateApplePayBackingPayload = {
  __typename?: 'CreateApplePayBackingPayload';
  checkout?: Maybe<Checkout>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateAsset */
export type CreateAssetInput = {
  /** attachable attribute. ex: 'hero_media', 'avatar', ... */
  attachableAssoc: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** mime type. ex: 'image/png' */
  contentType: Scalars['String']['input'];
  fileName: Scalars['String']['input'];
  /** File size of asset in bytes. */
  fileSize: Scalars['Int']['input'];
  /** ID of the object to attach the asset to */
  id: Scalars['ID']['input'];
  s3Key: Scalars['String']['input'];
  updatedAt: Scalars['Int']['input'];
};

/** Autogenerated return type of CreateAsset */
export type CreateAssetPayload = {
  __typename?: 'CreateAssetPayload';
  asset?: Maybe<AttachedMedia>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateAttributionEvent */
export type CreateAttributionEventInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  eventName: Scalars['String']['input'];
  eventProperties?: InputMaybe<Scalars['JSON']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of CreateAttributionEvent */
export type CreateAttributionEventPayload = {
  __typename?: 'CreateAttributionEventPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  successful: Scalars['Boolean']['output'];
};

/** Autogenerated input type of CreateBackerReportSegment */
export type CreateBackerReportSegmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** If true, the segment will be duplicated */
  duplicate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of saved segment */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The project ID of the request */
  projectId: Scalars['ID']['input'];
  /** A set of search parameters to save for reëxecution */
  segmentBody?: InputMaybe<Scalars['JSON']['input']>;
  /** The ID of the segment to update. If null, a new segment will be created */
  segmentId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of CreateBackerReportSegment */
export type CreateBackerReportSegmentPayload = {
  __typename?: 'CreateBackerReportSegmentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  data?: Maybe<SavedSearchSegment>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of CreateBackerSurvey */
export type CreateBackerSurveyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateBackerSurvey */
export type CreateBackerSurveyPayload = {
  __typename?: 'CreateBackerSurveyPayload';
  /** The backer survey if creation was successful. */
  backerSurvey?: Maybe<BackerSurvey>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateBacking */
export type CreateBackingInput = {
  /** Optional, will default to combined reward minimums + shipping */
  amount?: InputMaybe<Scalars['String']['input']>;
  applePay?: InputMaybe<ApplePayInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  incremental?: InputMaybe<Scalars['Boolean']['input']>;
  locationId?: InputMaybe<Scalars['String']['input']>;
  paymentSourceId?: InputMaybe<Scalars['String']['input']>;
  paymentType?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
  refParam?: InputMaybe<Scalars['String']['input']>;
  /** Relay encoded Reward ID - legacy - mutually exclusive with reward_ids */
  rewardId?: InputMaybe<Scalars['ID']['input']>;
  /** List of Relay encoded Reward/Add-on IDs - mutually exclusive with reward_id */
  rewardIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  setupIntentClientSecret?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateBacking */
export type CreateBackingPayload = {
  __typename?: 'CreateBackingPayload';
  checkout?: Maybe<Checkout>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateCheckout */
export type CreateCheckoutInput = {
  amount?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  locationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
  refParam?: InputMaybe<Scalars['String']['input']>;
  rewardIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of CreateCheckout */
export type CreateCheckoutPayload = {
  __typename?: 'CreateCheckoutPayload';
  checkout?: Maybe<Checkout>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateCountrySignup */
export type CreateCountrySignupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  country: CountryCode;
  email: Scalars['Email']['input'];
};

/** Autogenerated return type of CreateCountrySignup */
export type CreateCountrySignupPayload = {
  __typename?: 'CreateCountrySignupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  isSuccessful: Scalars['Boolean']['output'];
};

/** Autogenerated input type of CreateCreatorInterview */
export type CreateCreatorInterviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateCreatorInterview */
export type CreateCreatorInterviewPayload = {
  __typename?: 'CreateCreatorInterviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  creatorInterview?: Maybe<CreatorInterview>;
};

/** Autogenerated input type of CreateEditorialLayoutType */
export type CreateEditorialLayoutTypeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Short description for the Editorial Layout */
  description?: InputMaybe<Scalars['String']['input']>;
  /** All the Editorial Modules for this layout */
  modules?: InputMaybe<Array<InputMaybe<EditorialModuleInput>>>;
  /** Slug for the Editorial Layout url */
  slug: Scalars['String']['input'];
  /** Title for the Editorial Layout */
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateEditorialLayoutType */
export type CreateEditorialLayoutTypePayload = {
  __typename?: 'CreateEditorialLayoutTypePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  layout?: Maybe<Layout>;
};

/** Autogenerated input type of CreateFlagging */
export type CreateFlaggingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  contentId: Scalars['ID']['input'];
  details?: InputMaybe<Scalars['String']['input']>;
  kind: NonDeprecatedFlaggingKind;
};

/** Autogenerated return type of CreateFlagging */
export type CreateFlaggingPayload = {
  __typename?: 'CreateFlaggingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  flagging?: Maybe<Flagging>;
};

/** Autogenerated input type of CreateFreeformPost */
export type CreateFreeformPostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateFreeformPost */
export type CreateFreeformPostPayload = {
  __typename?: 'CreateFreeformPostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  post?: Maybe<FreeformPost>;
};

/** Autogenerated input type of CreateOption */
export type CreateOptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  itemId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  prompt?: InputMaybe<Scalars['String']['input']>;
  values: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateOption */
export type CreateOptionPayload = {
  __typename?: 'CreateOptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  optionType?: Maybe<OptionType>;
};

/** Autogenerated input type of CreateOrUpdateBackingAddress */
export type CreateOrUpdateBackingAddressInput = {
  addressId: Scalars['ID']['input'];
  backingId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateOrUpdateBackingAddress */
export type CreateOrUpdateBackingAddressPayload = {
  __typename?: 'CreateOrUpdateBackingAddressPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of CreateOrUpdateItemTaxConfig */
export type CreateOrUpdateItemTaxConfigInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The item id */
  itemId: Scalars['ID']['input'];
  /** If the item is taxable */
  itemIsTaxExempt: Scalars['Boolean']['input'];
  /** The market value of the item */
  marketValue?: InputMaybe<Scalars['Int']['input']>;
  /** The surcharge cost for the item */
  surchargeCost?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of CreateOrUpdateItemTaxConfig */
export type CreateOrUpdateItemTaxConfigPayload = {
  __typename?: 'CreateOrUpdateItemTaxConfigPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item for the ID that was passed in */
  item: RewardItem;
};

/** Autogenerated input type of CreateOrUpdateShippingZone */
export type CreateOrUpdateShippingZoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IDs of locations included in the shipping zone */
  locationIds: Array<Scalars['ID']['input']>;
  /** The id of the project the shipping zone is under */
  projectId: Scalars['ID']['input'];
  /** The existing shipping zone id, if updating */
  shippingZoneId?: InputMaybe<Scalars['ID']['input']>;
  /** Weight ranges and cost data for the shipping zone */
  weightRanges: Array<WeightRangeInput>;
};

/** Autogenerated return type of CreateOrUpdateShippingZone */
export type CreateOrUpdateShippingZonePayload = {
  __typename?: 'CreateOrUpdateShippingZonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The project with updated shipping zones */
  project: Project;
};

/** Autogenerated input type of CreateOrUpdateTrackingNumber */
export type CreateOrUpdateTrackingNumberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  shipmentId: Scalars['ID']['input'];
  trackingNumber?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateOrUpdateTrackingNumber */
export type CreateOrUpdateTrackingNumberPayload = {
  __typename?: 'CreateOrUpdateTrackingNumberPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  shipment: Shipment;
};

/** Autogenerated input type of CreateOrUpdateVatConfig */
export type CreateOrUpdateVatConfigInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  locationVatNumbers: Array<LocationVatNumberInput>;
  /** The project id */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateOrUpdateVatConfig */
export type CreateOrUpdateVatConfigPayload = {
  __typename?: 'CreateOrUpdateVatConfigPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Project associated with the VAT Config */
  project: Project;
};

/** Autogenerated input type of CreatePaymentIntent */
export type CreatePaymentIntentInput = {
  /** total amount to be paid (eg. 10.55) */
  amount: Scalars['String']['input'];
  /** Current backing id for tracking purposes */
  backingId?: InputMaybe<Scalars['ID']['input']>;
  /** Current checkout id for tracking purposes */
  checkoutId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** if the payment is attributed to digital marketing (default: false) */
  digitalMarketingAttributed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Context in which this stripe intent is created */
  paymentIntentContext?: InputMaybe<StripeIntentContextTypes>;
  /** kickstarter project id */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreatePaymentIntent */
export type CreatePaymentIntentPayload = {
  __typename?: 'CreatePaymentIntentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** the stripe payment intent client secret used to complete a payment */
  clientSecret: Scalars['String']['output'];
};

/** Autogenerated input type of CreatePaymentSource */
export type CreatePaymentSourceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  intentClientSecret?: InputMaybe<Scalars['String']['input']>;
  paymentType?: InputMaybe<PaymentTypes>;
  reusable?: InputMaybe<Scalars['Boolean']['input']>;
  stripeCardId?: InputMaybe<Scalars['String']['input']>;
  stripeToken?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreatePaymentSource */
export type CreatePaymentSourcePayload = {
  __typename?: 'CreatePaymentSourcePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** @deprecated inconsistent use of GraphQL errors */
  errorMessage?: Maybe<Scalars['String']['output']>;
  isSuccessful: Scalars['Boolean']['output'];
  paymentSource?: Maybe<CreditCard>;
};

/** Autogenerated input type of CreatePledgeManagementReward */
export type CreatePledgeManagementRewardInput = {
  altText?: InputMaybe<Scalars['String']['input']>;
  amount: Scalars['Int']['input'];
  audienceData?: InputMaybe<AudienceInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  image?: InputMaybe<S3AssetInput>;
  items?: InputMaybe<Array<InputMaybe<RewardItemInput>>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  limitPerOrder?: InputMaybe<Scalars['Int']['input']>;
  localReceiptLocationId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  projectId: Scalars['ID']['input'];
  rewardType?: InputMaybe<RewardType>;
  shippingPreference: ShippingPreference;
  shippingRules?: InputMaybe<Array<InputMaybe<ShippingRuleInput>>>;
};

/** Autogenerated return type of CreatePledgeManagementReward */
export type CreatePledgeManagementRewardPayload = {
  __typename?: 'CreatePledgeManagementRewardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of CreateProjectDepositAccount */
export type CreateProjectDepositAccountInput = {
  accountBusinessType: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateProjectDepositAccount */
export type CreateProjectDepositAccountPayload = {
  __typename?: 'CreateProjectDepositAccountPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of CreateProjectImage */
export type CreateProjectImageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  contentType: Scalars['String']['input'];
  fileName: Scalars['String']['input'];
  fileSize: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
  s3Key: Scalars['String']['input'];
  updatedAt: Scalars['Int']['input'];
};

/** Autogenerated return type of CreateProjectImage */
export type CreateProjectImagePayload = {
  __typename?: 'CreateProjectImagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  image?: Maybe<Photo>;
};

/** Autogenerated input type of CreateProject */
export type CreateProjectInput = {
  additionalSubcategoryId?: InputMaybe<Scalars['ID']['input']>;
  categoryId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  countryCode: CountryCode;
  description?: InputMaybe<Scalars['String']['input']>;
  tag?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateProject */
export type CreateProjectPayload = {
  __typename?: 'CreateProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of CreateProjectPaymentSource */
export type CreateProjectPaymentSourceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  paymentType: CreditCardPaymentType;
  reusable: Scalars['Boolean']['input'];
  token: Scalars['String']['input'];
};

/** Autogenerated return type of CreateProjectPaymentSource */
export type CreateProjectPaymentSourcePayload = {
  __typename?: 'CreateProjectPaymentSourcePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  paymentSource?: Maybe<CreditCard>;
};

/** Autogenerated input type of CreateProjectUpdateRequest */
export type CreateProjectUpdateRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  location: ProjectUpdateRequestLocation;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateProjectUpdateRequest */
export type CreateProjectUpdateRequestPayload = {
  __typename?: 'CreateProjectUpdateRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** Autogenerated input type of CreateProjectVideo */
export type CreateProjectVideoInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  contentType: Scalars['String']['input'];
  fileName: Scalars['String']['input'];
  fileSize: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
  s3Key: Scalars['String']['input'];
  updatedAt: Scalars['Int']['input'];
};

/** Autogenerated return type of CreateProjectVideo */
export type CreateProjectVideoPayload = {
  __typename?: 'CreateProjectVideoPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  video?: Maybe<Video>;
};

/** Autogenerated input type of CreateQuestion */
export type CreateQuestionInput = {
  choiceSelectionLimit?: InputMaybe<Scalars['Int']['input']>;
  choices?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  optional: Scalars['Boolean']['input'];
  prompt: Scalars['String']['input'];
  questionableId: Scalars['ID']['input'];
  questionableType: QuestionableType;
  type: QuestionType;
};

/** Autogenerated return type of CreateQuestion */
export type CreateQuestionPayload = {
  __typename?: 'CreateQuestionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  question?: Maybe<Question>;
};

/** Autogenerated input type of CreateReward */
export type CreateRewardInput = {
  altText?: InputMaybe<Scalars['String']['input']>;
  amount: Scalars['Int']['input'];
  audienceData?: InputMaybe<AudienceInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endCondition?: InputMaybe<Scalars['Int']['input']>;
  endsAt?: InputMaybe<Scalars['Int']['input']>;
  estimatedDeliveryOn: Scalars['Date']['input'];
  image?: InputMaybe<S3AssetInput>;
  items?: InputMaybe<Array<InputMaybe<RewardItemInput>>>;
  latePledgeAmount?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  limitPerBacker?: InputMaybe<Scalars['Int']['input']>;
  localReceiptLocationId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  projectId: Scalars['ID']['input'];
  rewardType?: InputMaybe<RewardType>;
  shippingPreference?: InputMaybe<ShippingPreference>;
  shippingRates?: InputMaybe<Array<InputMaybe<ShippingRateInput>>>;
  shippingRules?: InputMaybe<Array<InputMaybe<ShippingRuleInput>>>;
  startCondition?: InputMaybe<Scalars['Int']['input']>;
  startsAt?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of CreateRewardItem */
export type CreateRewardItemInput = {
  altText?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  deliveryType: Scalars['String']['input'];
  image?: InputMaybe<S3AssetInput>;
  name: Scalars['String']['input'];
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateRewardItem */
export type CreateRewardItemPayload = {
  __typename?: 'CreateRewardItemPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  item?: Maybe<RewardItem>;
};

/** Autogenerated return type of CreateReward */
export type CreateRewardPayload = {
  __typename?: 'CreateRewardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of CreateSetupIntent */
export type CreateSetupIntentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** If sepa should be added to the payment method types */
  sepaEligible?: InputMaybe<Scalars['Boolean']['input']>;
  /** Context in which this stripe intent is created */
  setupIntentContext?: InputMaybe<StripeIntentContextTypes>;
};

/** Autogenerated return type of CreateSetupIntent */
export type CreateSetupIntentPayload = {
  __typename?: 'CreateSetupIntentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  clientSecret: Scalars['String']['output'];
};

/** Autogenerated input type of CreateSheetForProject */
export type CreateSheetForProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateSheetForProject */
export type CreateSheetForProjectPayload = {
  __typename?: 'CreateSheetForProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  sheetsUrl?: Maybe<Scalars['String']['output']>;
  spreadsheetData?: Maybe<Array<Maybe<SpreadsheetDatum>>>;
};

/** Autogenerated input type of CreateTrackEvent */
export type CreateTrackEventInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  eventName: Scalars['String']['input'];
  eventProperties?: InputMaybe<Scalars['JSON']['input']>;
};

/** Autogenerated return type of CreateTrackEvent */
export type CreateTrackEventPayload = {
  __typename?: 'CreateTrackEventPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  successful: Scalars['Boolean']['output'];
};

/** Autogenerated input type of CreateUser */
export type CreateUserInput = {
  checkoutId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  emailConfirmation: Scalars['String']['input'];
  n: Scalars['String']['input'];
  name: Scalars['String']['input'];
  /** If the user agrees to opt into weekly newsletters */
  optIntoNewsletters?: InputMaybe<Scalars['Boolean']['input']>;
  /** If the user agrees to opt into receiving surveys for user research */
  optIntoUserResearch?: InputMaybe<Scalars['Boolean']['input']>;
  password: Scalars['String']['input'];
  /** Supply if creating an account via backing flow -- used for tracking purposes */
  projectPid?: InputMaybe<Scalars['String']['input']>;
  recaptchaV2Token?: InputMaybe<Scalars['String']['input']>;
  recaptchaV3Token?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateUser */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of CreateUserSlug */
export type CreateUserSlugInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  slug: Scalars['String']['input'];
};

/** Autogenerated return type of CreateUserSlug */
export type CreateUserSlugPayload = {
  __typename?: 'CreateUserSlugPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of CreateUserUrls */
export type CreateUserUrlsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  url: Scalars['String']['input'];
};

/** Autogenerated return type of CreateUserUrls */
export type CreateUserUrlsPayload = {
  __typename?: 'CreateUserUrlsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of CreateVideoTrack */
export type CreateVideoTrackInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  languageCode: CaptionLanguageCode;
  videoId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateVideoTrack */
export type CreateVideoTrackPayload = {
  __typename?: 'CreateVideoTrackPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  videoTrack?: Maybe<VideoTrack>;
};

/** Autogenerated input type of CreateWave */
export type CreateWaveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The project id */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateWave */
export type CreateWavePayload = {
  __typename?: 'CreateWavePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** A creator interview. */
export type CreatorInterview = Commentable & Node & Postable & {
  __typename?: 'CreatorInterview';
  /** Actions you can currently perform */
  actions: PostActions;
  /** The interview answers associated with the creator interview. */
  answers: InterviewAnswerConnection;
  /** The author of the project update. */
  author: User;
  /** The author role of the project update. */
  authorRole: PostAuthorRole;
  /** True if the current user can comment (considers restrictions) */
  canComment: Scalars['Boolean']['output'];
  /** True if the current user can comment (does not consider restrictions) */
  canCommentSansRestrictions: Scalars['Boolean']['output'];
  /** Whether a user can request an update about this project from the Creator */
  canUserRequestUpdate: Scalars['Boolean']['output'];
  /** List of comments on the commentable */
  comments?: Maybe<CommentConnection>;
  /** Comment count - defaults to root level comments only */
  commentsCount: Scalars['Int']['output'];
  /** The date the project update was created. */
  createdAt: Scalars['DateTime']['output'];
  /** The prompt for the creator interview. */
  creatorPrompt: CreatorPrompt;
  /** All rewards belonging to a post that were specifically marked by a creator to be excluded from receiving a post notification. This does not, however, include the no reward tier. */
  excludedRewards?: Maybe<RewardConnection>;
  /** Users that have liked this project update. */
  fans?: Maybe<UserConnection>;
  /** True if creator has excluded the no reward tier from receiving a post notification. */
  hasExcludedNoRewardTier?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  /** All rewards that were marked to recieve a post notification, excluding the no reward tier. */
  includedRewards?: Maybe<RewardConnection>;
  /** Whether or not the current user has liked this project update. */
  isLiked: Scalars['Boolean']['output'];
  /** True if marked as a public public post, false if the post is backers only. */
  isPublic: Scalars['Boolean']['output'];
  /**
   * True if the post's content is visible to the user.
   * @deprecated Query the read field in post abilities instead.
   */
  isVisible: Scalars['Boolean']['output'];
  /** The number of likes a post has. */
  likesCount: Scalars['Int']['output'];
  /** The next post. */
  nextPost?: Maybe<Postable>;
  /** The project update number. */
  number: Scalars['Int']['output'];
  /** The date the project update was pinned. */
  pinnedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The previous post. */
  previousPost?: Maybe<Postable>;
  /** Project that belongs to post. */
  project: Project;
  /** The root project id under which the comment is nested */
  projectRelayId: Scalars['ID']['output'];
  /** The date the project update was published. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** How much time a creator or collaborator has left to edit the post. */
  timeLeftToEdit?: Maybe<Scalars['String']['output']>;
  /** The project update's title. */
  title?: Maybe<Scalars['String']['output']>;
  /** The post type. */
  type: Post;
  /** The date the project update was last edited. */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The project update's URL. */
  url: Scalars['String']['output'];
};


/** A creator interview. */
export type CreatorInterviewAnswersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  withBlank?: InputMaybe<Scalars['Boolean']['input']>;
  withSkipped?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A creator interview. */
export type CreatorInterviewCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A creator interview. */
export type CreatorInterviewCommentsCountArgs = {
  withReplies?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A creator interview. */
export type CreatorInterviewExcludedRewardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A creator interview. */
export type CreatorInterviewFansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A creator interview. */
export type CreatorInterviewIncludedRewardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A set of interview questions to be answered. */
export type CreatorPrompt = Node & {
  __typename?: 'CreatorPrompt';
  id: Scalars['ID']['output'];
  /** All the questions in a creator prompt. */
  questions: InterviewQuestionConnection;
  /** The creator prompt title. */
  title: Scalars['String']['output'];
};


/** A set of interview questions to be answered. */
export type CreatorPromptQuestionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type CreatorToolsPaths = {
  __typename?: 'CreatorToolsPaths';
  /** The advanced analytics path */
  advancedAnalyticsPath: Scalars['String']['output'];
  /** The backer report path */
  backerReportPath: Scalars['String']['output'];
  /** The backer survey path */
  backerSurveyPath: Scalars['String']['output'];
  /** The project collaborators path */
  collaboratorsPath: Scalars['String']['output'];
  /** The contact path */
  contactPath: Scalars['String']['output'];
  /** The creator faq path */
  creatorFaqPath: Scalars['String']['output'];
  /** The creator handbook path */
  creatorHandbookPath: Scalars['String']['output'];
  /** The project dashboard path */
  dashboardPath: Scalars['String']['output'];
  /** The path to the disbursement page for a successful post-pledge redemption payout */
  disbursementPath?: Maybe<Scalars['String']['output']>;
  /** The edit rewards project path */
  editRewardsProjectPath: Scalars['String']['output'];
  /** The fulfillment dashboard path */
  fulfillmentDashboardPath: Scalars['String']['output'];
  /** The help resources path */
  helpResourcesPath: Scalars['String']['output'];
  /** The messages thread path */
  messageThreadsPath: Scalars['String']['output'];
  /** The path for backers to access the project's pledge manager */
  pledgeManagerRedeemUrl: Scalars['String']['output'];
  /** The path to access creator pledge redemption tools */
  pledgeRedemptionPath: Scalars['String']['output'];
  /** The draft posts path */
  postsDashboardDraftsPath: Scalars['String']['output'];
  /** The published posts path */
  postsDashboardPublishedPath: Scalars['String']['output'];
  /** The project build path */
  projectBuildPath: Scalars['String']['output'];
  /** The project path */
  projectPath: Scalars['String']['output'];
};

/** A credit card on file. */
export type CreditCard = {
  __typename?: 'CreditCard';
  /** When the credit card expires. */
  expirationDate: Scalars['Date']['output'];
  /** The card ID */
  id: Scalars['String']['output'];
  /** The last four digits of the credit card number. */
  lastFour: Scalars['String']['output'];
  /** The card type, but in lowercase. */
  lowercaseType: LowercaseCreditCardTypes;
  /** The card's payment type. */
  paymentType: CreditCardPaymentType;
  /** The card's state. */
  state: CreditCardState;
  /** Stripe card id */
  stripeCardId: Scalars['String']['output'];
  /** The card type. */
  type: CreditCardTypes;
};

/** An edge in a connection. */
export type CreditCardEdge = {
  __typename?: 'CreditCardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CreditCard>;
};

/** Credit card payment types. */
export enum CreditCardPaymentType {
  AndroidPay = 'ANDROID_PAY',
  ApplePay = 'APPLE_PAY',
  BankAccount = 'BANK_ACCOUNT',
  CreditCard = 'CREDIT_CARD'
}

/** States of Credit Cards */
export enum CreditCardState {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE',
  Unauthorized = 'UNAUTHORIZED',
  Verifying = 'VERIFYING'
}

/** Credit card types. */
export enum CreditCardTypes {
  Amex = 'AMEX',
  Diners = 'DINERS',
  Discover = 'DISCOVER',
  Jcb = 'JCB',
  Mastercard = 'MASTERCARD',
  Unionpay = 'UNIONPAY',
  Visa = 'VISA'
}

/** Curated collections of projects, represented by badges. */
export type CuratedCollection = {
  __typename?: 'CuratedCollection';
  badge?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

/** A curated page */
export type CuratedPage = Node & {
  __typename?: 'CuratedPage';
  /** A curated page's description. */
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** A curated page's unique URL identifier. */
  slug: Scalars['String']['output'];
  /** A curated page's title. */
  title: Scalars['String']['output'];
};

/** An edge in a connection. */
export type CuratedPageEdge = {
  __typename?: 'CuratedPageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CuratedPage>;
};

/** A list of Iso4217–supported currencies. */
export enum CurrencyCode {
  Aud = 'AUD',
  Cad = 'CAD',
  Chf = 'CHF',
  Dkk = 'DKK',
  Eur = 'EUR',
  Gbp = 'GBP',
  Hkd = 'HKD',
  Jpy = 'JPY',
  Mxn = 'MXN',
  Nok = 'NOK',
  Nzd = 'NZD',
  Pln = 'PLN',
  Sek = 'SEK',
  Sgd = 'SGD',
  Usd = 'USD'
}

/** Autogenerated input type of DeactivateProjectCollaborator */
export type DeactivateProjectCollaboratorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The project id */
  projectId: Scalars['ID']['input'];
  /** The collaborator's user id */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeactivateProjectCollaborator */
export type DeactivateProjectCollaboratorPayload = {
  __typename?: 'DeactivateProjectCollaboratorPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** Autogenerated input type of DeactivateProjectPrelaunch */
export type DeactivateProjectPrelaunchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeactivateProjectPrelaunch */
export type DeactivateProjectPrelaunchPayload = {
  __typename?: 'DeactivateProjectPrelaunchPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of DeleteAddress */
export type DeleteAddressInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  fulfillmentAddressId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteAddress */
export type DeleteAddressPayload = {
  __typename?: 'DeleteAddressPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Success if address was deleted successfully */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeleteAsset */
export type DeleteAssetInput = {
  asset_id: Scalars['ID']['input'];
  attachable_id: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DeleteAsset */
export type DeleteAssetPayload = {
  __typename?: 'DeleteAssetPayload';
  attachable: Attachable;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteBackerReportSegment */
export type DeleteBackerReportSegmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the segment to delete */
  segmentId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteBackerReportSegment */
export type DeleteBackerReportSegmentPayload = {
  __typename?: 'DeleteBackerReportSegmentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Indicates if the deletion was successful */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeleteBackerSurvey */
export type DeleteBackerSurveyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteBackerSurvey */
export type DeleteBackerSurveyPayload = {
  __typename?: 'DeleteBackerSurveyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Succeeds if backer survey is deleted. */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeleteComment */
export type DeleteCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The comment ID */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteComment */
export type DeleteCommentPayload = {
  __typename?: 'DeleteCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  commentable?: Maybe<Project>;
};

/** Autogenerated input type of DeleteOption */
export type DeleteOptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  optionTypeId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteOption */
export type DeleteOptionPayload = {
  __typename?: 'DeleteOptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that the deleted option type was associated with */
  item: RewardItem;
  /** Succeeds if option_type is deleted. */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeletePost */
export type DeletePostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeletePost */
export type DeletePostPayload = {
  __typename?: 'DeletePostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  post?: Maybe<Postable>;
};

/** Autogenerated input type of DeleteProjectComment */
export type DeleteProjectCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The comment ID */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectComment */
export type DeleteProjectCommentPayload = {
  __typename?: 'DeleteProjectCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of DeleteProjectImage */
export type DeleteProjectImageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectImage */
export type DeleteProjectImagePayload = {
  __typename?: 'DeleteProjectImagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of DeleteProject */
export type DeleteProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  password: Scalars['String']['input'];
};

/** Autogenerated return type of DeleteProject */
export type DeleteProjectPayload = {
  __typename?: 'DeleteProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  creator?: Maybe<User>;
};

/** Autogenerated input type of DeleteProjectVideo */
export type DeleteProjectVideoInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The project ID */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectVideo */
export type DeleteProjectVideoPayload = {
  __typename?: 'DeleteProjectVideoPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of DeleteQuestion */
export type DeleteQuestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  questionId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteQuestion */
export type DeleteQuestionPayload = {
  __typename?: 'DeleteQuestionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Succeeds if question is deleted. */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeleteReward */
export type DeleteRewardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The reward ID */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteRewardItem */
export type DeleteRewardItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The reward item ID */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteRewardItem */
export type DeleteRewardItemPayload = {
  __typename?: 'DeleteRewardItemPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated return type of DeleteReward */
export type DeleteRewardPayload = {
  __typename?: 'DeleteRewardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of DeleteShippingZone */
export type DeleteShippingZoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the to be deleted shipping */
  shippingZoneId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteShippingZone */
export type DeleteShippingZonePayload = {
  __typename?: 'DeleteShippingZonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** Autogenerated input type of DeleteStockLocation */
export type DeleteStockLocationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  stockLocationId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteStockLocation */
export type DeleteStockLocationPayload = {
  __typename?: 'DeleteStockLocationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Project associated with the stock location */
  project: Project;
};

/** Autogenerated input type of DeleteUserUrls */
export type DeleteUserUrlsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  urlId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteUserUrls */
export type DeleteUserUrlsPayload = {
  __typename?: 'DeleteUserUrlsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of DeleteVideoTrack */
export type DeleteVideoTrackInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteVideoTrack */
export type DeleteVideoTrackPayload = {
  __typename?: 'DeleteVideoTrackPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  video?: Maybe<Video>;
};

/** A deposit account. */
export type DepositAccount = {
  __typename?: 'DepositAccount';
  /** The deposit account business type. */
  accountBusinessType?: Maybe<DepositAccountBusiness>;
  /** The last four digits of the account number. */
  accountLastFour?: Maybe<Scalars['String']['output']>;
  /** Identity verifications for anyone owning > 25% of the company (if the identity is a legal entity) */
  additionalOwners?: Maybe<Array<Maybe<AdditionalOwner>>>;
  /** The company associated with this deposit account. */
  company?: Maybe<Company>;
  /** The name associated with either the associated company or identity */
  contactName?: Maybe<Scalars['String']['output']>;
  /** The Rosie ID for this DepositAccount */
  id: Scalars['ID']['output'];
  /** The identity associated with this deposit account. */
  identity?: Maybe<Identity>;
  /** Whether the deposit account is in the EU. */
  isInEuropeanUnion: Scalars['Boolean']['output'];
  /** Whether the deposit account is in the UK. */
  isInUnitedKingdom: Scalars['Boolean']['output'];
  /** Has the Stripe Account been created for this deposit account. */
  isStripeAccountCreated: Scalars['Boolean']['output'];
  /** The routing number. */
  routingNumber?: Maybe<Scalars['String']['output']>;
  /** The deposit account's state. */
  state: DepositAccountState;
  /** Either the company or identity street address */
  streetAddress?: Maybe<StreetAddress>;
};

/** Deposit account business types. */
export enum DepositAccountBusiness {
  Company = 'company',
  Individual = 'individual',
  NonProfit = 'non_profit'
}

/** Deposit account states. */
export enum DepositAccountState {
  Active = 'ACTIVE',
  Failed = 'FAILED',
  Inactive = 'INACTIVE',
  Unauthorized = 'UNAUTHORIZED',
  Verifying = 'VERIFYING'
}

/** An access code or URL for retrieving a digital reward */
export type DigitalAccessResource = {
  __typename?: 'DigitalAccessResource';
  /** A description of the resource or instructions for activation */
  description: Scalars['String']['output'];
  /** The project associated with the reward */
  project: Project;
  /** The access code or URL */
  resource: Scalars['String']['output'];
};

/** Autogenerated input type of DislikeProject */
export type DislikeProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the project that the user has disliked */
  id: Scalars['ID']['input'];
  /** The context or page that the user disliked this project from. Used for tracking */
  trackingContext?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DislikeProject */
export type DislikeProjectPayload = {
  __typename?: 'DislikeProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
  user?: Maybe<User>;
};

/** Autogenerated input type of DistributeDigitalAccessResources */
export type DistributeDigitalAccessResourcesInput = {
  backerIds: Array<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
  resources: Scalars['String']['input'];
};

/** Autogenerated return type of DistributeDigitalAccessResources */
export type DistributeDigitalAccessResourcesPayload = {
  __typename?: 'DistributeDigitalAccessResourcesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Editorial tool to create and modify content modules on discovery pages */
export type Editorial = Article | BespokeComponent | EditorialRichText | ExploreSubcategories | FeaturedProjectCollection | Header | MastheadImage | NewsCollection | NewsletterSignUp | ProjectCollection | PromoCollection | ShortText | SingleProjectContainer | SurveyEmbed;

/** The connection type for Editorial. */
export type EditorialConnection = {
  __typename?: 'EditorialConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EditorialEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Editorial>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  slug: Scalars['String']['output'];
};

/** An edge in a connection. */
export type EditorialEdge = {
  __typename?: 'EditorialEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Editorial>;
};

/** Editorial Module. */
export type EditorialModuleInput = {
  /** Module data */
  data: Scalars['JSON']['input'];
  /** Module GraphQL id */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Order of the Module */
  sequence?: InputMaybe<Scalars['Int']['input']>;
  /** Module type */
  type: EditorialModuleType;
};

/** Different types of Editorial modules. */
export enum EditorialModuleType {
  /** Article */
  Article = 'Article',
  /** BespokeComponent */
  BespokeComponent = 'BespokeComponent',
  /** EditorialRichText */
  EditorialRichText = 'EditorialRichText',
  /** ExploreSubcategories */
  ExploreSubcategories = 'ExploreSubcategories',
  /** FeaturedProjectCollection */
  FeaturedProjectCollection = 'FeaturedProjectCollection',
  /** Header */
  Header = 'Header',
  /** MastheadImage */
  MastheadImage = 'MastheadImage',
  /** NewsCollection */
  NewsCollection = 'NewsCollection',
  /** NewsletterSignUp */
  NewsletterSignUp = 'NewsletterSignUp',
  /** ProjectCollection */
  ProjectCollection = 'ProjectCollection',
  /** PromoCollection */
  PromoCollection = 'PromoCollection',
  /** ShortText */
  ShortText = 'ShortText',
  /** SingleProjectContainer */
  SingleProjectContainer = 'SingleProjectContainer',
  /** SurveyEmbed */
  SurveyEmbed = 'SurveyEmbed'
}

/** An Editorial Page */
export type EditorialPage = {
  __typename?: 'EditorialPage';
  /** When this page was created */
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** The page name. */
  name: Scalars['String']['output'];
  /** The page type. */
  pageType: EditorialPageType;
  /** The currently published revision. Can be null. */
  publishedRevision?: Maybe<EditorialRevision>;
  /** The slug of this page. Can include `/'. */
  slug: Scalars['String']['output'];
  /** When this page was last updated */
  updatedAt: Scalars['DateTime']['output'];
};

/** An Editorial Page fully loaded with admin only fields */
export type EditorialPageForAdmin = {
  __typename?: 'EditorialPageForAdmin';
  /** Rich Text Editor property for attachableAssoc. */
  attachableAssoc: Scalars['String']['output'];
  /** Rich Text Editor property for attachableId. */
  attachableId: Scalars['String']['output'];
  /** When this page was created */
  createdAt: Scalars['DateTime']['output'];
  /** This page's editor. */
  editor: User;
  /** (Deprecated) Slug where `/` is replaced by `-`. Used for ref tag and admin routing. */
  flatSlug: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** An identifier for the page. Used for ref tags. */
  identifier: Scalars['String']['output'];
  /** Last revision */
  lastRevision: EditorialRevisionForAdmin;
  /** A link to the Looker Dashboard for this page, if any */
  lookerDashboardUrl?: Maybe<Scalars['String']['output']>;
  /** The page name. */
  name: Scalars['String']['output'];
  /** The page type. */
  pageType: EditorialPageType;
  /** Published revision */
  publishedRevision?: Maybe<EditorialRevisionForAdmin>;
  /** The revisions in reverse chronological order. */
  revisions: EditorialRevisionForAdminConnection;
  /** The slug of this page. Can include `/'. */
  slug: Scalars['String']['output'];
  /** Stats for the past 30 days */
  stats: EditorialPageStats;
  /** When this page was last updated */
  updatedAt: Scalars['DateTime']['output'];
};


/** An Editorial Page fully loaded with admin only fields */
export type EditorialPageForAdminRevisionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for EditorialPageForAdmin. */
export type EditorialPageForAdminConnection = {
  __typename?: 'EditorialPageForAdminConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EditorialPageForAdminEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EditorialPageForAdmin>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type EditorialPageForAdminEdge = {
  __typename?: 'EditorialPageForAdminEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EditorialPageForAdmin>;
};

/** Direction to sort Editorial Pages */
export enum EditorialPageSortDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

/** Field you can sort Editorial Pages by */
export enum EditorialPageSortField {
  CreatedAt = 'CREATED_AT',
  Name = 'NAME',
  Slug = 'SLUG',
  UpdatedAt = 'UPDATED_AT'
}

export type EditorialPageStats = {
  __typename?: 'EditorialPageStats';
  backingsCount: Scalars['Int']['output'];
  backingsUsd: Scalars['Int']['output'];
  pageViews: Scalars['Int']['output'];
  projectClicks: Scalars['Int']['output'];
};

/** Editorial page types. */
export enum EditorialPageType {
  Article = 'article',
  Category = 'category',
  International = 'international',
  Prompt = 'prompt',
  Resource = 'resource'
}

/** Layouts for Editorial Promo Collections */
export enum EditorialPromoCollectionLayout {
  ThreeColumns = 'THREE_COLUMNS',
  TwoColumns = 'TWO_COLUMNS'
}

/** Visual themes for Editorial Promo Collections */
export enum EditorialPromoCollectionTheme {
  Flex = 'FLEX',
  Promo = 'PROMO'
}

/** An Editorial Page Revision */
export type EditorialRevision = {
  __typename?: 'EditorialRevision';
  /** The page metadata */
  metadata: EditorialRevisionMetadata;
  /** The modules for the editorial revision */
  modules: Array<Editorial>;
  /** The page that this revision belongs to */
  page: EditorialPage;
  /** The revision uuid */
  uuid: Scalars['String']['output'];
};

/** An Editorial Page Revision fully loaded with admin attributes */
export type EditorialRevisionForAdmin = {
  __typename?: 'EditorialRevisionForAdmin';
  /** The person who created this revision */
  author: User;
  /** When this editorial layout was created */
  createdAt: Scalars['DateTime']['output'];
  /** The page metadata */
  metadata: EditorialRevisionMetadata;
  /** The modules for the editorial revision */
  modules: Array<Editorial>;
  /** The page that this revision belongs to */
  page: EditorialPage;
  /** Is the editorial revision published? */
  published: Scalars['Boolean']['output'];
  /** When the editorial revision was published. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The person who published this revision */
  publisher?: Maybe<User>;
  /** The sequence number for this revision */
  sequence: Scalars['Int']['output'];
  /** Counts of translated / total strings for each locale */
  translationStatus: Array<EditorialTranslationStatus>;
  /** When this editorial layout was created */
  updatedAt: Scalars['DateTime']['output'];
  /** The revision uuid */
  uuid: Scalars['String']['output'];
};

/** The connection type for EditorialRevisionForAdmin. */
export type EditorialRevisionForAdminConnection = {
  __typename?: 'EditorialRevisionForAdminConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EditorialRevisionForAdminEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EditorialRevisionForAdmin>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EditorialRevisionForAdminEdge = {
  __typename?: 'EditorialRevisionForAdminEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EditorialRevisionForAdmin>;
};

export type EditorialRevisionMetadata = {
  __typename?: 'EditorialRevisionMetadata';
  /** The revision description */
  description: Scalars['String']['output'];
  /** The revision og_image */
  ogImage?: Maybe<Scalars['String']['output']>;
  /** The revision title */
  title: Scalars['String']['output'];
};

/** A Rich Text block for Editorial pages */
export type EditorialRichText = {
  __typename?: 'EditorialRichText';
  /** AdminUI: Rich Text Editor property for attachableAssoc. */
  attachableAssoc: Scalars['String']['output'];
  /** AdminUI: Rich Text Editor property for attachableId. */
  attachableId: Scalars['String']['output'];
  /** The html body of the rich text module. */
  body: Scalars['String']['output'];
  id: Scalars['ID']['output'];
};

export type EditorialTranslationStatus = {
  __typename?: 'EditorialTranslationStatus';
  /** The language */
  locale: EditorialTranslationStatusLocale;
  /** Total number of strings */
  total: Scalars['Int']['output'];
  /** Number of strings translated */
  translated: Scalars['Int']['output'];
};

/** Editorial locale */
export enum EditorialTranslationStatusLocale {
  De = 'de',
  Es = 'es',
  Fr = 'fr',
  It = 'it',
  Ja = 'ja',
  Zh = 'zh'
}

/** Autogenerated input type of EndLatePledges */
export type EndLatePledgesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of EndLatePledges */
export type EndLatePledgesPayload = {
  __typename?: 'EndLatePledgesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

export type EnvironmentalCommitment = {
  __typename?: 'EnvironmentalCommitment';
  /** The type of environmental commitment */
  commitmentCategory: EnvironmentalCommitmentCategory;
  /** An environmental commitment description */
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
};

/** The type of environmental commitment for a project. */
export enum EnvironmentalCommitmentCategory {
  /** environmentally friendly factories */
  EnvironmentallyFriendlyFactories = 'environmentally_friendly_factories',
  /** long lasting design */
  LongLastingDesign = 'long_lasting_design',
  /** reusability and recyclability */
  ReusabilityAndRecyclability = 'reusability_and_recyclability',
  /** something else */
  SomethingElse = 'something_else',
  /** sustainable distribution */
  SustainableDistribution = 'sustainable_distribution',
  /** sustainable materials */
  SustainableMaterials = 'sustainable_materials'
}

/** An environmental commitment for a project. */
export type EnvironmentalCommitmentInput = {
  commitmentCategory: EnvironmentalCommitmentCategory;
  description: Scalars['String']['input'];
  id: Scalars['ID']['input'];
};

/** Top subcategories */
export type ExploreSubcategories = {
  __typename?: 'ExploreSubcategories';
  /** The root category */
  category: Category;
  /** The root category database id */
  categoryId: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  /** Top subcategories ordered by number of live projects descending */
  subcategories: Array<ExploreSubcategory>;
};


/** Top subcategories */
export type ExploreSubcategoriesSubcategoriesArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};

/** A subcategory for ExploreSubcategories */
export type ExploreSubcategory = {
  __typename?: 'ExploreSubcategory';
  /** The category database id */
  categoryId: Scalars['Int']['output'];
  /** The subcategory name for the current language */
  name: Scalars['String']['output'];
  /** The projects to display in this collection */
  projects: Array<Project>;
};


/** A subcategory for ExploreSubcategories */
export type ExploreSubcategoryProjectsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};

/** A FAQ question and answer for a project. */
export type FaqInput = {
  answer: Scalars['String']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  position: Scalars['Int']['input'];
  question: Scalars['String']['input'];
};

/** The list of available public features */
export enum Feature {
  Gr = 'GR',
  IbanFlexibility = 'IBAN_flexibility',
  KdsMessagesApp = 'KDS_messages_app',
  KdsMessagesAppBackerFilter = 'KDS_messages_app_backer_filter',
  Pl = 'PL',
  Si = 'SI',
  AccountsUpgrade = 'accounts_upgrade',
  AddressCollection_2024 = 'address_collection_2024',
  AdminCheckoutDebugger = 'admin_checkout_debugger',
  AndroidBraze = 'android_braze',
  AndroidSegment = 'android_segment',
  BackerReportUpdate_2024 = 'backer_report_update_2024',
  BackersCanChoosePlotV1 = 'backers_can_choose_plot_v1',
  BackingsDashV2_2025 = 'backings_dash_v2_2025',
  CaCurrencySelector = 'ca_currency_selector',
  ChCurrencySelector = 'ch_currency_selector',
  CkeditorProjectUpdates = 'ckeditor_project_updates',
  CopyAddons = 'copy_addons',
  CopyRewards = 'copy_rewards',
  CreatorDemographicsSurvey = 'creator_demographics_survey',
  CreatorExperience_2025 = 'creator_experience_2025',
  CreatorNavRefresh = 'creator_nav_refresh',
  CreatorOnboardingFlow_2021 = 'creator_onboarding_flow_2021',
  CreatorOsatSurvey_2022 = 'creator_osat_survey_2022',
  CreatorTab_2025 = 'creator_tab_2025',
  DatalakeFeEvents = 'datalake_fe_events',
  DefaultToCampaignOnMobile = 'default_to_campaign_on_mobile',
  DelayBackerTrustModule_2024 = 'delay_backer_trust_module_2024',
  DeviceComponents = 'device_components',
  DigitalRewards_2025 = 'digital_rewards_2025',
  DisableManualCreateStripeElementsPostalCode = 'disable_manual_create_stripe_elements_postal_code',
  DiscoverUi_2025 = 'discover_ui_2025',
  DkCurrencySelector = 'dk_currency_selector',
  EcovadisComponent_2023 = 'ecovadis_component_2023',
  EmojiLocale = 'emoji_locale',
  EnableSpotlightBgImage = 'enable_spotlight_bg_image',
  FeaturedProjectMobileOptimizations = 'featured_project_mobile_optimizations',
  FeaturedRewards_2025 = 'featured_rewards_2025',
  FundingSheet = 'funding_sheet',
  HideFacebookLoginButton_2022 = 'hide_facebook_login_button_2022',
  HkBankAccountHolderName = 'hk_bank_account_holder_name',
  HowItWorks = 'how_it_works',
  IdentityVerificationProjectOverview = 'identity_verification_project_overview',
  ImageUploaderAltText = 'image_uploader_alt_text',
  ImprovedTaxCodeCollection_2025 = 'improved_tax_code_collection_2025',
  InsideVoicesFooter = 'inside_voices_footer',
  IosBackerDashboard = 'ios_backer_dashboard',
  IosBraze = 'ios_braze',
  IosCrashlytics = 'ios_crashlytics',
  IosEmailVerificationFlow = 'ios_email_verification_flow',
  IosEmailVerificationSkip = 'ios_email_verification_skip',
  IosFavoriteCategories = 'ios_favorite_categories',
  IosHockeyApp = 'ios_hockey_app',
  IosI18n = 'ios_i18n',
  IosKoala = 'ios_koala',
  IosLiveStreamChat = 'ios_live_stream_chat',
  IosLiveStreamDiscovery = 'ios_live_stream_discovery',
  IosLiveStreams = 'ios_live_streams',
  IosMixpanel = 'ios_mixpanel',
  IosNativeCheckout = 'ios_native_checkout',
  IosNativeCheckoutPledgeView = 'ios_native_checkout_pledge_view',
  IosNewRelic = 'ios_new_relic',
  IosQualtrics = 'ios_qualtrics',
  IosScrollOutputObserveForUi = 'ios_scroll_output_observe_for_ui',
  IosSegment = 'ios_segment',
  IosTappableCategoryLocation = 'ios_tappable_category_location',
  IosWhTout = 'ios_wh_tout',
  Ksr10BuildOverview = 'ksr10_build_overview',
  LatePledgesLearnMoreCta = 'late_pledges_learn_more_cta',
  Make_100_2020 = 'make_100_2020',
  MeGenerativeArt = 'me_generative_art',
  MessageArchiving = 'message_archiving',
  MessageSpam = 'message_spam',
  NativeCreatorBreakdownChart = 'native_creator_breakdown_chart',
  NewPmBackers_2025 = 'new_pm_backers_2025',
  NoCurrencySelector = 'no_currency_selector',
  NotificationBannerUpdate_2024 = 'notification_banner_update_2024',
  PaymentElementProjectBuild_2022 = 'payment_element_project_build_2022',
  PaymentsStripeLinkOnCheckout = 'payments_stripe_link_on_checkout',
  PinnedPostsOnFeed = 'pinned_posts_on_feed',
  PledgeManagementBackerReport = 'pledge_management_backer_report',
  PledgeManagementBeta = 'pledge_management_beta',
  PledgeManagementRewardSetup = 'pledge_management_reward_setup',
  PledgeManagementSelfLaunch_2025 = 'pledge_management_self_launch_2025',
  PledgeOverTimeGa_2025 = 'pledge_over_time_ga_2025',
  PledgeProjectsOverview_2024 = 'pledge_projects_overview_2024',
  PledgeProjectsOverviewIos_2024 = 'pledge_projects_overview_ios_2024',
  PledgeUpgrade_2025 = 'pledge_upgrade_2025',
  PmOpenBetaV1_2025 = 'pm_open_beta_v1_2025',
  PostCampaignBackings_2024 = 'post_campaign_backings_2024',
  PrelaunchStoryEditor = 'prelaunch_story_editor',
  PrelaunchStoryException = 'prelaunch_story_exception',
  ProjectBuildMilestones = 'project_build_milestones',
  ProjectBuildRewardsExplorer = 'project_build_rewards_explorer',
  ProjectBuildZendesk = 'project_build_zendesk',
  ProjectClassifiers_2025 = 'project_classifiers_2025',
  ProjectHeaderMediaCarouselHero = 'project_header_media_carousel_hero',
  ProjectPrelaunchSummaries = 'project_prelaunch_summaries',
  ProjectUpdateRequests = 'project_update_requests',
  Qualtrics = 'qualtrics',
  ReactBackedProjects = 'react_backed_projects',
  RecentSearches_2025 = 'recent_searches_2025',
  RemoveEventSourcing_2025 = 'remove_event_sourcing_2025',
  ResetBackerSurvey_2024 = 'reset_backer_survey_2024',
  RichTextEmbedifier = 'rich_text_embedifier',
  SaveProjectExperiment = 'save_project_experiment',
  SeCurrencySelector = 'se_currency_selector',
  SecretRewards_2025 = 'secret_rewards_2025',
  SegmentHideProjectDeadlineProperty = 'segment_hide_project_deadline_property',
  SegmentTrackingEvents = 'segment_tracking_events',
  SepaDebitPaymentElement = 'sepa_debit_payment_element',
  ShowCreativeDownload_2024ReportInNav = 'show_creative_download_2024_report_in_nav',
  ShowPostsFeed = 'show_posts_feed',
  SkuEditing_2024 = 'sku_editing_2024',
  StackedRecsOnMobile = 'stacked_recs_on_mobile',
  SuperbackerProgress = 'superbacker_progress',
  SurveyRewardQuestions_2024 = 'survey_reward_questions_2024',
  TariffManagerContactForm_2025 = 'tariff_manager_contact_form_2025',
  TrackDefineNamespace = 'track_define_namespace',
  TrustAndSafetyProjectBanner = 'trust_and_safety_project_banner',
  UkCreatedProjectsAcceptUsdCurrency = 'uk_created_projects_accept_usd_currency',
  UpdatedRisksFlow = 'updated_risks_flow',
  UserMenuDraftProject = 'user_menu_draft_project',
  WebBraze = 'web_braze',
  WebErrorOnRetryOfFailed_3dsBacking = 'web_error_on_retry_of_failed_3ds_backing',
  WeightBasedShipping_2025 = 'weight_based_shipping_2025'
}

/** Autogenerated input type of FeatureReward */
export type FeatureRewardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  featured: Scalars['Boolean']['input'];
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of FeatureReward */
export type FeatureRewardPayload = {
  __typename?: 'FeatureRewardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** A set of projects that can be scheduled to be featured */
export type FeaturedProjectCollection = {
  __typename?: 'FeaturedProjectCollection';
  /** The project collection query used to generate the featured project's project list */
  collectionQueryOverride?: Maybe<Scalars['String']['output']>;
  /** The currently featured project */
  currentlyFeaturedProject: FeaturedProjectItem;
  /** The featured project items in this collection */
  featuredProjectItems: Array<Maybe<FeaturedProjectItem>>;
  id: Scalars['ID']['output'];
  /** A recommended collection of projects, optionally controlled by collectionQueryOverride */
  projectList: ProjectCollection;
  /** The localized title of the featured project section. (eg: 'Featured project') */
  title?: Maybe<Scalars['String']['output']>;
};


/** A set of projects that can be scheduled to be featured */
export type FeaturedProjectCollectionFeaturedProjectItemsArgs = {
  all?: InputMaybe<Scalars['Boolean']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** A curated project to be featured in an editorial layout. */
export type FeaturedProjectItem = {
  __typename?: 'FeaturedProjectItem';
  /** The project description or, if specified, the project description override */
  description: Scalars['String']['output'];
  /** When this featured project item should be featured */
  featuredAt?: Maybe<Scalars['Date']['output']>;
  id: Scalars['ID']['output'];
  /** If specified, will override the image of the associated project */
  imageOverride?: Maybe<Scalars['String']['output']>;
  /** The project that is featured */
  project: Project;
  /** The project id (pid) of the featured project */
  projectId: Scalars['Int']['output'];
  /** The see more url for this featured section */
  sectionUrl: Scalars['String']['output'];
  /** The project title or, if specified, the project title override */
  title: Scalars['String']['output'];
};

/** Types that can be reported by users */
export type FlaggableContent = Message | Project;

/** A report by a user. */
export type Flagging = Node & {
  __typename?: 'Flagging';
  /** The detailed reason for the flagging. */
  details: Scalars['String']['output'];
  /** The content that has been flagged by the user. */
  flaggedContent?: Maybe<FlaggableContent>;
  id: Scalars['ID']['output'];
  /** The general reason for the flagging. */
  kind?: Maybe<FlaggingKind>;
  /** The user who created the flagging. */
  user?: Maybe<User>;
};

/** The bucket for a flagging (general reason). */
export enum FlaggingKind {
  /** abuse */
  Abuse = 'ABUSE',
  /** backing-abuse */
  BackingAbuse = 'BACKING_ABUSE',
  /** backing-doxxing */
  BackingDoxxing = 'BACKING_DOXXING',
  /** backing-fraud */
  BackingFraud = 'BACKING_FRAUD',
  /** backing-spam */
  BackingSpam = 'BACKING_SPAM',
  /** charity */
  Charity = 'CHARITY',
  /** comment-abuse */
  CommentAbuse = 'COMMENT_ABUSE',
  /** comment-doxxing */
  CommentDoxxing = 'COMMENT_DOXXING',
  /** comment-offtopic */
  CommentOfftopic = 'COMMENT_OFFTOPIC',
  /** comment-spam */
  CommentSpam = 'COMMENT_SPAM',
  /** false-claims */
  FalseClaims = 'FALSE_CLAIMS',
  /** financial-contests-coupons */
  FinancialContestsCoupons = 'FINANCIAL_CONTESTS_COUPONS',
  /** financial-political-donations */
  FinancialPoliticalDonations = 'FINANCIAL_POLITICAL_DONATIONS',
  /** financial-services */
  FinancialServices = 'FINANCIAL_SERVICES',
  /** guidelines-abuse */
  GuidelinesAbuse = 'GUIDELINES_ABUSE',
  /** guidelines-spam */
  GuidelinesSpam = 'GUIDELINES_SPAM',
  /** guidelines-violation */
  GuidelinesViolation = 'GUIDELINES_VIOLATION',
  /** health-claims */
  HealthClaims = 'HEALTH_CLAIMS',
  /** health-energy-food-and-drink */
  HealthEnergyFoodAndDrink = 'HEALTH_ENERGY_FOOD_AND_DRINK',
  /** health-gmos */
  HealthGmos = 'HEALTH_GMOS',
  /** health-live-animals */
  HealthLiveAnimals = 'HEALTH_LIVE_ANIMALS',
  /** health-regulations */
  HealthRegulations = 'HEALTH_REGULATIONS',
  /** misrep-support */
  MisrepSupport = 'MISREP_SUPPORT',
  /** misrep-support-impersonation */
  MisrepSupportImpersonation = 'MISREP_SUPPORT_IMPERSONATION',
  /** misrep-support-other */
  MisrepSupportOther = 'MISREP_SUPPORT_OTHER',
  /** misrep-support-outstanding-fulfillment */
  MisrepSupportOutstandingFulfillment = 'MISREP_SUPPORT_OUTSTANDING_FULFILLMENT',
  /** misrep-support-suspicious-pledging */
  MisrepSupportSuspiciousPledging = 'MISREP_SUPPORT_SUSPICIOUS_PLEDGING',
  /** not-project */
  NotProject = 'NOT_PROJECT',
  /** not-project-barebones */
  NotProjectBarebones = 'NOT_PROJECT_BAREBONES',
  /** not-project-charity */
  NotProjectCharity = 'NOT_PROJECT_CHARITY',
  /** not-project-other */
  NotProjectOther = 'NOT_PROJECT_OTHER',
  /** not-project-personal-expenses */
  NotProjectPersonalExpenses = 'NOT_PROJECT_PERSONAL_EXPENSES',
  /** not-project-stunt-or-hoax */
  NotProjectStuntOrHoax = 'NOT_PROJECT_STUNT_OR_HOAX',
  /** offensive-content-hate */
  OffensiveContentHate = 'OFFENSIVE_CONTENT_HATE',
  /** offensive-content-porn */
  OffensiveContentPorn = 'OFFENSIVE_CONTENT_PORN',
  /** plagiarism */
  Plagiarism = 'PLAGIARISM',
  /** post-funding-creator-inappropriate */
  PostFundingCreatorInappropriate = 'POST_FUNDING_CREATOR_INAPPROPRIATE',
  /** post-funding-creator-selling-elsewhere */
  PostFundingCreatorSellingElsewhere = 'POST_FUNDING_CREATOR_SELLING_ELSEWHERE',
  /** post-funding-creator-uncommunicative */
  PostFundingCreatorUncommunicative = 'POST_FUNDING_CREATOR_UNCOMMUNICATIVE',
  /** post-funding-issues */
  PostFundingIssues = 'POST_FUNDING_ISSUES',
  /** post-funding-reward-delayed */
  PostFundingRewardDelayed = 'POST_FUNDING_REWARD_DELAYED',
  /** post-funding-reward-not-as-described */
  PostFundingRewardNotAsDescribed = 'POST_FUNDING_REWARD_NOT_AS_DESCRIBED',
  /** post-funding-shipped-never-received */
  PostFundingShippedNeverReceived = 'POST_FUNDING_SHIPPED_NEVER_RECEIVED',
  /** post-funding-suspicious-third-party */
  PostFundingSuspiciousThirdParty = 'POST_FUNDING_SUSPICIOUS_THIRD_PARTY',
  /** prohibited-items */
  ProhibitedItems = 'PROHIBITED_ITEMS',
  /** prototype-misrepresentation */
  PrototypeMisrepresentation = 'PROTOTYPE_MISREPRESENTATION',
  /** resale */
  Resale = 'RESALE',
  /** reselling */
  Reselling = 'RESELLING',
  /** spam */
  Spam = 'SPAM',
  /** undisclosed-ai-use */
  UndisclosedAiUse = 'UNDISCLOSED_AI_USE',
  /** vices-alcohol */
  VicesAlcohol = 'VICES_ALCOHOL',
  /** vices-drugs */
  VicesDrugs = 'VICES_DRUGS',
  /** vices-weapons */
  VicesWeapons = 'VICES_WEAPONS'
}

/** Autogenerated input type of FollowUser */
export type FollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of FollowUser */
export type FollowUserPayload = {
  __typename?: 'FollowUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** A project update. */
export type FreeformPost = Commentable & Node & Postable & {
  __typename?: 'FreeformPost';
  /** Actions you can currently perform */
  actions: PostActions;
  /** The author of the project update. */
  author: User;
  /** The author role of the project update. */
  authorRole: PostAuthorRole;
  /** The body of the post. */
  body?: Maybe<Scalars['HTML']['output']>;
  /** True if the current user can comment (considers restrictions) */
  canComment: Scalars['Boolean']['output'];
  /** True if the current user can comment (does not consider restrictions) */
  canCommentSansRestrictions: Scalars['Boolean']['output'];
  /** Whether a user can request an update about this project from the Creator */
  canUserRequestUpdate: Scalars['Boolean']['output'];
  /** List of comments on the commentable */
  comments?: Maybe<CommentConnection>;
  /** Comment count - defaults to root level comments only */
  commentsCount: Scalars['Int']['output'];
  /** The date the project update was created. */
  createdAt: Scalars['DateTime']['output'];
  /** All rewards belonging to a post that were specifically marked by a creator to be excluded from receiving a post notification. This does not, however, include the no reward tier. */
  excludedRewards?: Maybe<RewardConnection>;
  /** Users that have liked this project update. */
  fans?: Maybe<UserConnection>;
  /** True if creator has excluded the no reward tier from receiving a post notification. */
  hasExcludedNoRewardTier?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  /** All rewards that were marked to recieve a post notification, excluding the no reward tier. */
  includedRewards?: Maybe<RewardConnection>;
  /** Whether or not the current user has liked this project update. */
  isLiked: Scalars['Boolean']['output'];
  /** True if marked as a public public post, false if the post is backers only. */
  isPublic: Scalars['Boolean']['output'];
  /**
   * True if the post's content is visible to the user.
   * @deprecated Query the read field in post abilities instead.
   */
  isVisible: Scalars['Boolean']['output'];
  /** The number of likes a post has. */
  likesCount: Scalars['Int']['output'];
  /** The images associated with the post via native ui. */
  nativeImages?: Maybe<Array<Image>>;
  /** The next post. */
  nextPost?: Maybe<Postable>;
  /** The project update number. */
  number: Scalars['Int']['output'];
  /** The date the project update was pinned. */
  pinnedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The previous post. */
  previousPost?: Maybe<Postable>;
  /** Project that belongs to post. */
  project: Project;
  /** The root project id under which the comment is nested */
  projectRelayId: Scalars['ID']['output'];
  /** The date the project update was published. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** How much time a creator or collaborator has left to edit the post. */
  timeLeftToEdit?: Maybe<Scalars['String']['output']>;
  /** The project update's title. */
  title?: Maybe<Scalars['String']['output']>;
  /** The post type. */
  type: Post;
  /** The date the project update was last edited. */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The project update's URL. */
  url: Scalars['String']['output'];
};


/** A project update. */
export type FreeformPostCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A project update. */
export type FreeformPostCommentsCountArgs = {
  withReplies?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A project update. */
export type FreeformPostExcludedRewardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A project update. */
export type FreeformPostFansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A project update. */
export type FreeformPostIncludedRewardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** All available fulfillment statuses */
export enum FulfillmentStatus {
  /** All rewards made */
  AllRewardsMade = 'ALL_REWARDS_MADE',
  /** Fulfilling all rewards */
  FulfillingAllRewards = 'FULFILLING_ALL_REWARDS',
  /** Fulfilling some rewards */
  FulfillingSomeRewards = 'FULFILLING_SOME_REWARDS',
  /** Fulfillment complete */
  FulfillmentComplete = 'FULFILLMENT_COMPLETE',
  /** No rewards made; default value */
  NoRewardsMade = 'NO_REWARDS_MADE',
  /** Some rewards made */
  SomeRewardsMade = 'SOME_REWARDS_MADE'
}

/** All values for backing fulfillment status, including where not provided/available */
export enum FulfillmentStatusDisplayOptions {
  Delayed = 'delayed',
  InProgress = 'in_progress',
  NotAvailable = 'not_available',
  NotProvided = 'not_provided',
  NotStarted = 'not_started',
  Shipped = 'shipped'
}

/** Values for backing fulfillment status */
export enum FulfillmentStatusSelectOptions {
  Delayed = 'delayed',
  InProgress = 'in_progress',
  NotStarted = 'not_started',
  Shipped = 'shipped'
}

/** Information about a currency a creator can fund a project in */
export type FundingCurrency = {
  __typename?: 'FundingCurrency';
  /** Currency code */
  currency: CurrencyCode;
  /** Does the currency use decimals (not zero-decimal) */
  decimal: Scalars['Boolean']['output'];
  /** Maximum amount a creator can specify for a project goal */
  maxGoal: Scalars['Int']['output'];
  /** Maximum amount a backer can specify for a pledge */
  maxPledge: Scalars['Int']['output'];
  /** Minimum amount a backer can specify for a pledge */
  minPledge: Scalars['Int']['output'];
};

/** Autogenerated input type of GenerateProjectPreview */
export type GenerateProjectPreviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of GenerateProjectPreview */
export type GenerateProjectPreviewPayload = {
  __typename?: 'GenerateProjectPreviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** Buckets of project goals */
export enum GoalBuckets {
  /** Range from 0 to 1000 USD */
  Bucket_0 = 'BUCKET_0',
  /** Range from 1000 to 10000 USD */
  Bucket_1 = 'BUCKET_1',
  /** Range from 10000 to 100000 USD */
  Bucket_2 = 'BUCKET_2',
  /** Range from 100000 to 1000000 USD */
  Bucket_3 = 'BUCKET_3',
  /** Range from 1000000 to Infinity USD */
  Bucket_4 = 'BUCKET_4'
}

/** A header for an editorial layout. */
export type Header = {
  __typename?: 'Header';
  /** The localized blurb of this header */
  blurb?: Maybe<Scalars['String']['output']>;
  /** The categories linked to this header */
  categories: Array<Category>;
  id: Scalars['ID']['output'];
  /** The links of this header */
  links: Array<HeaderLink>;
  /** The localized title of this header */
  title?: Maybe<Scalars['String']['output']>;
};

/** A link of a header for an editorial layout. */
export type HeaderLink = {
  __typename?: 'HeaderLink';
  /** The localized text content of this link */
  content: Scalars['String']['output'];
  /** True if the link should open a new tab when clicked on */
  openInNewTab: Scalars['Boolean']['output'];
  /** The url this link points to */
  url: Scalars['String']['output'];
};

/** A deposit account's identity. */
export type Identity = {
  __typename?: 'Identity';
  /** ID of the identity */
  id?: Maybe<Scalars['Int']['output']>;
  /** The most recent identity document */
  identityDocument?: Maybe<IdentityDocument>;
  /** The account-holder name. */
  name?: Maybe<Scalars['String']['output']>;
  verification?: Maybe<AsynchronousVerification>;
};

/** The relevant identity document supplied for identity verification. */
export type IdentityDocument = {
  __typename?: 'IdentityDocument';
  /** The associated identity's verification state */
  identityState?: Maybe<IdentityVerificationState>;
  verificationState: IdentityDocumentVerificationStates;
};

/** Identity document verification states. */
export enum IdentityDocumentVerificationStates {
  Abandoned = 'ABANDONED',
  Failed = 'FAILED',
  Pending = 'PENDING',
  Started = 'STARTED',
  Successful = 'SUCCESSFUL'
}

/** Identity verification states. */
export enum IdentityVerificationState {
  Error = 'ERROR',
  Failed = 'FAILED',
  Passed = 'PASSED',
  Started = 'STARTED',
  Verifying = 'VERIFYING'
}

/** A post image */
export type Image = {
  __typename?: 'Image';
  id: Scalars['ID']['output'];
  /** URL of the image */
  url?: Maybe<Scalars['String']['output']>;
};


/** A post image */
export type ImageUrlArgs = {
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** A creator interview answer. */
export type InterviewAnswer = Node & {
  __typename?: 'InterviewAnswer';
  /** The interview answer text. */
  body?: Maybe<Scalars['HTML']['output']>;
  id: Scalars['ID']['output'];
  /** True if the creator skipped the associated question. */
  isSkipped: Scalars['Boolean']['output'];
  /** The question */
  question: InterviewQuestion;
};

/** The connection type for InterviewAnswer. */
export type InterviewAnswerConnection = {
  __typename?: 'InterviewAnswerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<InterviewAnswerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<InterviewAnswer>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type InterviewAnswerEdge = {
  __typename?: 'InterviewAnswerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<InterviewAnswer>;
};

/** Interview answer input for updating creator interviews */
export type InterviewAnswerInput = {
  /** The body of the interview answer */
  body: Scalars['String']['input'];
  /** The associated interview question id */
  interviewQuestionId: Scalars['ID']['input'];
  /** True if the creator chose to skip the question */
  skip?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A creator interview question. */
export type InterviewQuestion = Node & {
  __typename?: 'InterviewQuestion';
  /** All the answers to the question. */
  answers: InterviewAnswerConnection;
  /** The interview question text. */
  body: Scalars['String']['output'];
  /** The interview question category. */
  category: InterviewQuestionCategory;
  id: Scalars['ID']['output'];
};


/** A creator interview question. */
export type InterviewQuestionAnswersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The interview question category. */
export enum InterviewQuestionCategory {
  Blockers = 'blockers',
  Inspiration = 'inspiration',
  Learnings = 'learnings',
  Process = 'process',
  Retrospective = 'retrospective'
}

/** The connection type for InterviewQuestion. */
export type InterviewQuestionConnection = {
  __typename?: 'InterviewQuestionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<InterviewQuestionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<InterviewQuestion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type InterviewQuestionEdge = {
  __typename?: 'InterviewQuestionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<InterviewQuestion>;
};

/** Autogenerated input type of InviteProjectCollaborator */
export type InviteProjectCollaboratorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Permissions granted to the collaborator */
  permissions: Array<CollaboratorPermission>;
  /** ID of project getting the collaborator */
  projectId: Scalars['ID']['input'];
  /** Title of the collaborator */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Email of the collaborator */
  userEmail: Scalars['String']['input'];
};

/** Autogenerated return type of InviteProjectCollaborator */
export type InviteProjectCollaboratorPayload = {
  __typename?: 'InviteProjectCollaboratorPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** Autogenerated input type of IssueRefund */
export type IssueRefundInput = {
  /** ID of associated backing */
  backingId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Stripe Payment Source ID */
  creatorPaymentSourceId?: InputMaybe<Scalars['ID']['input']>;
  /** Stripe SetupIntent client secret */
  intentClientSecret?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  /** Reason for adjustment */
  reason: RefundReasonType;
  /** (legacy) Whether or not the refund the order */
  refundOrder?: InputMaybe<Scalars['Boolean']['input']>;
  /** Parameters to refund a order. */
  refundOrderInput?: InputMaybe<RefundOrderInput>;
  /** Parameters to refund a pledge. Leave blank to not refund the pledge. */
  refundPledgeInput?: InputMaybe<RefundPledgeInput>;
};

/** Autogenerated return type of IssueRefund */
export type IssueRefundPayload = {
  __typename?: 'IssueRefundPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  refund: Refund;
};

/** Tax configuration data related to an item */
export type ItemTaxConfig = {
  __typename?: 'ItemTaxConfig';
  id: Scalars['ID']['output'];
  item: RewardItem;
  /** Value of item pre any bundling discounts */
  marketValue?: Maybe<Scalars['Int']['output']>;
  taxCategory?: Maybe<TaxCategory>;
};

/** A unique item variant aka SKU */
export type ItemVariant = {
  __typename?: 'ItemVariant';
  id: Scalars['ID']['output'];
  /** The name (e.g. 'Hoodie Small Blue Checkered') */
  name: Scalars['String']['output'];
  /** The option values associated with this variant */
  optionValues?: Maybe<Array<OptionValue>>;
  /** The sku value (e.g. 'Hoodie-Small-Blue-Checkered') */
  sku: Scalars['String']['output'];
};

/** Input for updating an Item Variant */
export type ItemVariantInput = {
  id: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};

/** Item's weight configuration data */
export type ItemWeight = {
  __typename?: 'ItemWeight';
  exclude: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  item: RewardItem;
  /** item weight */
  weight: Scalars['Float']['output'];
};

/** Stats related to configuring weights for items */
export type ItemWeightCompletionStats = {
  __typename?: 'ItemWeightCompletionStats';
  allItemsConfigured: Scalars['Boolean']['output'];
  excludedCount: Scalars['Int']['output'];
  itemsMissingWeightsCount: Scalars['Int']['output'];
  itemsWithWeightCount: Scalars['Int']['output'];
};

/** Input to create or update weight ranges */
export type ItemWeightInput = {
  exclude: Scalars['Boolean']['input'];
  itemId: Scalars['ID']['input'];
  weight?: InputMaybe<Scalars['Float']['input']>;
};

/** A Kickstarter fact */
export type KsrFact = {
  __typename?: 'KsrFact';
  /** Fact contributor */
  contributor?: Maybe<Scalars['String']['output']>;
  /** Fact date */
  date?: Maybe<Scalars['String']['output']>;
  /** Kickstarter fact */
  fact?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of LaunchProject */
export type LaunchProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of LaunchProject */
export type LaunchProjectPayload = {
  __typename?: 'LaunchProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** An Editorial Layout */
export type Layout = {
  __typename?: 'Layout';
  /** When this editorial layout was created */
  createdAt: Scalars['DateTime']['output'];
  /** The description of the editorial layout */
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** All the modules for an editorial layout */
  modules: EditorialConnection;
  /** Is the editorial layout published? */
  published: Scalars['Boolean']['output'];
  /** The revision of the editorial layout */
  revision: Scalars['String']['output'];
  /** The sequence number of the currently published revision of the editorial */
  sequence?: Maybe<Scalars['Int']['output']>;
  /** The slug for the url of the editorial layout oage */
  slug: Scalars['String']['output'];
  /** The title of the editorial layout */
  title?: Maybe<Scalars['String']['output']>;
};


/** An Editorial Layout */
export type LayoutModulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of LikePost */
export type LikePostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of LikePost */
export type LikePostPayload = {
  __typename?: 'LikePostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  post?: Maybe<Postable>;
};

/** Autogenerated input type of LikeProject */
export type LikeProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the project that the user has liked */
  id: Scalars['ID']['input'];
  /** The context or page that the user liked this project from. Used for tracking */
  trackingContext?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of LikeProject */
export type LikeProjectPayload = {
  __typename?: 'LikeProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
  user?: Maybe<User>;
};

/** Autogenerated input type of LikeQuizProject */
export type LikeQuizProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not the user has indicated that they like something else about the project other than the attributes presented */
  likedSomethingElse?: InputMaybe<Scalars['Boolean']['input']>;
  /** The id of the quiz project that the user has liked */
  quizProjectId: Scalars['ID']['input'];
  /** A list of selected likeable attribute ids associated to the quiz project */
  selectedLikeableAttributeIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of LikeQuizProject */
export type LikeQuizProjectPayload = {
  __typename?: 'LikeQuizProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** An attribute about a quiz project that a user can select in the taste profile quiz. */
export type LikeableAttribute = {
  __typename?: 'LikeableAttribute';
  id: Scalars['ID']['output'];
  /** The text of the attribute. */
  text: Scalars['String']['output'];
};

/** A line item in a cart */
export type LineItem = {
  __typename?: 'LineItem';
  /** The answers associated with the line item */
  answers?: Maybe<Array<Answer>>;
  id: Scalars['ID']['output'];
  /** The item associated with the line item */
  item: RewardItem;
  /** The item variant the backer selected (unless master variant) */
  itemVariant?: Maybe<ItemVariant>;
  /** The option values that comprise the selected item variant, if present. */
  optionValues: Array<OptionValue>;
  /** The questions associated with the line item */
  questions: Array<CartQuestion>;
  /** True if the backer needs to select a variant or answer an item question */
  requiresSelection: Scalars['Boolean']['output'];
};

/** Line item belonging to a cart */
export type LineItemInput = {
  answers?: InputMaybe<Array<InputMaybe<AnswerInput>>>;
  id: Scalars['ID']['input'];
  optionValueIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** A location. */
export type Location = Node & {
  __typename?: 'Location';
  /** The country code. */
  country: Scalars['String']['output'];
  /** The localized country name. */
  countryName?: Maybe<Scalars['String']['output']>;
  /** The county name or code. Can be null. */
  county?: Maybe<Scalars['String']['output']>;
  /** A URL to a discover page filtered by location */
  discoverUrl: Scalars['String']['output'];
  /** The displayable name. It includes the state code for US cities. ex: 'Seattle, WA' */
  displayableName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Whether or not this location is the root location */
  isRoot: Scalars['Boolean']['output'];
  /** The latitude of the location. */
  latitude?: Maybe<Scalars['Float']['output']>;
  /** The longitude of the location. */
  longitude?: Maybe<Scalars['Float']['output']>;
  /** The localized name */
  name: Scalars['String']['output'];
  /** The state name or code. Can be null. */
  state?: Maybe<Scalars['String']['output']>;
};


/** A location. */
export type LocationDiscoverUrlArgs = {
  ref_tag?: InputMaybe<Scalars['String']['input']>;
};

/** An edge in a connection. */
export type LocationEdge = {
  __typename?: 'LocationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Location>;
};

export type LocationVatNumber = {
  __typename?: 'LocationVatNumber';
  /** The creator's last used vat number for this location */
  lastUsed?: Maybe<Scalars['String']['output']>;
  /** The id of the location associated with a given VAT number. */
  locationId: Scalars['ID']['output'];
  /** The name of the location. */
  locationName: VatConfigLocationEnum;
  /** Whether the creator has opted out of VAT collection for this location. */
  optOut: Scalars['Boolean']['output'];
  /** The unique tax identifier for a given location. */
  vatNumber?: Maybe<Scalars['String']['output']>;
};

/** Input to create or update a VAT number for a location. */
export type LocationVatNumberInput = {
  locationId: Scalars['ID']['input'];
  optOut: Scalars['Boolean']['input'];
  vatNumber?: InputMaybe<Scalars['String']['input']>;
};

/** The connection type for Location. */
export type LocationsConnection = {
  __typename?: 'LocationsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LocationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Location>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** Autogenerated input type of LockAddresses */
export type LockAddressesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of LockAddresses */
export type LockAddressesPayload = {
  __typename?: 'LockAddressesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Returns the updated project if successful. */
  project: Project;
};

/** Credit card types. */
export enum LowercaseCreditCardTypes {
  Amex = 'amex',
  Diners = 'diners',
  Discover = 'discover',
  Jcb = 'jcb',
  Mastercard = 'mastercard',
  Unionpay = 'unionpay',
  Visa = 'visa'
}

/** A mailbox */
export enum MailboxType {
  All = 'ALL',
  Archive = 'ARCHIVE',
  Inbox = 'INBOX',
  Sent = 'SENT',
  Spam = 'SPAM',
  Unread = 'UNREAD'
}

/** A masthead image with text for an editorial layout. */
export type MastheadImage = {
  __typename?: 'MastheadImage';
  /** The header text overlaying the masthead image. */
  header?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The url for the backgrorund image of the masthead. */
  imageUrl?: Maybe<Scalars['String']['output']>;
  /** The smaller subheader text overlaying the masthead image. */
  subheader?: Maybe<Scalars['String']['output']>;
};

/** The connection type for Project. */
export type MembershipProjectsConnection = {
  __typename?: 'MembershipProjectsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** A message on Kickstarter. */
export type Message = Node & {
  __typename?: 'Message';
  /** Body of the message */
  body: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** The message is an submission appeal */
  isAppeal: Scalars['Boolean']['output'];
  /** When the message was first read */
  readAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user who received this message */
  recipient?: Maybe<User>;
  /** The user who sent this message */
  sender?: Maybe<User>;
  /** When the message was sent */
  sentAt?: Maybe<Scalars['DateTime']['output']>;
  /** The message is spam */
  spam: Scalars['Boolean']['output'];
};

/** An edge in a connection. */
export type MessageEdge = {
  __typename?: 'MessageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Message>;
};

/** Autogenerated input type of MigrateToFulfillmentStatus */
export type MigrateToFulfillmentStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of MigrateToFulfillmentStatus */
export type MigrateToFulfillmentStatusPayload = {
  __typename?: 'MigrateToFulfillmentStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Succeeds if backings are being updated in backend. */
  success: Scalars['Boolean']['output'];
};

export type MilestoneCategory = {
  __typename?: 'MilestoneCategory';
  /** Name of category */
  name: Scalars['String']['output'];
  /** Order to display category in for Project */
  order: Scalars['Int']['output'];
};

/** A monetary amount and its corresponding currency. */
export type Money = {
  __typename?: 'Money';
  /** Floating-point numeric value of monetary amount represented as a string */
  amount?: Maybe<Scalars['String']['output']>;
  /** Currency of the monetary amount */
  currency?: Maybe<CurrencyCode>;
  /** Symbol of the currency in which the monetary amount appears */
  symbol?: Maybe<Scalars['String']['output']>;
};

/** The mutation root of the Kickstarter GraphQL interface */
export type Mutation = {
  __typename?: 'Mutation';
  /** Updates an address if the user rejects or accepts a suggestion */
  acceptOrRejectAddressSuggestion?: Maybe<AcceptOrRejectAddressSuggestionPayload>;
  /** Indicates that a backer has acknowledged the available upgrades step in checkout. */
  acknowledgeUpgrades?: Maybe<AcknowledgeUpgradesPayload>;
  /** Activates the prelaunch page for a project */
  activatePrelaunch?: Maybe<ActivateProjectPrelaunchPayload>;
  /** Updates the toggle-able options of the spreadsheet graph */
  answerProjectFeedbackQuestion?: Maybe<AnswerProjectFeedbackQuestionPayload>;
  /** Given a checkout that already exists, this mutation just applies a specific payment source to its backing. That's it! If you need to create a checkout and backing from scratch, use CreateBackingType. */
  applyPaymentSourceToCheckout?: Maybe<ApplyPaymentSourceToCheckoutPayload>;
  /** Batch updates addresses for users's active survey responses */
  batchUpdateSurveyResponseAddresses?: Maybe<BatchUpdateSurveyResponseAddressesPayload>;
  /** Block a user */
  blockUser?: Maybe<BlockUserPayload>;
  /** Bulk edits the entire set of backer questions for a backer survey */
  bulkEditQuestions?: Maybe<BulkEditQuestionsPayload>;
  /** Takes a stock location and bulk edits the location mapping */
  bulkEditStockLocationMappings?: Maybe<BulkEditStockLocationMappingsPayload>;
  /** Cancel a pledged backing */
  cancelBacking?: Maybe<CancelBackingPayload>;
  /** Cancel a live Kickstarter project. */
  cancelProject?: Maybe<CancelProjectPayload>;
  clearUserUnseenActivity?: Maybe<ClearUserUnseenActivityPayload>;
  /** Ends a given checkout wave. */
  closeWave?: Maybe<CloseWavePayload>;
  /** Complete a checkout originating from an session payment */
  completeOnSessionCheckout?: Maybe<CompleteOnSessionCheckoutPayload>;
  /** Confirm payment and complete the order */
  completeOrder?: Maybe<CompleteOrderPayload>;
  /** Complete a $0 order */
  completeZeroDollarOrder?: Maybe<CompleteZeroDollarOrderPayload>;
  /** Confirm order address */
  confirmOrderAddress?: Maybe<ConfirmOrderAddressPayload>;
  /** Copy Reward Items from one Project to another. */
  copyRewardItems?: Maybe<CopyRewardItemsPayload>;
  /** Save a new address. */
  createAddress?: Maybe<CreateAddressPayload>;
  /** [DEPRECATED in favor of CreateBackingType] Create a checkout with Apple Pay. */
  createApplePayBacking?: Maybe<CreateApplePayBackingPayload>;
  /** Create an asset. */
  createAsset?: Maybe<CreateAssetPayload>;
  /** Creates an attribution event. Specifying a project will pass the project properties for attribution events. Sending this request as a logged-in user passes that user's properties as well. Any passed-in property with the same name overwrites the generated properties. */
  createAttributionEvent?: Maybe<CreateAttributionEventPayload>;
  /** Save or update a search segment */
  createBackerReportSegment?: Maybe<CreateBackerReportSegmentPayload>;
  /** Creates a backer survey and generates master variants for each project item if needed */
  createBackerSurvey?: Maybe<CreateBackerSurveyPayload>;
  /** Create a backing and checkout and process payment. */
  createBacking?: Maybe<CreateBackingPayload>;
  /** Create a backing and checkout without syncing to Rosie */
  createCheckout?: Maybe<CreateCheckoutPayload>;
  /** Post a comment */
  createComment?: Maybe<PostCommentPayload>;
  /** Create a country signup. */
  createCountrySignup?: Maybe<CreateCountrySignupPayload>;
  /** Create a new creator interview */
  createCreatorInterview?: Maybe<CreateCreatorInterviewPayload>;
  /** Create an Editorial Layout. */
  createEditorialLayout?: Maybe<CreateEditorialLayoutTypePayload>;
  /** Create a flagging (report) of a piece flaggable content. */
  createFlagging?: Maybe<CreateFlaggingPayload>;
  /** Create a new project post/update */
  createFreeformPost?: Maybe<CreateFreeformPostPayload>;
  /** Creates an option type and values for an item */
  createOption?: Maybe<CreateOptionPayload>;
  createOrUpdateBackingAddress?: Maybe<CreateOrUpdateBackingAddressPayload>;
  /** Creates/updates item tax config and creates/updates tax category for an item */
  createOrUpdateItemTaxConfig?: Maybe<CreateOrUpdateItemTaxConfigPayload>;
  /** Creates (or updates) a shipping zone with weight ranges and locations */
  createOrUpdateShippingZone?: Maybe<CreateOrUpdateShippingZonePayload>;
  /** Create or update a shipment's tracking number */
  createOrUpdateTrackingNumber?: Maybe<CreateOrUpdateTrackingNumberPayload>;
  /** Creates/updates a VAT config */
  createOrUpdateVatConfig?: Maybe<CreateOrUpdateVatConfigPayload>;
  /** Create a Stripe PaymentIntent in order to collect an on-session payment via the Stripe PaymentElement */
  createPaymentIntent?: Maybe<CreatePaymentIntentPayload>;
  /** Create a payment source */
  createPaymentSource?: Maybe<CreatePaymentSourcePayload>;
  /** create a reward to be made available in Pledge Management. */
  createPledgeManagementReward?: Maybe<CreatePledgeManagementRewardPayload>;
  /** Start a Kickstarter project. */
  createProject?: Maybe<CreateProjectPayload>;
  /** Post a project comment */
  createProjectComment?: Maybe<PostProjectCommentPayload>;
  /** Creates a Deposit Account on Rosie, and a Stripe Connect Account. */
  createProjectDepositAccount?: Maybe<CreateProjectDepositAccountPayload>;
  /** Create a project image. */
  createProjectImage?: Maybe<CreateProjectImagePayload>;
  createProjectPaymentSource?: Maybe<CreateProjectPaymentSourcePayload>;
  createProjectUpdateRequest?: Maybe<CreateProjectUpdateRequestPayload>;
  /** Create a project video. */
  createProjectVideo?: Maybe<CreateProjectVideoPayload>;
  /** Creates a question for an object */
  createQuestion?: Maybe<CreateQuestionPayload>;
  /** create a reward on a Kickstarter project. */
  createReward?: Maybe<CreateRewardPayload>;
  /** Create an item which is available through the project's backer rewards. */
  createRewardItem?: Maybe<CreateRewardItemPayload>;
  /** Create a Stripe SetupIntent in order to render new Stripe Elements */
  createSetupIntent?: Maybe<CreateSetupIntentPayload>;
  /** Creates a copy of the master Sheet and shares it with the project owner */
  createSheetForProject?: Maybe<CreateSheetForProjectPayload>;
  /** Creates a track event */
  createTrackEvent?: Maybe<CreateTrackEventPayload>;
  /** Creates a new registered user */
  createUser?: Maybe<CreateUserPayload>;
  /** Add a user's slug. */
  createUserSlug?: Maybe<CreateUserSlugPayload>;
  /** Add a user's website. */
  createUserUrl?: Maybe<CreateUserUrlsPayload>;
  /** Create a video track (caption) for a Project Video */
  createVideoTrack?: Maybe<CreateVideoTrackPayload>;
  /** Creates a checkout wave for a given project, assuming all pre-requisites are complete. */
  createWave?: Maybe<CreateWavePayload>;
  /** Deactivates the prelaunch page for a project */
  deactivatePrelaunch?: Maybe<DeactivateProjectPrelaunchPayload>;
  /** Deactivate a collaborator on a project. */
  deactivateProjectCollaborator?: Maybe<DeactivateProjectCollaboratorPayload>;
  /** Deletes an address */
  deleteAddress?: Maybe<DeleteAddressPayload>;
  /** Delete a asset. */
  deleteAsset?: Maybe<DeleteAssetPayload>;
  /** Delete a search segment */
  deleteBackerReportSegment?: Maybe<DeleteBackerReportSegmentPayload>;
  /** Deletes a backer survey */
  deleteBackerSurvey?: Maybe<DeleteBackerSurveyPayload>;
  /** Delete a comment */
  deleteComment?: Maybe<DeleteCommentPayload>;
  /** Deletes an option type and values for an item */
  deleteOption?: Maybe<DeleteOptionPayload>;
  /** Delete a project post */
  deletePost?: Maybe<DeletePostPayload>;
  /** Delete an unlaunched Kickstarter project. */
  deleteProject?: Maybe<DeleteProjectPayload>;
  /** Delete a comment */
  deleteProjectComment?: Maybe<DeleteProjectCommentPayload>;
  /** Delete a project image. */
  deleteProjectImage?: Maybe<DeleteProjectImagePayload>;
  /** Delete a project video. */
  deleteProjectVideo?: Maybe<DeleteProjectVideoPayload>;
  /** Deletes a question */
  deleteQuestion?: Maybe<DeleteQuestionPayload>;
  /** Delete a reward from a project */
  deleteReward?: Maybe<DeleteRewardPayload>;
  /** Delete a reward item from a project */
  deleteRewardItem?: Maybe<DeleteRewardItemPayload>;
  /** Delete a shipping zone. */
  deleteShippingZone?: Maybe<DeleteShippingZonePayload>;
  /** Deletes a stock location and associated address */
  deleteStockLocation?: Maybe<DeleteStockLocationPayload>;
  /** Delete a user's url */
  deleteUserUrl?: Maybe<DeleteUserUrlsPayload>;
  /** Delete a video track (caption) from a video */
  deleteVideoTrack?: Maybe<DeleteVideoTrackPayload>;
  /** Adds disliked projects to a users taste profile */
  dislikeProject?: Maybe<DislikeProjectPayload>;
  /** Distribute digital access resources like access keys or URLs to backers with digital rewards */
  distributeDigitalAccessResources?: Maybe<DistributeDigitalAccessResourcesPayload>;
  /** End late pledges for a Kickstarter project. */
  endLatePledges?: Maybe<EndLatePledgesPayload>;
  /** Feature a reward for a Kickstarter project. */
  featureReward?: Maybe<FeatureRewardPayload>;
  /** Causes the current user to follow a specified user */
  followUser?: Maybe<FollowUserPayload>;
  /** Enable the preview url for a Kickstarter project. */
  generateProjectPreview?: Maybe<GenerateProjectPreviewPayload>;
  /** Invite a new collaborator on a project */
  inviteProjectCollaborator?: Maybe<InviteProjectCollaboratorPayload>;
  /** Issue a refund for a backer. Can include the refunding of both the pledge and the PM transactions. */
  issueRefund?: Maybe<IssueRefundPayload>;
  /** Launch a Kickstarter project. */
  launchProject?: Maybe<LaunchProjectPayload>;
  /** Like a specified project update */
  likePost?: Maybe<LikePostPayload>;
  /** Adds a like for the passed in project to the user's taste profile */
  likeProject?: Maybe<LikeProjectPayload>;
  /** Adds a quiz project and any attributes the user has liked to their taste profile */
  likeQuizProject?: Maybe<LikeQuizProjectPayload>;
  /** Locks backer address changes for a project */
  lockAddresses?: Maybe<LockAddressesPayload>;
  /** Migrate's a project's eligible backings to new fulfillment status tool. */
  migrateToFulfillmentStatus?: Maybe<MigrateToFulfillmentStatusPayload>;
  /** Opt out of a pledge manager */
  optOutOfPledgeManager?: Maybe<OptOutOfPledgeManagerPayload>;
  /** Delete a user's payment source */
  paymentSourceDelete?: Maybe<PaymentSourceDeletePayload>;
  /** Pin a project update */
  pinPost?: Maybe<PinPostPayload>;
  /** Exclude a reward's backers from getting notifications about a post. */
  postExcludeReward?: Maybe<PostExcludeRewardPayload>;
  /** Include a reward's backers in notifications about a post. */
  postIncludeReward?: Maybe<PostIncludeRewardPayload>;
  /** Processes tracking numbers for a given project */
  processTrackingNumbers?: Maybe<ProcessTrackingNumbersPayload>;
  /** Publish an Editorial Layout. */
  publishEditorialLayout?: Maybe<PublishEditorialLayoutTypePayload>;
  /** Publish a project post */
  publishPost?: Maybe<PublishPostPayload>;
  /** Refreshes the spreadsheet data from the sheet */
  refreshSpreadsheetData?: Maybe<RefreshSpreadsheetDataPayload>;
  /** Removes the spreadsheet associated to a project */
  removeSheetFromProject?: Maybe<RemoveSheetFromProjectPayload>;
  reportSpam?: Maybe<ReportSpamPayload>;
  /** Requests a password reset email. */
  requestPasswordReset?: Maybe<RequestPasswordResetPayload>;
  /** Reset a backer survey */
  resetBackerSurvey?: Maybe<ResetBackerSurveyPayload>;
  /** Sets pledge manager state to approved or denied based on outcome of review */
  reviewPledgeManager?: Maybe<ReviewPledgeManagerPayload>;
  /** Send a message */
  sendMessage?: Maybe<SendMessagePayload>;
  /** Send a message for a project submission */
  sendSubmissionMessage?: Maybe<SendSubmissionMessagePayload>;
  /** Sends a backer survey and creates backer carts */
  sendSurvey?: Maybe<SendSurveyPayload>;
  /** Sets an address as the primary/default address for the user */
  setAddressAsPrimary?: Maybe<SetAddressAsPrimaryPayload>;
  /** Sets address_collection_enabled */
  setAddressCollectionEnabled?: Maybe<SetAddressCollectionEnabledPayload>;
  /** Sets the fulfillment status of multiple backings based on various filters. */
  setBackingFulfillmentStatuses?: Maybe<SetBackingFulfillmentStatusesPayload>;
  setBackingNote?: Maybe<SetBackingNotePayload>;
  /** Set a project slug. */
  setProjectSlug?: Maybe<SetProjectSlugPayload>;
  /** Updates the project status */
  setProjectStatus?: Maybe<SetProjectStatusPayload>;
  /** Sets a project's shipping configuration, e.g. weight based or flat rate */
  setShippingConfig?: Maybe<SetShippingConfigPayload>;
  /** Sets tax category for an item */
  setTaxCategory?: Maybe<SetTaxCategoryPayload>;
  /** Signs in or sign up a user via the Sign in With Apple service */
  signInWithApple?: Maybe<SignInWithApplePayload>;
  /** Submits a draft pledge manager */
  submitPledgeManager?: Maybe<SubmitPledgeManagerPayload>;
  submitProject?: Maybe<SubmitProjectPayload>;
  /** Refund a backing. */
  submitRefundCheckout?: Maybe<SubmitRefundCheckoutPayload>;
  /** Associates backing with an address, updates cart with item preference selections, and creates answers to survey questions. */
  submitResponses?: Maybe<SubmitResponsesPayload>;
  /** Submits the VAT number to rosie */
  submitVatNumber?: Maybe<SubmitVatNumberPayload>;
  /** Confirm payment and complete the order */
  succeedOrder?: Maybe<SucceedOrderPayload>;
  /** Toggle whether a comment is pinned. */
  toggleCommentPin?: Maybe<ToggleCommentPinPayload>;
  /** Toggles a milestone for a given project and category to completed or not completed */
  toggleProjectMilestone?: Maybe<ToggleProjectMilestonePayload>;
  /** Enable & disable the preview url for a Kickstarter project. */
  toggleProjectPreview?: Maybe<ToggleProjectPreviewPayload>;
  /** Toggle whether a project can set up and collect tariff surcharges */
  toggleTariffSurchargesEnabled?: Maybe<ToggleTariffSurchargesEnabledPayload>;
  /** Translate an Editorial Layout. */
  translateEditorialLayout?: Maybe<TranslateEditorialLayoutTypePayload>;
  /** Triggers third party event */
  triggerThirdPartyEvent?: Maybe<TriggerThirdPartyEventPayload>;
  /** Unblock a user */
  unblockUser?: Maybe<UnblockUserPayload>;
  /** Removes a like for the passed in project from the user's taste profile */
  undislikeProject?: Maybe<UndislikeProjectPayload>;
  /** Causes the current user to unfollow a specified user */
  unfollowUser?: Maybe<UnfollowUserPayload>;
  /** Unlike a specified project update */
  unlikePost?: Maybe<UnlikePostPayload>;
  /** Removes a like for the passed in project from the user's taste profile */
  unlikeProject?: Maybe<UnlikeProjectPayload>;
  /** Unpin a project update */
  unpinPost?: Maybe<UnpinPostPayload>;
  /** Unpublish an Editorial Layout. */
  unpublishEditorialLayout?: Maybe<UnpublishEditorialLayoutTypePayload>;
  untagProject?: Maybe<UntagProjectPayload>;
  unwatchProject?: Maybe<UnwatchProjectPayload>;
  /** Updates the pledge manager to enable or disable accepts_new_backers */
  updateAcceptsNewBackers?: Maybe<UpdateAcceptsNewBackersPayload>;
  /** Update the backing completed at field with a backing_completed toggle */
  updateBackerCompleted?: Maybe<UpdateBackerCompletedPayload>;
  /** Updates backer survey with a rich text intro */
  updateBackerSurveyIntro?: Maybe<UpdateBackerSurveyIntroPayload>;
  /** Update an existing backing for a Kickstarter project. */
  updateBacking?: Maybe<UpdateBackingPayload>;
  /** Update a backing's payment source */
  updateBackingPaymentSource?: Maybe<UpdateBackingPaymentSourcePayload>;
  /** Handle a user's updated consent for data collection purposes. */
  updateConsent?: Maybe<UpdateConsentPayload>;
  /** Update a creator interview */
  updateCreatorInterview?: Maybe<UpdateCreatorInterviewPayload>;
  /** Creates, updates, or destroys associations between an Order and a backer's selected Cross Sells */
  updateCrossSellsOnOrder?: Maybe<UpdateCrossSellsOnOrderPayload>;
  /** Update a project's fulfillment_modal_dismissed_at timestamp. */
  updateFulfillmentModalDismissedAt?: Maybe<UpdateFulfillmentModalDismissedAtPayload>;
  /** Update a project's fulfillment_status. */
  updateFulfillmentStatus?: Maybe<UpdateFulfillmentStatusPayload>;
  /** Updates an array of ItemVariant */
  updateItemVariants?: Maybe<UpdateItemVariantsPayload>;
  /** Updates item weights given a set of item ids and weights */
  updateItemWeights?: Maybe<UpdateItemWeightsPayload>;
  /** Updates an option type and values for an item */
  updateOption?: Maybe<UpdateOptionPayload>;
  /** Update OrderableConfig for an Orderable */
  updateOrderableConfig?: Maybe<UpdateOrderableConfigPayload>;
  /** update a reward to be made available in Pledge Management. */
  updatePledgeManagementReward?: Maybe<UpdatePledgeManagementRewardPayload>;
  /** Update a project post */
  updatePost?: Maybe<UpdatePostPayload>;
  /** Update an existing Kickstarter project. */
  updateProject?: Maybe<UpdateProjectPayload>;
  /** Update a collaborator on a project. */
  updateProjectCollaborator?: Maybe<UpdateProjectCollaboratorPayload>;
  updateProjectPaymentSource?: Maybe<UpdateProjectPaymentSourcePayload>;
  updateProjectRiskStrategies?: Maybe<UpdateProjectRiskStrategiesPayload>;
  updateProjectVerifiedCreatorName?: Maybe<UpdateProjectVerifiedCreatorNamePayload>;
  /** Updates a question */
  updateQuestion?: Maybe<UpdateQuestionPayload>;
  /** Updates audience for a specified resource */
  updateResourceAudience?: Maybe<UpdateResourceAudiencePayload>;
  /** Update a reward on a Kickstarter project. */
  updateReward?: Maybe<UpdateRewardPayload>;
  /** Update an item which is available through the project's backer rewards. */
  updateRewardItem?: Maybe<UpdateRewardItemPayload>;
  /** Update ShippingRates for a BackerReward */
  updateRewardShippingRates?: Maybe<UpdateRewardShippingRatesPayload>;
  /** Updates the toggle-able options of the spreadsheet graph */
  updateSpreadsheetToggles?: Maybe<UpdateSpreadsheetTogglesPayload>;
  /** Update user account */
  updateUserAccount?: Maybe<UpdateUserAccountPayload>;
  /** Update user notification for a topic */
  updateUserNotification?: Maybe<UpdateUserNotificationPayload>;
  /** Update user notification frequency for a topic */
  updateUserNotificationFrequency?: Maybe<UpdateUserNotificationFrequencyPayload>;
  /** Update user's profile */
  updateUserProfile?: Maybe<UpdateUserProfilePayload>;
  /** Creates a valid user setting */
  updateUserSetting?: Maybe<UpdateUserSettingPayload>;
  /** Updates the backer's order with the new reward they're upgrading to, or resets the order */
  upgradeRewardOnOrder?: Maybe<UpgradeRewardOnOrderPayload>;
  /** send email verification */
  userSendEmailVerification?: Maybe<UserSendEmailVerificationPayload>;
  watchProject?: Maybe<WatchProjectPayload>;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationAcceptOrRejectAddressSuggestionArgs = {
  input: AcceptOrRejectAddressSuggestionInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationAcknowledgeUpgradesArgs = {
  input: AcknowledgeUpgradesInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationActivatePrelaunchArgs = {
  input: ActivateProjectPrelaunchInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationAnswerProjectFeedbackQuestionArgs = {
  input: AnswerProjectFeedbackQuestionInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationApplyPaymentSourceToCheckoutArgs = {
  input: ApplyPaymentSourceToCheckoutInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationBatchUpdateSurveyResponseAddressesArgs = {
  input: BatchUpdateSurveyResponseAddressesInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationBlockUserArgs = {
  input: BlockUserInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationBulkEditQuestionsArgs = {
  input: BulkEditQuestionsInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationBulkEditStockLocationMappingsArgs = {
  input: BulkEditStockLocationMappingsInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCancelBackingArgs = {
  input: CancelBackingInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCancelProjectArgs = {
  input: CancelProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationClearUserUnseenActivityArgs = {
  input: ClearUserUnseenActivityInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCloseWaveArgs = {
  input: CloseWaveInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCompleteOnSessionCheckoutArgs = {
  input: CompleteOnSessionCheckoutInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCompleteOrderArgs = {
  input: CompleteOrderInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCompleteZeroDollarOrderArgs = {
  input: CompleteZeroDollarOrderInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationConfirmOrderAddressArgs = {
  input: ConfirmOrderAddressInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCopyRewardItemsArgs = {
  input: CopyRewardItemsInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateAddressArgs = {
  input: CreateAddressInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateApplePayBackingArgs = {
  input: CreateApplePayBackingInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateAssetArgs = {
  input: CreateAssetInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateAttributionEventArgs = {
  input: CreateAttributionEventInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateBackerReportSegmentArgs = {
  input: CreateBackerReportSegmentInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateBackerSurveyArgs = {
  input: CreateBackerSurveyInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateBackingArgs = {
  input: CreateBackingInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateCheckoutArgs = {
  input: CreateCheckoutInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateCommentArgs = {
  input: PostCommentInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateCountrySignupArgs = {
  input: CreateCountrySignupInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateCreatorInterviewArgs = {
  input: CreateCreatorInterviewInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateEditorialLayoutArgs = {
  input: CreateEditorialLayoutTypeInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateFlaggingArgs = {
  input: CreateFlaggingInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateFreeformPostArgs = {
  input: CreateFreeformPostInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateOptionArgs = {
  input: CreateOptionInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateOrUpdateBackingAddressArgs = {
  input: CreateOrUpdateBackingAddressInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateOrUpdateItemTaxConfigArgs = {
  input: CreateOrUpdateItemTaxConfigInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateOrUpdateShippingZoneArgs = {
  input: CreateOrUpdateShippingZoneInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateOrUpdateTrackingNumberArgs = {
  input: CreateOrUpdateTrackingNumberInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateOrUpdateVatConfigArgs = {
  input: CreateOrUpdateVatConfigInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreatePaymentIntentArgs = {
  input: CreatePaymentIntentInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreatePaymentSourceArgs = {
  input: CreatePaymentSourceInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreatePledgeManagementRewardArgs = {
  input: CreatePledgeManagementRewardInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateProjectArgs = {
  input: CreateProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateProjectCommentArgs = {
  input: PostProjectCommentInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateProjectDepositAccountArgs = {
  input: CreateProjectDepositAccountInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateProjectImageArgs = {
  input: CreateProjectImageInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateProjectPaymentSourceArgs = {
  input: CreateProjectPaymentSourceInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateProjectUpdateRequestArgs = {
  input: CreateProjectUpdateRequestInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateProjectVideoArgs = {
  input: CreateProjectVideoInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateQuestionArgs = {
  input: CreateQuestionInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateRewardArgs = {
  input: CreateRewardInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateRewardItemArgs = {
  input: CreateRewardItemInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateSetupIntentArgs = {
  input: CreateSetupIntentInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateSheetForProjectArgs = {
  input: CreateSheetForProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateTrackEventArgs = {
  input: CreateTrackEventInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateUserSlugArgs = {
  input: CreateUserSlugInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateUserUrlArgs = {
  input: CreateUserUrlsInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateVideoTrackArgs = {
  input: CreateVideoTrackInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationCreateWaveArgs = {
  input: CreateWaveInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeactivatePrelaunchArgs = {
  input: DeactivateProjectPrelaunchInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeactivateProjectCollaboratorArgs = {
  input: DeactivateProjectCollaboratorInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteAddressArgs = {
  input: DeleteAddressInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteAssetArgs = {
  input: DeleteAssetInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteBackerReportSegmentArgs = {
  input: DeleteBackerReportSegmentInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteBackerSurveyArgs = {
  input: DeleteBackerSurveyInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteCommentArgs = {
  input: DeleteCommentInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteOptionArgs = {
  input: DeleteOptionInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeletePostArgs = {
  input: DeletePostInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteProjectArgs = {
  input: DeleteProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteProjectCommentArgs = {
  input: DeleteProjectCommentInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteProjectImageArgs = {
  input: DeleteProjectImageInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteProjectVideoArgs = {
  input: DeleteProjectVideoInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteQuestionArgs = {
  input: DeleteQuestionInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteRewardArgs = {
  input: DeleteRewardInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteRewardItemArgs = {
  input: DeleteRewardItemInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteShippingZoneArgs = {
  input: DeleteShippingZoneInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteStockLocationArgs = {
  input: DeleteStockLocationInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteUserUrlArgs = {
  input: DeleteUserUrlsInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDeleteVideoTrackArgs = {
  input: DeleteVideoTrackInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDislikeProjectArgs = {
  input: DislikeProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationDistributeDigitalAccessResourcesArgs = {
  input: DistributeDigitalAccessResourcesInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationEndLatePledgesArgs = {
  input: EndLatePledgesInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationFeatureRewardArgs = {
  input: FeatureRewardInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationFollowUserArgs = {
  input: FollowUserInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationGenerateProjectPreviewArgs = {
  input: GenerateProjectPreviewInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationInviteProjectCollaboratorArgs = {
  input: InviteProjectCollaboratorInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationIssueRefundArgs = {
  input: IssueRefundInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationLaunchProjectArgs = {
  input: LaunchProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationLikePostArgs = {
  input: LikePostInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationLikeProjectArgs = {
  input: LikeProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationLikeQuizProjectArgs = {
  input: LikeQuizProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationLockAddressesArgs = {
  input: LockAddressesInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationMigrateToFulfillmentStatusArgs = {
  input: MigrateToFulfillmentStatusInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationOptOutOfPledgeManagerArgs = {
  input: OptOutOfPledgeManagerInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationPaymentSourceDeleteArgs = {
  input: PaymentSourceDeleteInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationPinPostArgs = {
  input: PinPostInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationPostExcludeRewardArgs = {
  input: PostExcludeRewardInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationPostIncludeRewardArgs = {
  input: PostIncludeRewardInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationProcessTrackingNumbersArgs = {
  input: ProcessTrackingNumbersInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationPublishEditorialLayoutArgs = {
  input: PublishEditorialLayoutTypeInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationPublishPostArgs = {
  input: PublishPostInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationRefreshSpreadsheetDataArgs = {
  input: RefreshSpreadsheetDataInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationRemoveSheetFromProjectArgs = {
  input: RemoveSheetFromProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationReportSpamArgs = {
  input: ReportSpamInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationRequestPasswordResetArgs = {
  input: RequestPasswordResetInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationResetBackerSurveyArgs = {
  input: ResetBackerSurveyInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationReviewPledgeManagerArgs = {
  input: ReviewPledgeManagerInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSendMessageArgs = {
  input: SendMessageInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSendSubmissionMessageArgs = {
  input: SendSubmissionMessageInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSendSurveyArgs = {
  input: SendSurveyInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSetAddressAsPrimaryArgs = {
  input: SetAddressAsPrimaryInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSetAddressCollectionEnabledArgs = {
  input: SetAddressCollectionEnabledInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSetBackingFulfillmentStatusesArgs = {
  input: SetBackingFulfillmentStatusesInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSetBackingNoteArgs = {
  input: SetBackingNoteInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSetProjectSlugArgs = {
  input: SetProjectSlugInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSetProjectStatusArgs = {
  input: SetProjectStatusInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSetShippingConfigArgs = {
  input: SetShippingConfigInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSetTaxCategoryArgs = {
  input: SetTaxCategoryInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSignInWithAppleArgs = {
  input: SignInWithAppleInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSubmitPledgeManagerArgs = {
  input: SubmitPledgeManagerInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSubmitProjectArgs = {
  input: SubmitProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSubmitRefundCheckoutArgs = {
  input: SubmitRefundCheckoutInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSubmitResponsesArgs = {
  input: SubmitResponsesInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSubmitVatNumberArgs = {
  input: SubmitVatNumberInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationSucceedOrderArgs = {
  input: SucceedOrderInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationToggleCommentPinArgs = {
  input: ToggleCommentPinInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationToggleProjectMilestoneArgs = {
  input: ToggleProjectMilestoneInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationToggleProjectPreviewArgs = {
  input: ToggleProjectPreviewInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationToggleTariffSurchargesEnabledArgs = {
  input: ToggleTariffSurchargesEnabledInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationTranslateEditorialLayoutArgs = {
  input: TranslateEditorialLayoutTypeInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationTriggerThirdPartyEventArgs = {
  input: TriggerThirdPartyEventInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUnblockUserArgs = {
  input: UnblockUserInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUndislikeProjectArgs = {
  input: UndislikeProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUnfollowUserArgs = {
  input: UnfollowUserInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUnlikePostArgs = {
  input: UnlikePostInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUnlikeProjectArgs = {
  input: UnlikeProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUnpinPostArgs = {
  input: UnpinPostInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUnpublishEditorialLayoutArgs = {
  input: UnpublishEditorialLayoutTypeInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUntagProjectArgs = {
  input: UntagProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUnwatchProjectArgs = {
  input: UnwatchProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateAcceptsNewBackersArgs = {
  input: UpdateAcceptsNewBackersInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateBackerCompletedArgs = {
  input: UpdateBackerCompletedInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateBackerSurveyIntroArgs = {
  input: UpdateBackerSurveyIntroInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateBackingArgs = {
  input: UpdateBackingInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateBackingPaymentSourceArgs = {
  input: UpdateBackingPaymentSourceInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateConsentArgs = {
  input: UpdateConsentInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateCreatorInterviewArgs = {
  input: UpdateCreatorInterviewInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateCrossSellsOnOrderArgs = {
  input: UpdateCrossSellsOnOrderInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateFulfillmentModalDismissedAtArgs = {
  input: UpdateFulfillmentModalDismissedAtInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateFulfillmentStatusArgs = {
  input: UpdateFulfillmentStatusInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateItemVariantsArgs = {
  input: UpdateItemVariantsInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateItemWeightsArgs = {
  input: UpdateItemWeightsInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateOptionArgs = {
  input: UpdateOptionInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateOrderableConfigArgs = {
  input: UpdateOrderableConfigInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdatePledgeManagementRewardArgs = {
  input: UpdatePledgeManagementRewardInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdatePostArgs = {
  input: UpdatePostInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateProjectArgs = {
  input: UpdateProjectInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateProjectCollaboratorArgs = {
  input: UpdateProjectCollaboratorInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateProjectPaymentSourceArgs = {
  input: UpdateProjectPaymentSourceInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateProjectRiskStrategiesArgs = {
  input: UpdateProjectRiskStrategiesInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateProjectVerifiedCreatorNameArgs = {
  input: UpdateProjectVerifiedCreatorNameInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateQuestionArgs = {
  input: UpdateQuestionInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateResourceAudienceArgs = {
  input: UpdateResourceAudienceInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateRewardArgs = {
  input: UpdateRewardInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateRewardItemArgs = {
  input: UpdateRewardItemInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateRewardShippingRatesArgs = {
  input: UpdateRewardShippingRatesInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateSpreadsheetTogglesArgs = {
  input: UpdateSpreadsheetTogglesInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateUserAccountArgs = {
  input: UpdateUserAccountInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateUserNotificationArgs = {
  input: UpdateUserNotificationInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateUserNotificationFrequencyArgs = {
  input: UpdateUserNotificationFrequencyInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateUserProfileArgs = {
  input: UpdateUserProfileInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpdateUserSettingArgs = {
  input: UpdateUserSettingInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUpgradeRewardOnOrderArgs = {
  input: UpgradeRewardOnOrderInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationUserSendEmailVerificationArgs = {
  input: UserSendEmailVerificationInput;
};


/** The mutation root of the Kickstarter GraphQL interface */
export type MutationWatchProjectArgs = {
  input: WatchProjectInput;
};

/** A curated set of news articles */
export type NewsCollection = {
  __typename?: 'NewsCollection';
  id: Scalars['ID']['output'];
  /** The news items in this collection */
  newsItems: Array<Maybe<NewsItem>>;
  /** The localized title of this news collection */
  title?: Maybe<Scalars['String']['output']>;
};


/** A curated set of news articles */
export type NewsCollectionNewsItemsArgs = {
  all?: InputMaybe<Scalars['Boolean']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** A curated news article used in an editorial layout. */
export type NewsItem = {
  __typename?: 'NewsItem';
  /** The byline of this news item. */
  attribution?: Maybe<Scalars['String']['output']>;
  /** The localized description of this news item. */
  description?: Maybe<Scalars['String']['output']>;
  /** When this news item should be featured */
  featuredAt?: Maybe<Scalars['Date']['output']>;
  id: Scalars['ID']['output'];
  /** The url for the background image of the news item. */
  imageUrl?: Maybe<Scalars['String']['output']>;
  /** The primary language of the news item. `null` if available in all languages. */
  language?: Maybe<Scalars['String']['output']>;
  /** The type of content of this news item. */
  mediaType?: Maybe<Scalars['String']['output']>;
  /** The source or author of the news article. */
  source?: Maybe<Scalars['String']['output']>;
  /** The localized title of this news item. */
  title?: Maybe<Scalars['String']['output']>;
  /** The url that links to the news article. */
  url?: Maybe<Scalars['String']['output']>;
};

/** Sign up for a newsletter. */
export type NewsletterSignUp = {
  __typename?: 'NewsletterSignUp';
  /** Description of the newsletter */
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The source that should be recorded for the newsletter signup */
  newsletterSource?: Maybe<Scalars['String']['output']>;
  /** ID of the newsletter */
  newsletterType?: Maybe<Scalars['String']['output']>;
  /** Headline in the newsletter signup */
  signupHeadline?: Maybe<Scalars['String']['output']>;
  /** Name of the newsletter */
  title?: Maybe<Scalars['String']['output']>;
};

/** A subscription a user has to a particular newsletter. */
export type NewsletterSubscriptions = {
  __typename?: 'NewsletterSubscriptions';
  /** The subscription to the AlumniNewsletter newsletter */
  alumniNewsletter: Scalars['Boolean']['output'];
  /** The subscription to the ArtsCultureNewsletter newsletter */
  artsCultureNewsletter: Scalars['Boolean']['output'];
  /** The subscription to the ComicsNewsletter newsletter */
  comicsNewsletter: Scalars['Boolean']['output'];
  /** The subscription to the CreatorNewsletter newsletter */
  creatorNewsletter: Scalars['Boolean']['output'];
  /** The subscription to the FilmNewsletter newsletter */
  filmNewsletter: Scalars['Boolean']['output'];
  /** The subscription to the GamesNewsletter newsletter */
  gamesNewsletter: Scalars['Boolean']['output'];
  /** The subscription to the HappeningNewsletter newsletter */
  happeningNewsletter: Scalars['Boolean']['output'];
  /** The subscription to the InventNewsletter newsletter */
  inventNewsletter: Scalars['Boolean']['output'];
  /** The subscription to the LearningLabNewsletter newsletter */
  learningLabNewsletter: Scalars['Boolean']['output'];
  /** The subscription to the MusicNewsletter newsletter */
  musicNewsletter: Scalars['Boolean']['output'];
  /** The subscription to the ProjectsYoullLoveNewsletter newsletter */
  projectsYoullLoveNewsletter: Scalars['Boolean']['output'];
  /** The subscription to the PromoNewsletter newsletter */
  promoNewsletter: Scalars['Boolean']['output'];
  /** The subscription to the PublishingNewsletter newsletter */
  publishingNewsletter: Scalars['Boolean']['output'];
  /** The subscription to the WeeklyNewsletter newsletter */
  weeklyNewsletter: Scalars['Boolean']['output'];
};

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars['ID']['output'];
};

/** The bucket for a flagging (general reason). Does not included deprecated kinds. */
export enum NonDeprecatedFlaggingKind {
  /** backing-abuse */
  BackingAbuse = 'BACKING_ABUSE',
  /** backing-doxxing */
  BackingDoxxing = 'BACKING_DOXXING',
  /** backing-fraud */
  BackingFraud = 'BACKING_FRAUD',
  /** backing-spam */
  BackingSpam = 'BACKING_SPAM',
  /** charity */
  Charity = 'CHARITY',
  /** comment-abuse */
  CommentAbuse = 'COMMENT_ABUSE',
  /** comment-doxxing */
  CommentDoxxing = 'COMMENT_DOXXING',
  /** comment-offtopic */
  CommentOfftopic = 'COMMENT_OFFTOPIC',
  /** comment-spam */
  CommentSpam = 'COMMENT_SPAM',
  /** false-claims */
  FalseClaims = 'FALSE_CLAIMS',
  /** financial-contests-coupons */
  FinancialContestsCoupons = 'FINANCIAL_CONTESTS_COUPONS',
  /** financial-political-donations */
  FinancialPoliticalDonations = 'FINANCIAL_POLITICAL_DONATIONS',
  /** financial-services */
  FinancialServices = 'FINANCIAL_SERVICES',
  /** guidelines-abuse */
  GuidelinesAbuse = 'GUIDELINES_ABUSE',
  /** guidelines-spam */
  GuidelinesSpam = 'GUIDELINES_SPAM',
  /** guidelines-violation */
  GuidelinesViolation = 'GUIDELINES_VIOLATION',
  /** health-claims */
  HealthClaims = 'HEALTH_CLAIMS',
  /** health-energy-food-and-drink */
  HealthEnergyFoodAndDrink = 'HEALTH_ENERGY_FOOD_AND_DRINK',
  /** health-gmos */
  HealthGmos = 'HEALTH_GMOS',
  /** health-live-animals */
  HealthLiveAnimals = 'HEALTH_LIVE_ANIMALS',
  /** health-regulations */
  HealthRegulations = 'HEALTH_REGULATIONS',
  /** misrep-support */
  MisrepSupport = 'MISREP_SUPPORT',
  /** misrep-support-impersonation */
  MisrepSupportImpersonation = 'MISREP_SUPPORT_IMPERSONATION',
  /** misrep-support-other */
  MisrepSupportOther = 'MISREP_SUPPORT_OTHER',
  /** misrep-support-outstanding-fulfillment */
  MisrepSupportOutstandingFulfillment = 'MISREP_SUPPORT_OUTSTANDING_FULFILLMENT',
  /** misrep-support-suspicious-pledging */
  MisrepSupportSuspiciousPledging = 'MISREP_SUPPORT_SUSPICIOUS_PLEDGING',
  /** not-project */
  NotProject = 'NOT_PROJECT',
  /** not-project-barebones */
  NotProjectBarebones = 'NOT_PROJECT_BAREBONES',
  /** not-project-charity */
  NotProjectCharity = 'NOT_PROJECT_CHARITY',
  /** not-project-other */
  NotProjectOther = 'NOT_PROJECT_OTHER',
  /** not-project-personal-expenses */
  NotProjectPersonalExpenses = 'NOT_PROJECT_PERSONAL_EXPENSES',
  /** not-project-stunt-or-hoax */
  NotProjectStuntOrHoax = 'NOT_PROJECT_STUNT_OR_HOAX',
  /** offensive-content-hate */
  OffensiveContentHate = 'OFFENSIVE_CONTENT_HATE',
  /** offensive-content-porn */
  OffensiveContentPorn = 'OFFENSIVE_CONTENT_PORN',
  /** plagiarism */
  Plagiarism = 'PLAGIARISM',
  /** post-funding-creator-inappropriate */
  PostFundingCreatorInappropriate = 'POST_FUNDING_CREATOR_INAPPROPRIATE',
  /** post-funding-creator-selling-elsewhere */
  PostFundingCreatorSellingElsewhere = 'POST_FUNDING_CREATOR_SELLING_ELSEWHERE',
  /** post-funding-creator-uncommunicative */
  PostFundingCreatorUncommunicative = 'POST_FUNDING_CREATOR_UNCOMMUNICATIVE',
  /** post-funding-issues */
  PostFundingIssues = 'POST_FUNDING_ISSUES',
  /** post-funding-reward-delayed */
  PostFundingRewardDelayed = 'POST_FUNDING_REWARD_DELAYED',
  /** post-funding-reward-not-as-described */
  PostFundingRewardNotAsDescribed = 'POST_FUNDING_REWARD_NOT_AS_DESCRIBED',
  /** post-funding-shipped-never-received */
  PostFundingShippedNeverReceived = 'POST_FUNDING_SHIPPED_NEVER_RECEIVED',
  /** post-funding-suspicious-third-party */
  PostFundingSuspiciousThirdParty = 'POST_FUNDING_SUSPICIOUS_THIRD_PARTY',
  /** prohibited-items */
  ProhibitedItems = 'PROHIBITED_ITEMS',
  /** prototype-misrepresentation */
  PrototypeMisrepresentation = 'PROTOTYPE_MISREPRESENTATION',
  /** resale */
  Resale = 'RESALE',
  /** reselling */
  Reselling = 'RESELLING',
  /** spam */
  Spam = 'SPAM',
  /** undisclosed-ai-use */
  UndisclosedAiUse = 'UNDISCLOSED_AI_USE',
  /** vices-alcohol */
  VicesAlcohol = 'VICES_ALCOHOL',
  /** vices-drugs */
  VicesDrugs = 'VICES_DRUGS',
  /** vices-weapons */
  VicesWeapons = 'VICES_WEAPONS'
}

/** An object containing a user's notifications. */
export type Notification = {
  __typename?: 'Notification';
  /** Are email notifications enabled for this topic */
  email: Scalars['Boolean']['output'];
  /** The frequency of the notification */
  frequency?: Maybe<UserNotificationFrequency>;
  /** The ID of the Notification */
  id: Scalars['String']['output'];
  /** Are mobile notifications enabled for this topic */
  mobile: Scalars['Boolean']['output'];
  /** The ID of the associated Project */
  projectId?: Maybe<Scalars['String']['output']>;
  /** The name of the associated Project */
  projectName?: Maybe<Scalars['String']['output']>;
  /** The topic of the notification */
  topic: UserNotificationTopic;
};

export enum OnSessionPaymentIntentStatus {
  /** If the setup requires additional actions, such as authenticating with 3D Secure */
  RequiresAction = 'REQUIRES_ACTION',
  /** Setup of payment source was successful. */
  Succeeded = 'SUCCEEDED'
}

/** Autogenerated input type of OptOutOfPledgeManager */
export type OptOutOfPledgeManagerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The pledge manager id */
  pledgeManagerId: Scalars['ID']['input'];
};

/** Autogenerated return type of OptOutOfPledgeManager */
export type OptOutOfPledgeManagerPayload = {
  __typename?: 'OptOutOfPledgeManagerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  pledgeManager: PledgeManager;
};

/** An option type associated with an item (e.g. "size" or "color") */
export type OptionType = {
  __typename?: 'OptionType';
  id: Scalars['ID']['output'];
  /** The item associated with the option type */
  item: RewardItem;
  /** The option type name (e.g. "size" or "color") */
  name: Scalars['String']['output'];
  /** The option type prompt (e.g. "What size do you want?") */
  prompt: Scalars['String']['output'];
  /** The associated option values */
  values: Array<OptionValue>;
};

/** An option value (e.g. "red") associated with an option type (e.g. "color") */
export type OptionValue = {
  __typename?: 'OptionValue';
  id: Scalars['ID']['output'];
  /** The option type */
  optionType: OptionType;
  /** The option value */
  value: Scalars['String']['output'];
};

/** An order. */
export type Order = Node & {
  __typename?: 'Order';
  /** The delivery or home address associated with the order. */
  address?: Maybe<Address>;
  /** The associated backer */
  backer: User;
  /** The associated backing */
  backing: Backing;
  /** Whether or not the order can be partially refunded */
  canBePartiallyRefunded: Scalars['Boolean']['output'];
  /** Contains the backer's item preferences and responses to survey questions */
  cart?: Maybe<Cart>;
  /** Whether there is required action for the backer to take in their pledge manager */
  checkoutRequired: Scalars['Boolean']['output'];
  /** The state of checkout (taking into account order and cart status) */
  checkoutState: CheckoutStateEnum;
  /** Whether or not the order would be auto-exemptable if the order had no cross-sells. */
  checkoutVoucherOrBaseAutoCompletable: Scalars['Boolean']['output'];
  /** Add-ons selected for this order during Pledge Redemption */
  crossSells: Array<OrderOrderable>;
  /** The cross-sells total amount for the order */
  crossSellsTotal: Scalars['Int']['output'];
  /** The cross-sells total amount for the order, formatted */
  crossSellsTotalFormatted: Scalars['String']['output'];
  /** Add-ons selected for this order during Pledge Redemption with quantity */
  crossSellsWithQuantity: Array<OrderCrossSellWithQuantity>;
  /** Whether the order was upgraded from a crowdfunding reward to a pledge manager-only reward */
  crowdfundingRewardToNewRewardUpgrade: Scalars['Boolean']['output'];
  /** The currency of the order */
  currency: CurrencyCode;
  /** Whether the order is in a finalized state */
  finalized: Scalars['Boolean']['output'];
  /** Whether or not the order was finalized but non-exempt. */
  finalizedAndNotExempt: Scalars['Boolean']['output'];
  /** Whether or not the order has been fully refunded */
  fullyRefunded: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** Whether this order is a net new order for the pledge manager */
  isPledgeManagerNetNewBacker: Scalars['Boolean']['output'];
  /** The order location. */
  location?: Maybe<Location>;
  /** Whether the backer must acknowledge cross-sells to complete checkout */
  mustAcknowledgeCrossSells: Scalars['Boolean']['output'];
  /** Whether the backer must acknowledge upgrades to complete checkout */
  mustAcknowledgeUpgrades: Scalars['Boolean']['output'];
  /** The rewards included in the order */
  orderOrderables: Array<OrderOrderable>;
  /** Payment source used on an order. */
  paymentSource?: Maybe<PaymentSource>;
  /** The project associated with the order */
  project: Project;
  /** The amount refunded for the shipping */
  refundedShippingAmount: Scalars['Int']['output'];
  /** The amount refunded for the total tax */
  refundedTotalTax: Scalars['Int']['output'];
  /** The remaining cost */
  remainingCostFormatted: Scalars['String']['output'];
  /** The remaining shipping amount */
  remainingShippingAmountFormatted: Scalars['String']['output'];
  /** The remaining total tax */
  remainingTotalTaxFormatted: Scalars['String']['output'];
  /** The currently-selected reward upgrade on an order */
  rewardUpgrade?: Maybe<OrderOrderable>;
  /** The reward upgrade on an order after order is completed */
  rewardUpgradeFinal?: Maybe<OrderOrderable>;
  /** The shipments associated with the order */
  shipments: Array<Shipment>;
  /** The cost of shipping */
  shippingAmount?: Maybe<Scalars['Int']['output']>;
  /** The cost of shipping, formatted */
  shippingAmountFormatted?: Maybe<Scalars['String']['output']>;
  /** The order's state, e.g. draft, collected, dropped, etc. */
  state: OrderStateEnum;
  /** The total surcharge amount for the order */
  surchargeAmount?: Maybe<Scalars['Int']['output']>;
  /** The total surcharge amount for the order, formatted */
  surchargeAmountFormatted?: Maybe<Scalars['String']['output']>;
  /** The total cost for the order including taxes and shipping */
  total?: Maybe<Scalars['Int']['output']>;
  /** The total cost for the order including taxes and shipping, formatted */
  totalFormatted?: Maybe<Scalars['String']['output']>;
  /** The total tax amount for the order */
  totalTax?: Maybe<Scalars['Int']['output']>;
  /** The total tax amount for the order, formatted */
  totalTaxFormatted?: Maybe<Scalars['String']['output']>;
  /** Whether or not the location is in the EU or UK (uses VAT) */
  vatLocation: Scalars['Boolean']['output'];
};

/** An add-on reward included in an Order during Pledge Redemption as a Cross Sell. */
export type OrderCrossSellWithQuantity = {
  __typename?: 'OrderCrossSellWithQuantity';
  /** The orderable of the cross sell */
  orderable: Orderable;
  /** The quantity of the add-on in the Order */
  quantity: Scalars['Int']['output'];
  /** The total price of the cross-sell */
  totalPrice: Scalars['Int']['output'];
  /** The total price of the cross-sell, formatted */
  totalPriceFormatted: Scalars['String']['output'];
  /** The price of one unit of the cross-sell */
  unitPriceFormatted: Scalars['String']['output'];
};

/** Ordering direction values */
export enum OrderDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

/** An item included in an Order. */
export type OrderItem = {
  __typename?: 'OrderItem';
  id: Scalars['ID']['output'];
  /** The line item associated with the order item */
  lineItem?: Maybe<LineItem>;
  /** The name of the order item. This is the name of the product or service being purchased. */
  name: Scalars['String']['output'];
};

/** An orderable included in an Order, e.g. a reward. */
export type OrderOrderable = {
  __typename?: 'OrderOrderable';
  /** The price of one unit of the reward */
  baseAmount: Scalars['Int']['output'];
  /** The price of one unit of the reward */
  baseAmountFormatted: Scalars['String']['output'];
  /** The cost of the orderable, after voucher is applied */
  cost: Scalars['Int']['output'];
  /** The formatted cost of the orderable, after voucher is applied */
  costFormatted: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Whether the orderable has been removed after order collection */
  isRemoved: Scalars['Boolean']['output'];
  /** The order items associated with the reward */
  orderItems: Array<OrderItem>;
  /** The reward data for this OrderOrderable */
  orderable: Orderable;
  /** The amount refunded for the cost */
  refundedCost: Scalars['Int']['output'];
  /** The remaining cost */
  remainingCost: Scalars['Int']['output'];
  /** The remaining cost */
  remainingCostFormatted: Scalars['String']['output'];
  /** Whether the reward is voucher */
  voucher: Scalars['Boolean']['output'];
  /** The amount of the voucher */
  voucherAmount: Scalars['Int']['output'];
};

/** Parameters to refund an order orderable. */
export type OrderOrderableInput = {
  /** Non-voucher amount to refund */
  amount: Scalars['Int']['input'];
  /** ID of the order orderable */
  orderOrderableId: Scalars['Int']['input'];
  /** Whether the order orderable was removed */
  removed: Scalars['Boolean']['input'];
};

/** The state of the order, e.g. draft, submitted, successful, errored, missed. */
export enum OrderStateEnum {
  /** auto_exempt */
  AutoExempt = 'auto_exempt',
  /** calculated_exempt */
  CalculatedExempt = 'calculated_exempt',
  /** collected */
  Collected = 'collected',
  /** draft */
  Draft = 'draft',
  /** dropped */
  Dropped = 'dropped',
  /** refunded */
  Refunded = 'refunded'
}

/** Types that can be added to an Order */
export type Orderable = Reward;

/** Configuration for an Orderable for Cross-Sells. */
export type OrderableConfig = {
  __typename?: 'OrderableConfig';
  /** Is this reward currently available to add to an Order */
  available: Scalars['Boolean']['output'];
  /** Is this orderable available for cross-sells in Pledge Redemption. */
  enabled: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** The total number of an orderable available to be purchased */
  limit?: Maybe<Scalars['Int']['output']>;
  /** The number of an orderable a backer is allowed to add to their order */
  limitPerOrder?: Maybe<Scalars['Int']['output']>;
  /** The price charged for an orderable */
  price?: Maybe<Money>;
  /** How many of this reward are still available to claim during Pledge Redemption */
  remainingQuantity?: Maybe<Scalars['Int']['output']>;
};

/** An organization */
export type Organization = Node & {
  __typename?: 'Organization';
  id: Scalars['ID']['output'];
  /** An organization's name */
  name: Scalars['String']['output'];
  /** An organization's slug */
  slug: Scalars['String']['output'];
};

/** An edge in a connection. */
export type OrganizationEdge = {
  __typename?: 'OrganizationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Organization>;
};

/** Possible states for an organization membership */
export enum OrganizationMembershipState {
  Active = 'ACTIVE',
  Admin = 'ADMIN',
  Denied = 'DENIED',
  Inactive = 'INACTIVE',
  Pending = 'PENDING'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']['output']>;
};

export type PaymentIncrement = {
  __typename?: 'PaymentIncrement';
  /** The payment increment amount represented in various formats */
  amount: PaymentIncrementAmount;
  id?: Maybe<Scalars['ID']['output']>;
  paymentIncrementableId?: Maybe<Scalars['ID']['output']>;
  paymentIncrementableType?: Maybe<Scalars['String']['output']>;
  scheduledCollection: Scalars['ISO8601DateTime']['output'];
  state: PaymentIncrementState;
  stateReason?: Maybe<PaymentIncrementStateReason>;
};

/** Representations of the payment increment amount with cents, float, and currency variations */
export type PaymentIncrementAmount = {
  __typename?: 'PaymentIncrementAmount';
  /** The increment amount in the smallest denomination of the currency, ie 3750 for the USD currency */
  amountAsCents: Scalars['String']['output'];
  /** The increment amount represented as a float, ie 37.50 for the USD currency */
  amountAsFloat: Scalars['String']['output'];
  /** The increment amount represented as a float with the currency symbol, ie $37.50 */
  amountFormattedInProjectNativeCurrency: Scalars['String']['output'];
  /** The increment amount represented as a float with the currency symbol and three-letter currency code, ie $37.50 USD */
  amountFormattedInProjectNativeCurrencyWithCurrencyCode: Scalars['String']['output'];
  /** A three-letter currency code for the increment (ie the currency of the project) */
  currency: Scalars['String']['output'];
};

export enum PaymentIncrementState {
  /** Payment increment is cancelled by user action or is an abandoned increment due to failure to complete payment */
  Cancelled = 'CANCELLED',
  /** Backer issued a dispute and we (kickstarter) lost the dispute */
  ChargebackLost = 'CHARGEBACK_LOST',
  /** Payment source was successfully charged */
  Collected = 'COLLECTED',
  /** Payment source could not be charged due to an errored payment source or authentication being required */
  Errored = 'ERRORED',
  /** The initial state of the payment increment; payment source has not been charged */
  Unattempted = 'UNATTEMPTED'
}

export enum PaymentIncrementStateReason {
  /** The payment source has attempted to be charged, but issuer requires additional authentication to complete the payment */
  RequiresAction = 'REQUIRES_ACTION'
}

/** A payment plan for a pledge over time project */
export type PaymentPlan = {
  __typename?: 'PaymentPlan';
  /** Amount is enough to qualify for pledge over time, if project allows */
  amountIsPledgeOverTimeEligible: Scalars['Boolean']['output'];
  paymentIncrements?: Maybe<Array<PaymentIncrement>>;
  /** Whether the project permits pledge over time pledges */
  projectIsPledgeOverTimeAllowed: Scalars['Boolean']['output'];
};

/** Payment sources */
export type PaymentSource = BankAccount | CreditCard;

/** Autogenerated input type of PaymentSourceDelete */
export type PaymentSourceDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  paymentSourceId: Scalars['String']['input'];
};

/** Autogenerated return type of PaymentSourceDelete */
export type PaymentSourceDeletePayload = {
  __typename?: 'PaymentSourceDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Payment types */
export enum PaymentTypes {
  CreditCard = 'CREDIT_CARD'
}

/** A representation of the creator's progress through the payments & identity parts of Project Build onboarding. Currently just their overall 'status' */
export type PaymentsOnboarding = {
  __typename?: 'PaymentsOnboarding';
  status: PaymentsOnboardingStatus;
};

/** The overall status of the payments & identity onboarding flow of project build. */
export enum PaymentsOnboardingStatus {
  /** The creator successfully completed payments & identity onboarding */
  Complete = 'complete',
  /** The creator has started onboarding but has not yet finished */
  InProgress = 'in_progress',
  /** The creator must proceed to Stripe Hosted Onboarding to finish onboarding */
  RequiresHostedOnboarding = 'requires_hosted_onboarding'
}

/** A photo */
export type Photo = Node & {
  __typename?: 'Photo';
  /** Alt text on the image */
  altText: Scalars['String']['output'];
  /** The fingerprint of the photo */
  fingerprint?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Upload status of the photo */
  status: AssetState;
  /** URL of the photo */
  url: Scalars['String']['output'];
};


/** A photo */
export type PhotoUrlArgs = {
  blur?: InputMaybe<Scalars['Boolean']['input']>;
  width: Scalars['Int']['input'];
};

/** Autogenerated input type of PinPost */
export type PinPostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of PinPost */
export type PinPostPayload = {
  __typename?: 'PinPostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  post?: Maybe<Postable>;
};

/** Represents a project's pledge manager */
export type PledgeManager = {
  __typename?: 'PledgeManager';
  /** Whether the pledge manager accepts new backers or not */
  acceptsNewBackers: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** Notes associated with the pledge manager */
  notes: Array<Scalars['String']['output']>;
  /** Whether the creator opted out of the pledge manager. */
  optedOut: Scalars['Boolean']['output'];
  /** The associated project */
  project: Project;
  /** The pledge manager's state, e.g. draft, submitted, approved, denied, etc. */
  state: PledgeManagerStateEnum;
  /** Whether the pledge manager can be used to charge for tariffs. */
  tariffSurchargesEnabled: Scalars['Boolean']['output'];
};

/** The state of the pledge manager, e.g. draft, submitted, approved, denied. */
export enum PledgeManagerStateEnum {
  /** approved */
  Approved = 'approved',
  /** denied */
  Denied = 'denied',
  /** draft */
  Draft = 'draft',
  /** submitted */
  Submitted = 'submitted'
}

/** Pledged projects in pledge projects overview */
export type PledgeProjectOverviewItem = {
  __typename?: 'PledgeProjectOverviewItem';
  /** backing details */
  backing?: Maybe<Backing>;
  /** tags */
  flags?: Maybe<Array<PledgedProjectsOverviewPledgeFlags>>;
  /** tier type */
  tierType?: Maybe<Scalars['String']['output']>;
  /** webview url for survey responses or pledge management */
  webviewUrl?: Maybe<Scalars['String']['output']>;
};

/** An edge in a connection. */
export type PledgeProjectOverviewItemEdge = {
  __typename?: 'PledgeProjectOverviewItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PledgeProjectOverviewItem>;
};

/** Provides an overview of pledge projects */
export type PledgeProjectsOverview = {
  __typename?: 'PledgeProjectsOverview';
  /** List of sort options */
  filterOption?: Maybe<Array<PledgeProjectsOverviewOptionSet>>;
  /** List of pledged projects */
  pledges?: Maybe<PledgedProjectsOverviewPledgesConnection>;
  /** List of sort options */
  sortOptions?: Maybe<Array<PledgeProjectsOverviewOptionSet>>;
};


/** Provides an overview of pledge projects */
export type PledgeProjectsOverviewPledgesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PledgeProjectsOverviewFilterInput = {
  /** Filter by one or more years. */
  pledgeDate?: InputMaybe<Scalars['Int']['input']>;
  /** Filter by one or more reward statuses. */
  rewardStatuses?: InputMaybe<PledgeProjectsOverviewRewardStatusFilter>;
};

/** sort option group */
export type PledgeProjectsOverviewOptionSet = {
  __typename?: 'PledgeProjectsOverviewOptionSet';
  /** List of sort option groups */
  items?: Maybe<Array<PledgeProjectsOverviewOptionSetItem>>;
  /** Title of the sort option group */
  title: Scalars['String']['output'];
};

/** sort option group */
export type PledgeProjectsOverviewOptionSetItem = {
  __typename?: 'PledgeProjectsOverviewOptionSetItem';
  /** Label for sort option */
  label: Scalars['String']['output'];
  /** Value for sort option */
  value: Scalars['String']['output'];
};

export enum PledgeProjectsOverviewRewardStatusFilter {
  /** Pledges awaiting rewards for */
  AwaitingReward = 'AWAITING_REWARD',
  /** All reward types */
  All = 'All',
  /** Pledges with no rewards */
  NoReward = 'NO_REWARD',
  /** pledges reward received */
  Received = 'RECEIVED'
}

/** Buckets of amount pledged */
export enum PledgedBuckets {
  /** Range from 0 to 1000 USD */
  Bucket_0 = 'BUCKET_0',
  /** Range from 1000 to 10000 USD */
  Bucket_1 = 'BUCKET_1',
  /** Range from 10000 to 100000 USD */
  Bucket_2 = 'BUCKET_2',
  /** Range from 100000 to 1000000 USD */
  Bucket_3 = 'BUCKET_3',
  /** Range from 1000000 to Infinity USD */
  Bucket_4 = 'BUCKET_4'
}

/** Flags for pledge in projects overview dashboard */
export type PledgedProjectsOverviewPledgeFlags = {
  __typename?: 'PledgedProjectsOverviewPledgeFlags';
  /** Flag icon type, e.g. time, alert, etc. */
  icon?: Maybe<Scalars['String']['output']>;
  /** Translated flag message */
  message?: Maybe<Scalars['String']['output']>;
  /** Flag type, e.g. warning, alert, etc. */
  type?: Maybe<Scalars['String']['output']>;
};

/** The connection type for PledgeProjectOverviewItem. */
export type PledgedProjectsOverviewPledgesConnection = {
  __typename?: 'PledgedProjectsOverviewPledgesConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PledgeProjectOverviewItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PledgeProjectOverviewItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** Post types */
export enum Post {
  CreatorInterview = 'CreatorInterview',
  FreeformPost = 'FreeformPost'
}

/** List actions current user can perform on a post */
export type PostActions = {
  __typename?: 'PostActions';
  destroy: Scalars['Boolean']['output'];
  edit: Scalars['Boolean']['output'];
  pin: Scalars['Boolean']['output'];
  publish: Scalars['Boolean']['output'];
  read: Scalars['Boolean']['output'];
  update: Scalars['Boolean']['output'];
};

/** The project roles a project update author can have. */
export enum PostAuthorRole {
  Collaborator = 'collaborator',
  Creator = 'creator'
}

/** Autogenerated input type of PostComment */
export type PostCommentInput = {
  /** The body of the comment */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the object you are commenting on */
  commentableId: Scalars['ID']['input'];
  /** The ID of the comment you are replying to */
  parentId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of PostComment */
export type PostCommentPayload = {
  __typename?: 'PostCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  comment?: Maybe<Comment>;
};

/** The connection type for Postable. */
export type PostConnection = {
  __typename?: 'PostConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PostableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Postable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** Autogenerated input type of PostExcludeReward */
export type PostExcludeRewardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  postId: Scalars['ID']['input'];
  rewardId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of PostExcludeReward */
export type PostExcludeRewardPayload = {
  __typename?: 'PostExcludeRewardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  post?: Maybe<Postable>;
};

/** The possible post types. */
export enum PostFormat {
  CreatorInterview = 'creator_interview',
  FreeformPost = 'freeform_post'
}

/** Autogenerated input type of PostIncludeReward */
export type PostIncludeRewardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  postId: Scalars['ID']['input'];
  rewardId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of PostIncludeReward */
export type PostIncludeRewardPayload = {
  __typename?: 'PostIncludeRewardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  post?: Maybe<Postable>;
};

/** Autogenerated input type of PostProjectComment */
export type PostProjectCommentInput = {
  /** The body of the comment */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment you are replying to */
  parentId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the project you are commenting on */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of PostProjectComment */
export type PostProjectCommentPayload = {
  __typename?: 'PostProjectCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  comment?: Maybe<Comment>;
};

/** Possible states for project posts. */
export enum PostState {
  Draft = 'draft',
  Processing = 'processing',
  Published = 'published'
}

/** Something that can be posted */
export type Postable = {
  /** Actions you can currently perform */
  actions: PostActions;
  /** The author of the project update. */
  author: User;
  /** The author role of the project update. */
  authorRole: PostAuthorRole;
  /** The date the project update was created. */
  createdAt: Scalars['DateTime']['output'];
  /** All rewards belonging to a post that were specifically marked by a creator to be excluded from receiving a post notification. This does not, however, include the no reward tier. */
  excludedRewards?: Maybe<RewardConnection>;
  /** Users that have liked this project update. */
  fans?: Maybe<UserConnection>;
  /** True if creator has excluded the no reward tier from receiving a post notification. */
  hasExcludedNoRewardTier?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  /** All rewards that were marked to recieve a post notification, excluding the no reward tier. */
  includedRewards?: Maybe<RewardConnection>;
  /** Whether or not the current user has liked this project update. */
  isLiked: Scalars['Boolean']['output'];
  /** True if marked as a public public post, false if the post is backers only. */
  isPublic: Scalars['Boolean']['output'];
  /**
   * True if the post's content is visible to the user.
   * @deprecated Query the read field in post abilities instead.
   */
  isVisible: Scalars['Boolean']['output'];
  /** The number of likes a post has. */
  likesCount: Scalars['Int']['output'];
  /** The next post. */
  nextPost?: Maybe<Postable>;
  /** The project update number. */
  number: Scalars['Int']['output'];
  /** The date the project update was pinned. */
  pinnedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The previous post. */
  previousPost?: Maybe<Postable>;
  /** Project that belongs to post. */
  project: Project;
  /** The date the project update was published. */
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** How much time a creator or collaborator has left to edit the post. */
  timeLeftToEdit?: Maybe<Scalars['String']['output']>;
  /** The project update's title. */
  title?: Maybe<Scalars['String']['output']>;
  /** The post type. */
  type: Post;
  /** The date the project update was last edited. */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The project update's URL. */
  url: Scalars['String']['output'];
};


/** Something that can be posted */
export type PostableExcludedRewardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Something that can be posted */
export type PostableFansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Something that can be posted */
export type PostableIncludedRewardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type PostableEdge = {
  __typename?: 'PostableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Postable>;
};

/** Completion status of objects necessary for pledge redemption */
export enum PrereqCompletionStatus {
  /** Prereq is complete */
  Complete = 'complete',
  /** Prereq has been started but is not complete */
  Incomplete = 'incomplete',
  /** Prereq has not been started */
  NotStarted = 'not_started'
}

/** Autogenerated input type of ProcessTrackingNumbers */
export type ProcessTrackingNumbersInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
  s3Key: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of ProcessTrackingNumbers */
export type ProcessTrackingNumbersPayload = {
  __typename?: 'ProcessTrackingNumbersPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** A project on Kickstarter. */
export type Project = Commentable & Node & {
  __typename?: 'Project';
  /** Account information. */
  accountInfo?: Maybe<AccountInfo>;
  /** Actions you can currently perform */
  actions: ProjectActions;
  /** The active checkout_wave, if there is one */
  activeWave?: Maybe<CheckoutWave>;
  /** Backing Add-ons */
  addOns?: Maybe<ProjectRewardConnection>;
  /** The project's additional category. */
  additionalSubcategory?: Maybe<Category>;
  /** Whether or not the creator has enabled address collection */
  addressCollectionEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not the creator has enabled address collection for digital reward backers */
  addressCollectionForDigitalReward?: Maybe<Scalars['Boolean']['output']>;
  aiDisclosure?: Maybe<AiDisclosure>;
  /** The total amount collected for add-ons in the pledge manager */
  amountCollectedForPledgeManagerAddons: Scalars['String']['output'];
  /** The total amount collected for shipping in the pledge manager */
  amountCollectedForShipping: Scalars['String']['output'];
  /** Available card types. */
  availableCardTypes: Array<CreditCardTypes>;
  /** A list of currencies that the project's country can use */
  availableFundingCurrenciesForCountry: Array<CurrencyCode>;
  /** The average sentiment of the project */
  averageSentiment: Scalars['Float']['output'];
  /** The lockout date for address collection */
  backerAddressLockoutDate?: Maybe<Scalars['DateTime']['output']>;
  /** Whether or not the backer address lockout date has passed. */
  backerAddressLockoutDatePassed: Scalars['Boolean']['output'];
  /** Returns the backer report in JSON format */
  backerReport?: Maybe<Scalars['JSON']['output']>;
  /** Backer survey for the project */
  backerSurvey?: Maybe<BackerSurvey>;
  /** An optional introduction to the backer survey. */
  backerSurveyIntro?: Maybe<Scalars['HTML']['output']>;
  /** Backers of the project */
  backers?: Maybe<Array<User>>;
  /** Total backers for the project */
  backersCount: Scalars['Int']['output'];
  /** The number of backers who have yet to go through the pledge manager */
  backersRemainingForPledgeRedemption: Scalars['Int']['output'];
  /** The current user's backing of this project.  Does not include inactive backings. */
  backing?: Maybe<Backing>;
  /** True if the current user can comment (considers restrictions) */
  canComment: Scalars['Boolean']['output'];
  /** True if the current user can comment (does not consider restrictions) */
  canCommentSansRestrictions: Scalars['Boolean']['output'];
  /** Whether user is allowed to edit project status */
  canUserEditProjectStatus: Scalars['Boolean']['output'];
  /** Whether a user can request an update about this project from the Creator */
  canUserRequestUpdate: Scalars['Boolean']['output'];
  /** Whether user is a backer of the project or not */
  canUserViewProjectStatusFeedback: Scalars['Boolean']['output'];
  /** If the project is in a canceled state, when was it canceled? */
  canceledAt?: Maybe<Scalars['DateTime']['output']>;
  /** The project's category. */
  category?: Maybe<Category>;
  /** The path to change the current user's payment method for their pledge to this project. */
  changeMethodProjectPledgePath: Scalars['String']['output'];
  /** Will this project be using a pledge manager to charge shipping? */
  chargeShippingInPledgeManager: Scalars['Boolean']['output'];
  /** Permissions that can be assigned to a collaborator on a project */
  collaboratorPermissions: Array<CollaboratorPermission>;
  /** A project's collaborators. */
  collaborators?: Maybe<ProjectCollaboratorConnection>;
  /** List of comments on the commentable */
  comments?: Maybe<CommentConnection>;
  /** Comment count - defaults to root level comments only */
  commentsCount: Scalars['Int']['output'];
  /** Representation of the Project Milestones */
  completedMilestones?: Maybe<Array<ProjectMilestone>>;
  /** Number of watchers who went on to back the project. */
  convertedWatchesCount?: Maybe<Scalars['Int']['output']>;
  /** The project's country */
  country: Country;
  /**
   * The project's country.
   * @deprecated Moved to country which returns CountryType.
   */
  countryCode: CountryCode;
  /** When the project was created */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** The project's creator. */
  creator?: Maybe<User>;
  /** The draft projects that have a share token for the project creator */
  creatorSharedDrafts?: Maybe<Array<Maybe<ProjectSharedDraft>>>;
  /** The paths for the creator tools pages */
  creatorToolsPaths: CreatorToolsPaths;
  /** The Curated Collection that a project is in e.g. Make 100 */
  curatedCollection?: Maybe<CuratedCollection>;
  /** The project's currency code. */
  currency: CurrencyCode;
  /** The current amount pledged in USD */
  currentAmountPledgedUsd?: Maybe<Scalars['Float']['output']>;
  /** When is the project scheduled to end? */
  deadlineAt?: Maybe<Scalars['DateTime']['output']>;
  /** The default currency for the project's country */
  defaultFundingCurrencyForCountry: CurrencyCode;
  /** The default no reward pledge amount based on the project's currency. */
  defaultPledge: Scalars['Int']['output'];
  /** A short description of the project. */
  description: Scalars['String']['output'];
  /** The path to destroy the current user's pledge for this project. */
  destroyProjectPledgePath: Scalars['String']['output'];
  /** Funding duration in days */
  duration?: Maybe<Scalars['Int']['output']>;
  /** The path to edit the current user's pledge for this project. */
  editProjectPledgePath: Scalars['String']['output'];
  /** The environmental commitments of the project. */
  environmentalCommitments?: Maybe<Array<Maybe<EnvironmentalCommitment>>>;
  /** List of FAQs of a project */
  faqs?: Maybe<ProjectFaqConnection>;
  /** The date at which pledge collections will end */
  finalCollectionDate?: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** A report by the current user for the project. */
  flagging?: Maybe<Flagging>;
  /** A project's friendly backers. */
  friends?: Maybe<ProjectBackerFriendsConnection>;
  /** When the fulfillment modal was dismissed */
  fulfillmentModalDismissedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Status of fulfillment */
  fulfillmentStatus?: Maybe<FulfillmentStatus>;
  /** When the fulfillment status was updated */
  fulfillmentStatusUpdatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The ratio of funding progress. */
  fundingRatio: Scalars['Ratio']['output'];
  /** Exchange rate for the current user's currency */
  fxRate: Scalars['Float']['output'];
  /** The project's title converted to a slug. */
  generatedSlug: Scalars['String']['output'];
  /** The minimum amount to raise for the project to be successful. */
  goal?: Maybe<Money>;
  /** API secret for Google Analytics event */
  googleAnalyticsApiSecret?: Maybe<Scalars['String']['output']>;
  /** The Google Analytics tracking ID. */
  googleAnalyticsTrackingId?: Maybe<Scalars['String']['output']>;
  /** Does this project have any pledge over time config record? */
  hasPledgeOverTimeConfig: Scalars['Boolean']['output'];
  /** Does this project have any post-campaign config? */
  hasPostCampaignConfig: Scalars['Boolean']['output'];
  /** Whether or not the project has reward images */
  hasRewardImages: Scalars['Boolean']['output'];
  /** Whether a project has its slug set. */
  hasSlug: Scalars['Boolean']['output'];
  /** If the payout for the funds capture has happened */
  hasSuccessfulFundsCapturePayout: Scalars['Boolean']['output'];
  /** Whether or not the project has supporting materials (Prototype Gallery) */
  hasSupportingMaterials: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** The project's primary image. */
  image?: Maybe<Photo>;
  /** A read-only representation of the image (complete with fallback default image) */
  imageUrl: Scalars['String']['output'];
  /** Is the project's submission state accepted. */
  isApproved: Scalars['Boolean']['output'];
  /** Has the current user disliked this project? */
  isDisliked: Scalars['Boolean']['output'];
  /** Is the project tagged with one of the Forward Fund tags? */
  isForwardFundTagged: Scalars['Boolean']['output'];
  /** Is this project currently accepting post-campaign pledges? */
  isInPostCampaignPledgingPhase: Scalars['Boolean']['output'];
  /** The project has launched */
  isLaunched: Scalars['Boolean']['output'];
  /** Has the current user liked this project? */
  isLiked: Scalars['Boolean']['output'];
  /** Whether a project is enrolled in plot */
  isPledgeOverTimeAllowed: Scalars['Boolean']['output'];
  /** Whether or not this is a Project of the Day. */
  isProjectOfTheDay?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not this is a Kickstarter-featured project. */
  isProjectWeLove: Scalars['Boolean']['output'];
  /** Whether the project is sharing it's budgeting information with the everyone */
  isSharingProjectBudget: Scalars['Boolean']['output'];
  /** Whether current user is creator of current project */
  isUserCreator: Scalars['Boolean']['output'];
  /** Whether a not the project can be watched. */
  isWatchable: Scalars['Boolean']['output'];
  /** Is the current user watching this project? */
  isWatched: Scalars['Boolean']['output'];
  /** Items available through the project's backer rewards. */
  items: Array<RewardItem>;
  /** A project's last uploaded video, if it's processing, or the current project video. */
  lastUploadedVideo?: Maybe<Video>;
  /** The last checkout_wave, if there is one */
  lastWave?: Maybe<CheckoutWave>;
  /** Total backers for the project during late pledge phase */
  latePledgeBackersCount: Scalars['Int']['output'];
  /** How much money is pledged to the project during late pledge phase. */
  latePledgePledged: Money;
  /** The datetime at which post-campaign pledging will end. This can be set to a future date if we have automatically scheduled an end to late pledging. */
  latePledgesEndedAt?: Maybe<Scalars['DateTime']['output']>;
  /** When the project launched */
  launchedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Where the project is based. */
  location?: Maybe<Location>;
  /** Possible VAT numbers the project could have, by location. */
  locationVatNumbers: Array<LocationVatNumber>;
  /** The max pledge amount for a single reward tier. */
  maxPledge: Scalars['Int']['output'];
  /** Whether or not the project has met KYC requirement */
  metKycRequirements: Scalars['Boolean']['output'];
  /** Access token for Meta Conversion API */
  metaCapiAccessToken?: Maybe<Scalars['String']['output']>;
  /** The unique identifier for the project's Meta Pixel ID */
  metaPixelId?: Maybe<Scalars['String']['output']>;
  /** List of milestones available to project, empty array if project has no possible milestones */
  milestoneCategories: Array<MilestoneCategory>;
  /** The min pledge amount for a single reward tier. */
  minPledge: Scalars['Int']['output'];
  /** The project's name. */
  name: Scalars['String']['output'];
  /** Whether the project has been enabled to allow new backers into pledge manager */
  newBackersEnabled: Scalars['Boolean']['output'];
  /** Whether the project's shipping rules designate no vat collection */
  noVatCollection: Scalars['Boolean']['output'];
  /** A Stripe account identifier */
  onBehalfOf?: Maybe<Scalars['String']['output']>;
  /** The order for the logged in user associated with the project */
  order?: Maybe<Order>;
  /** Build a payment plan given a project id and amount */
  paymentPlan?: Maybe<PaymentPlan>;
  /** Payment source on creator's account used to issue refunds. */
  paymentSource?: Maybe<CreditCard>;
  /** What percent the project has towards meeting its funding goal. */
  percentFunded: Scalars['Int']['output'];
  /** The project's pid. */
  pid: Scalars['Int']['output'];
  /** The project's pledge manager */
  pledgeManager?: Maybe<PledgeManager>;
  /** Backer-facing summary of when the incremental charges will occur */
  pledgeOverTimeCollectionPlanChargeExplanation?: Maybe<Scalars['String']['output']>;
  /** Quick summary of the amount of increments pledges will be spread over */
  pledgeOverTimeCollectionPlanChargedAsNPayments?: Maybe<Scalars['String']['output']>;
  /** Backer-facing short summary of this project's number of payment increments to split over */
  pledgeOverTimeCollectionPlanShortPitch?: Maybe<Scalars['String']['output']>;
  /** Does this project have Pledge Over Time enabled? */
  pledgeOverTimeEnabled: Scalars['Boolean']['output'];
  /** The minimum pledge amount to be eligible for PLOT, localized to the project currency */
  pledgeOverTimeMinimum?: Maybe<Scalars['String']['output']>;
  /** The minimum pledge amount to be eligible for PLOT, localized to the project currency and backer language */
  pledgeOverTimeMinimumExplanation?: Maybe<Scalars['String']['output']>;
  /** How much money is pledged to the project. */
  pledged: Money;
  /** The percentage of pledges that have been redeemed */
  pledgesRedeemedPercentage: Scalars['Float']['output'];
  /** Is this project configured for post-campaign pledges? */
  postCampaignPledgingEnabled: Scalars['Boolean']['output'];
  /** Project updates. */
  posts?: Maybe<PostConnection>;
  /** Whether a project has activated prelaunch. */
  prelaunchActivated: Scalars['Boolean']['output'];
  /** The rich text story for a prelaunch campaign. */
  prelaunchStory?: Maybe<Scalars['HTML']['output']>;
  /** The rich text story for a prelaunch campaign in raw form. */
  prelaunchStoryForEditor?: Maybe<Scalars['HTML']['output']>;
  /** Return an itemized version of the prelaunch story. This feature is in BETA: types can change anytime! */
  prelaunchStoryRichText: RichText;
  /** The project's preview url. */
  previewUrl?: Maybe<Scalars['String']['output']>;
  /** The project's profile. */
  profile?: Maybe<ProjectProfile>;
  /** The text of the currently applied project notice, empty if there is no notice */
  projectNotice?: Maybe<Scalars['String']['output']>;
  /** When this project was Project of the Day. */
  projectOfTheDayAt?: Maybe<Scalars['DateTime']['output']>;
  /** The root project id under which the comment is nested */
  projectRelayId: Scalars['ID']['output'];
  /** The project's bitly short URL */
  projectShortLink?: Maybe<Scalars['String']['output']>;
  /** Project's now and next status */
  projectStatus?: Maybe<ProjectStatus>;
  /** Exchange rate to US Dollars (USD) for the project's currency */
  projectUsdExchangeRate: Scalars['Float']['output'];
  /** Survey questions asked of all the project's backers */
  questions: Array<Question>;
  recommendations?: Maybe<Recommendations>;
  /** Project rewards. */
  rewards?: Maybe<ProjectRewardConnection>;
  /** Risk questions for the project plan. */
  riskQuestions: Array<RiskQuestion>;
  /** The risk mitigation strategies outlined for this project. */
  riskStrategies?: Maybe<Array<RiskStrategy>>;
  /** Potential hurdles to project completion. */
  risks: Scalars['String']['output'];
  /** whether project has shipping zone for 'rest of the world' location */
  rootShippingZoneExists: Scalars['Boolean']['output'];
  /** Is this project configured so that events should be triggered for Meta's Conversions API? */
  sendMetaCapiEvents: Scalars['Boolean']['output'];
  /** Is this project configured for third party analytics events? */
  sendThirdPartyEvents: Scalars['Boolean']['output'];
  /** Shipping destination countries on all rewards on the project */
  shippableCountries: Array<Location>;
  /** Details regarding how the project is set up to charge shipping */
  shippingConfig?: Maybe<ShippingConfig>;
  /** Whether or not the project has completed either flat-rate or weight-based shipping costs and setup */
  shippingCostsCompleted: Scalars['Boolean']['output'];
  /** Shipping zones configured for the project. */
  shippingZones: Array<ShippingZone>;
  /** Whether or not to show ended to live cta */
  showCtaToLiveProjects: Scalars['Boolean']['output'];
  /** Whether or not to show the signal of fulfillment modal */
  showSignalOfFulfillmentModal: Scalars['Boolean']['output'];
  /** The project's unique URL identifier. */
  slug: Scalars['String']['output'];
  /** The Google Sheet associated to this project */
  spreadsheet?: Maybe<Spreadsheet>;
  /** The project's current state. */
  state: ProjectState;
  /** The last time a project's state changed, time since epoch */
  stateChangedAt: Scalars['DateTime']['output'];
  /** The initial project stats polling duration in ms */
  statsInterval?: Maybe<Scalars['Int']['output']>;
  /** Locations from which the project fulfills */
  stockLocations: Array<StockLocation>;
  /** The story behind the project, parsed for presentation. */
  story: Scalars['HTML']['output'];
  /** The project description without conversion for usage by Rich Text Editors. */
  storyForEditor: Scalars['HTML']['output'];
  /** Return an itemized version of the story. This feature is in BETA: types can change anytime! */
  storyRichText: RichText;
  /** The Rich Text Editor version that was used to generate the project story */
  storyRteVersion?: Maybe<Scalars['String']['output']>;
  /** A project submission. */
  submission?: Maybe<Submission>;
  /** Tags project has been tagged with */
  tags: Array<Maybe<Tag>>;
  /** The project's target launch date */
  targetLaunchDate?: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** The time that the project's target launch date was updated */
  targetLaunchDateUpdatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** Tax categories configured for the project excluding the non-taxable category */
  taxCategories: Array<TaxCategory>;
  /** Whether or not the project has configured a deposit account address and vat id */
  taxInformationCompletionStatus: PrereqCompletionStatus;
  /** The timeline of project events, including updates and milestones. */
  timeline?: Maybe<ProjectTimelineConnection>;
  /**
   * Locations (including countries and root) where shipping rates or shipping zones have been configured
   *                   but there is no ship-from location assigned
   */
  unassignedShippableLocations: Array<Location>;
  /** A URL to the project's page. */
  url: Scalars['String']['output'];
  /** Exchange rate to US Dollars (USD), null for draft projects. */
  usdExchangeRate?: Maybe<Scalars['Float']['output']>;
  /** Whether or not the project has used legacy surveys. */
  usedLegacySurveys: Scalars['Boolean']['output'];
  /** The feedback the current user has left for the project */
  userFeedback?: Maybe<Array<Maybe<ProjectFeedback>>>;
  /** User groups associated with the project */
  userGroups: Array<UserGroup>;
  /** Was the current user removed from this project? */
  userWasRemoved: Scalars['Boolean']['output'];
  /** Name of user on verified account */
  verifiedCreatorName?: Maybe<Scalars['String']['output']>;
  /**
   * Name of user on verified account
   * @deprecated Use verified_creator_name instead
   */
  verifiedIdentity?: Maybe<Scalars['String']['output']>;
  /** A project video. */
  video?: Maybe<Video>;
  /** Number of watchers a project has. */
  watchesCount?: Maybe<Scalars['Int']['output']>;
};


/** A project on Kickstarter. */
export type ProjectAddOnsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  forLocation?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  pledgeManagementOnly?: InputMaybe<Scalars['Boolean']['input']>;
  sort?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A project on Kickstarter. */
export type ProjectBackerReportArgs = {
  actionsTaken?: InputMaybe<Array<Scalars['String']['input']>>;
  addons?: InputMaybe<Array<Scalars['ID']['input']>>;
  amountMax?: InputMaybe<Scalars['Int']['input']>;
  amountMin?: InputMaybe<Scalars['Int']['input']>;
  ascOrDesc?: InputMaybe<Scalars['String']['input']>;
  fulfillmentStatus?: InputMaybe<Array<Scalars['String']['input']>>;
  isLatePledge?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  items?: InputMaybe<Array<Scalars['ID']['input']>>;
  locations?: InputMaybe<Array<Scalars['ID']['input']>>;
  page?: InputMaybe<Scalars['Int']['input']>;
  perPage?: InputMaybe<Scalars['Int']['input']>;
  pledgeRedemptionState?: InputMaybe<Array<Scalars['String']['input']>>;
  pledgedAtMax?: InputMaybe<Scalars['String']['input']>;
  pledgedAtMin?: InputMaybe<Scalars['String']['input']>;
  rewards?: InputMaybe<Array<Scalars['ID']['input']>>;
  skus?: InputMaybe<Array<Scalars['ID']['input']>>;
  sortBy?: InputMaybe<Scalars['String']['input']>;
  sqlFilterAddons?: InputMaybe<SqlFilterOperator>;
  sqlFilterItems?: InputMaybe<SqlFilterOperator>;
  sqlFilterSkus?: InputMaybe<SqlFilterOperator>;
  status?: InputMaybe<Array<Scalars['String']['input']>>;
  surveyAnswered?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  term?: InputMaybe<Array<Scalars['String']['input']>>;
};


/** A project on Kickstarter. */
export type ProjectBackerSurveyIntroArgs = {
  assetWidth?: InputMaybe<Scalars['Int']['input']>;
};


/** A project on Kickstarter. */
export type ProjectBackersArgs = {
  followed?: InputMaybe<Scalars['Boolean']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A project on Kickstarter. */
export type ProjectCollaboratorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  withCreator?: InputMaybe<Scalars['Boolean']['input']>;
  withInvited?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A project on Kickstarter. */
export type ProjectCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A project on Kickstarter. */
export type ProjectCommentsCountArgs = {
  withReplies?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A project on Kickstarter. */
export type ProjectFaqsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A project on Kickstarter. */
export type ProjectFriendsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A project on Kickstarter. */
export type ProjectImageUrlArgs = {
  blur?: InputMaybe<Scalars['Boolean']['input']>;
  width: Scalars['Int']['input'];
};


/** A project on Kickstarter. */
export type ProjectItemsArgs = {
  excludeItemsWithoutRewards?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A project on Kickstarter. */
export type ProjectPaymentPlanArgs = {
  amount: Scalars['String']['input'];
};


/** A project on Kickstarter. */
export type ProjectPostsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  forActivePrompt?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  postType?: InputMaybe<PostFormat>;
  state?: InputMaybe<PostState>;
};


/** A project on Kickstarter. */
export type ProjectPrelaunchStoryArgs = {
  assetWidth?: InputMaybe<Scalars['Int']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** A project on Kickstarter. */
export type ProjectPrelaunchStoryForEditorArgs = {
  assetWidth?: InputMaybe<Scalars['Int']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** A project on Kickstarter. */
export type ProjectProjectShortLinkArgs = {
  ref_tag?: InputMaybe<BitlyHashes>;
};


/** A project on Kickstarter. */
export type ProjectRewardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  pledgeManagementOnly?: InputMaybe<Scalars['Boolean']['input']>;
  sort?: InputMaybe<Scalars['Boolean']['input']>;
  withActiveBackings?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A project on Kickstarter. */
export type ProjectRisksArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** A project on Kickstarter. */
export type ProjectStoryArgs = {
  assetWidth?: InputMaybe<Scalars['Int']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** A project on Kickstarter. */
export type ProjectStoryForEditorArgs = {
  assetWidth?: InputMaybe<Scalars['Int']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** A project on Kickstarter. */
export type ProjectTagsArgs = {
  scope: TagScope;
};


/** A project on Kickstarter. */
export type ProjectTimelineArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  withPinnedFirst?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A project on Kickstarter. */
export type ProjectUserFeedbackArgs = {
  questionName?: InputMaybe<Scalars['String']['input']>;
};

/** List actions current user can perform on a project */
export type ProjectActions = {
  __typename?: 'ProjectActions';
  /** Whether or not the user is in a state to see currency conversions */
  displayConvertAmount: Scalars['Boolean']['output'];
  shareDraft: Scalars['Boolean']['output'];
  /** Whether or not the external survey should be displayed */
  showExternalSurvey: Scalars['Boolean']['output'];
};

/** The connection type for User. */
export type ProjectBackerFriendsConnection = {
  __typename?: 'ProjectBackerFriendsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** The connection type for User. */
export type ProjectCollaboratorConnection = {
  __typename?: 'ProjectCollaboratorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProjectCollaboratorEdge = {
  __typename?: 'ProjectCollaboratorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The email of a collaborator on a project */
  email?: Maybe<Scalars['String']['output']>;
  /** The state of a collaborator's membership on a project */
  membershipState: CollaboratorMembershipState;
  /** The item at the end of the edge. */
  node?: Maybe<User>;
  /** The permissions of the collaborator */
  permissions: Array<CollaboratorPermission>;
  /** The title of a collaborator on a project */
  title?: Maybe<Scalars['String']['output']>;
};

/** A curated set of projects based off a search query */
export type ProjectCollection = {
  __typename?: 'ProjectCollection';
  id: Scalars['ID']['output'];
  /** The projects to display in this collection */
  projects: Array<Project>;
  /** The raw search query to populate the project collection */
  query?: Maybe<Scalars['String']['output']>;
  /** The localized title of this project collection */
  title?: Maybe<Scalars['String']['output']>;
  /** The label to track this project collection */
  trackingLabel?: Maybe<Scalars['String']['output']>;
  /** The url that is linked to the project collection */
  url?: Maybe<Scalars['String']['output']>;
};


/** A curated set of projects based off a search query */
export type ProjectCollectionProjectsArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
};

/** An edge in a connection. */
export type ProjectEdge = {
  __typename?: 'ProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Project>;
};

/** Faqs for a project */
export type ProjectFaq = {
  __typename?: 'ProjectFaq';
  /** Faq answer */
  answer: Scalars['String']['output'];
  /** When faq was posted */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** position */
  position: Scalars['Int']['output'];
  /** Faq question */
  question: Scalars['String']['output'];
  /** When faq was updated */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** The connection type for ProjectFaq. */
export type ProjectFaqConnection = {
  __typename?: 'ProjectFaqConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectFaqEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectFaq>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProjectFaqEdge = {
  __typename?: 'ProjectFaqEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectFaq>;
};

/** Structured feedback left by a user on a project */
export type ProjectFeedback = {
  __typename?: 'ProjectFeedback';
  /** When the answer was provided */
  createdAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** The answer the user provided */
  questionAnswer: Scalars['String']['output'];
  /** The name of the question the user answered */
  questionName: Scalars['String']['output'];
};

/** Milestones for projects */
export type ProjectMilestone = {
  __typename?: 'ProjectMilestone';
  /** When the Milestone was marked as completed */
  completedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** The category for the Milestone */
  milestoneCategory: Scalars['String']['output'];
};

/** A profile for after a project has ended. */
export type ProjectProfile = Node & {
  __typename?: 'ProjectProfile';
  /** The description of the projects from the project's profile. */
  blurb?: Maybe<Scalars['String']['output']>;
  /** Featured image for this project profile. */
  featureImageUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The name from the project's profile. */
  name?: Maybe<Scalars['String']['output']>;
  /** The project profile's current state. */
  state: ProjectProfileState;
};


/** A profile for after a project has ended. */
export type ProjectProfileFeatureImageUrlArgs = {
  width: Scalars['Int']['input'];
};

/** Various project profile states. */
export enum ProjectProfileState {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

/** The connection type for Reward. */
export type ProjectRewardConnection = {
  __typename?: 'ProjectRewardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RewardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Reward>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** A Project that has a generated share token. */
export type ProjectSharedDraft = {
  __typename?: 'ProjectSharedDraft';
  /** The project id of a shared draft */
  id: Scalars['String']['output'];
  /** The project name of a shared draft */
  name: Scalars['String']['output'];
};

/** What order to sort projects in */
export enum ProjectSort {
  Distance = 'DISTANCE',
  EndDate = 'END_DATE',
  Magic = 'MAGIC',
  MostBacked = 'MOST_BACKED',
  MostFunded = 'MOST_FUNDED',
  Newest = 'NEWEST',
  Popularity = 'POPULARITY'
}

/** Various project states. */
export enum ProjectState {
  /** Canceled by creator. */
  Canceled = 'CANCELED',
  /** Failed to fund by deadline. */
  Failed = 'FAILED',
  /** Active and accepting pledges. */
  Live = 'LIVE',
  /** Suspended and hidden. */
  Purged = 'PURGED',
  /** Created and preparing for launch. */
  Started = 'STARTED',
  /** Ready for launch with a draft submitted for auto-approval. */
  Submitted = 'SUBMITTED',
  /** Successfully funded by deadline. */
  Successful = 'SUCCESSFUL',
  /** Suspended for investigation, visible. */
  Suspended = 'SUSPENDED'
}

/** Project status set by user */
export type ProjectStatus = {
  __typename?: 'ProjectStatus';
  /** Whether the project status is currently enabled or not (opted-in / opted-out) */
  enabled: Scalars['Boolean']['output'];
  /** Id of a project status */
  id: Scalars['String']['output'];
  /** The estimated due date for the next_status of the project */
  nextDueDate: Scalars['ISO8601DateTime']['output'];
  /** The next_status of the project */
  nextStatus: Scalars['String']['output'];
  /** The now_status of the project */
  nowStatus: Scalars['String']['output'];
  /** When project status is updated */
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** The connection type for ProjectTimelineEvent. */
export type ProjectTimelineConnection = {
  __typename?: 'ProjectTimelineConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectTimelineEventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectTimelineEvent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An event in a project's timeline */
export type ProjectTimelineEvent = {
  __typename?: 'ProjectTimelineEvent';
  /** Entity attached to the event, e.g. project or post */
  data?: Maybe<TimelineEventData>;
  /** The time the event occurred */
  timestamp: Scalars['DateTime']['output'];
  /** The event type. Corresponds to a subset of activity types */
  type: Scalars['String']['output'];
};

/** An edge in a connection. */
export type ProjectTimelineEventEdge = {
  __typename?: 'ProjectTimelineEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectTimelineEvent>;
};

export enum ProjectUpdateRequestLocation {
  /** Project Update Request from the Backer Bar flow */
  BackerBar = 'backer_bar',
  /** Project Update Request from the inline prompt on a comment */
  Comment = 'comment',
  /** Project Update Request from the prompt at the top of Project Updates */
  Updates = 'updates'
}

/** The connection type for Project. */
export type ProjectsConnectionWithTotalCount = {
  __typename?: 'ProjectsConnectionWithTotalCount';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  recommendationsEnabled: Scalars['Boolean']['output'];
  refTag?: Maybe<Scalars['String']['output']>;
  totalCount: Scalars['Int']['output'];
};

/** A promotional image used in a layout. */
export type Promo = {
  __typename?: 'Promo';
  /** The url for the audio player. */
  audioUrl?: Maybe<Scalars['String']['output']>;
  /** The background color within the promo */
  backgroundColor?: Maybe<Scalars['String']['output']>;
  /** Promo call to action */
  cta?: Maybe<Scalars['String']['output']>;
  /** The details of the promo module */
  description?: Maybe<Scalars['String']['output']>;
  /** When this promo should be featured */
  featuredAt?: Maybe<Scalars['Date']['output']>;
  id: Scalars['ID']['output'];
  /** The url for the background image of the promo module. */
  imageUrl?: Maybe<Scalars['String']['output']>;
  /** The primary language of the promo module. */
  language?: Maybe<Scalars['String']['output']>;
  /** The localized title of this promo module. */
  title?: Maybe<Scalars['String']['output']>;
  /** The label to track this promo module */
  trackingLabel?: Maybe<Scalars['String']['output']>;
  /** The url that is linked to the promo module. */
  url?: Maybe<Scalars['String']['output']>;
};

/** A curated set of promos */
export type PromoCollection = {
  __typename?: 'PromoCollection';
  id: Scalars['ID']['output'];
  /** Layout for this promo collection */
  layout: EditorialPromoCollectionLayout;
  /** Maximum number of items to display */
  maxFeaturedItems: Scalars['Int']['output'];
  /** The promos in this collection */
  promos: Array<Maybe<Promo>>;
  /** True if single item should be displayed full width */
  soloItemFullWidth: Scalars['Boolean']['output'];
  /** Visual theme for this promo collection */
  theme: EditorialPromoCollectionTheme;
  /** Title for this collection. Can be blank. */
  title?: Maybe<Scalars['String']['output']>;
};


/** A curated set of promos */
export type PromoCollectionPromosArgs = {
  all?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Publically visible project states. */
export enum PublicProjectState {
  /** Failed to fund by deadline. */
  Failed = 'FAILED',
  /** Project that is successful and accepting late pledges. */
  LatePledge = 'LATE_PLEDGE',
  /** Active and accepting pledges. */
  Live = 'LIVE',
  /** Project is submitted and in prelaunch state. */
  Submitted = 'SUBMITTED',
  /** Successfully funded by deadline. */
  Successful = 'SUCCESSFUL',
  /** Project that is in prelaunch. */
  Upcoming = 'UPCOMING'
}

/** Autogenerated input type of PublishEditorialLayoutType */
export type PublishEditorialLayoutTypeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Revision for the Editorial Layout */
  revision: Scalars['String']['input'];
  /** Slug for the Editorial Layout */
  slug: Scalars['String']['input'];
};

/** Autogenerated return type of PublishEditorialLayoutType */
export type PublishEditorialLayoutTypePayload = {
  __typename?: 'PublishEditorialLayoutTypePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  layout?: Maybe<Layout>;
};

/** Autogenerated input type of PublishPost */
export type PublishPostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of PublishPost */
export type PublishPostPayload = {
  __typename?: 'PublishPostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  post?: Maybe<Postable>;
};

/** The query root of the Kickstarter GraphQL interface. */
export type Query = {
  __typename?: 'Query';
  /** Fetches all saved searches user in provided origin */
  backerReportSavedSearchSegments?: Maybe<Array<SavedSearchSegment>>;
  /** Fetches a backing given its id. */
  backing?: Maybe<Backing>;
  /** Languages that are eligible for creating captions for video tracks */
  captionLanguages: Array<CaptionLanguage>;
  /** Fetch a project category by param.. */
  category?: Maybe<Category>;
  /** Fetches a checkout given its id. */
  checkout?: Maybe<Checkout>;
  /** Extracts claims from text. */
  claims?: Maybe<Claims>;
  /** The visitor's chosen currency */
  currentCurrency: CurrencyCode;
  /** Default tax categories managed by Kickstarter */
  defaultTaxCategories: Array<TaxCategory>;
  editorial?: Maybe<EditorialConnection>;
  editorialPage?: Maybe<EditorialPage>;
  editorialPageForAdmin?: Maybe<EditorialPageForAdmin>;
  editorialPages?: Maybe<EditorialPageForAdminConnection>;
  editorialRevision?: Maybe<EditorialRevision>;
  editorialRevisionForAdmin?: Maybe<EditorialRevisionForAdmin>;
  /** Fetches a address given its id. */
  fulfillmentAddress?: Maybe<Address>;
  /** Currencies a creator can choose between for collecting pledges on a project */
  fundingCurrencies: Array<FundingCurrency>;
  /** Fetches an item given its relay id. */
  item?: Maybe<RewardItem>;
  /** Get a kickstarter fact */
  ksrFact?: Maybe<KsrFact>;
  /** Searches locations. */
  locations?: Maybe<LocationsConnection>;
  /** You. */
  me?: Maybe<User>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Fetches an order given its id. */
  order: Order;
  photoForEditor?: Maybe<Photo>;
  /** Provides an overview of pledge projects */
  pledgeProjectsOverview?: Maybe<PledgeProjectsOverview>;
  /** Fetches a post given its ID. */
  post?: Maybe<Postable>;
  /** Fetches a project given its slug or pid. */
  project?: Maybe<Project>;
  /** Get some projects */
  projects?: Maybe<ProjectsConnectionWithTotalCount>;
  /** Editorialized quiz projects for the taste profile quiz. */
  quizProjects: QuizProjectsConnection;
  /** Fetches a refund given its id. */
  refund: Refund;
  /** Fetches a refund checkout given its id. */
  refundCheckout?: Maybe<RefundCheckout>;
  /** Regional tax authorities */
  regionalAuthorities: Array<Location>;
  reward?: Maybe<Reward>;
  /** Root project categories. */
  rootCategories: Array<Category>;
  /** Country locations for shipping rewards */
  shippingCountryLocations: Array<Location>;
  /** Regional locations for shipping rewards */
  shippingRegionalLocations: Array<Location>;
  /** Root location for shipping rewards */
  shippingRoot: Location;
  /** Countries that can launch projects. */
  supportedCountries: Array<Country>;
  /** Tags. */
  tags?: Maybe<TagsConnection>;
  /**
   * Fetches a project update given its ID.
   * @deprecated Use post field instead
   */
  update?: Maybe<FreeformPost>;
  /** The maximum file size of an upload by type. */
  uploadLimit: UploadLimit;
  /** How USD currencies should be rendered, based on user's location */
  usdType?: Maybe<UsdType>;
  /** Countries that are visible to the current user. This may include countries that cannot launch projects. */
  visibleCountries: Array<Country>;
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryBackerReportSavedSearchSegmentsArgs = {
  projectId: Scalars['ID']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryBackingArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryCategoryArgs = {
  param: Scalars['String']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryCheckoutArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryClaimsArgs = {
  text: Scalars['String']['input'];
  useStanford?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryEditorialArgs = {
  admin?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  revision?: InputMaybe<Scalars['String']['input']>;
  slug: Scalars['String']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryEditorialPageArgs = {
  slug: Scalars['String']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryEditorialPageForAdminArgs = {
  slug: Scalars['String']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryEditorialPagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  pageType?: InputMaybe<EditorialPageType>;
  search?: InputMaybe<Scalars['String']['input']>;
  sortDirection?: InputMaybe<EditorialPageSortDirection>;
  sortField?: InputMaybe<EditorialPageSortField>;
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryEditorialRevisionArgs = {
  uuid: Scalars['String']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryEditorialRevisionForAdminArgs = {
  uuid: Scalars['String']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryFulfillmentAddressArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryItemArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryLocationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assignable?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  searchable?: InputMaybe<Scalars['Boolean']['input']>;
  term?: InputMaybe<Scalars['String']['input']>;
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryOrderArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryPhotoForEditorArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryPledgeProjectsOverviewArgs = {
  filters?: InputMaybe<PledgeProjectsOverviewFilterInput>;
  sort?: InputMaybe<BackingsDashboardSortOptions>;
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryPostArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryProjectArgs = {
  pid?: InputMaybe<Scalars['Int']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  backed?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  categoryId?: InputMaybe<Scalars['String']['input']>;
  collaborated?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Boolean']['input']>;
  deadlineAfter?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineBefore?: InputMaybe<Scalars['DateTime']['input']>;
  excludePids?: InputMaybe<Array<Scalars['Int']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  goal?: InputMaybe<GoalBuckets>;
  last?: InputMaybe<Scalars['Int']['input']>;
  locationId?: InputMaybe<Scalars['ID']['input']>;
  pledged?: InputMaybe<PledgedBuckets>;
  raised?: InputMaybe<RaisedBuckets>;
  recommendationsModels?: InputMaybe<Array<RecommendationsModel>>;
  recommendationsSource?: InputMaybe<Array<RecommendationsSource>>;
  recommended?: InputMaybe<Scalars['Boolean']['input']>;
  seed?: InputMaybe<Scalars['Int']['input']>;
  similarTo?: InputMaybe<Scalars['String']['input']>;
  similarToPid?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
  staffPicks?: InputMaybe<Scalars['Boolean']['input']>;
  starred?: InputMaybe<Scalars['Boolean']['input']>;
  state?: InputMaybe<PublicProjectState>;
  tagId?: InputMaybe<Scalars['Int']['input']>;
  term?: InputMaybe<Scalars['String']['input']>;
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryQuizProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  excludeQuizProjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryRefundArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryRefundCheckoutArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryRegionalAuthoritiesArgs = {
  country: Scalars['String']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryRewardArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryTagsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  scope: TagScope;
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryUpdateArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of the Kickstarter GraphQL interface. */
export type QueryUploadLimitArgs = {
  filetype: UploadLimitFiletype;
};

/** A question associated with one of the following: Project, RewardItem, Reward */
export type Question = {
  __typename?: 'Question';
  /** The question choice selection limit */
  choiceSelectionLimit?: Maybe<Scalars['Int']['output']>;
  /** The question choices */
  choices?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['ID']['output'];
  /** Whether the question is optional */
  optional: Scalars['Boolean']['output'];
  /** Position of a question */
  position: Scalars['Int']['output'];
  /** The question prompt */
  prompt: Scalars['String']['output'];
  /** The object associated with the question */
  questionable: Questionable;
  /** The question type */
  type: QuestionType;
};

/** Question associated with a particular questionable. */
export type QuestionInput = {
  choiceSelectionLimit?: InputMaybe<Scalars['Int']['input']>;
  choices?: InputMaybe<Array<Scalars['String']['input']>>;
  optional: Scalars['Boolean']['input'];
  prompt: Scalars['String']['input'];
  questionableId: Scalars['String']['input'];
  questionableType: QuestionableType;
  type: QuestionType;
};

/** Question types */
export enum QuestionType {
  Choices = 'choices',
  Text = 'text'
}

/** An object that can be associated with a question */
export type Questionable = Project | Reward | RewardItem;

/** Types that can be associated with a Question */
export enum QuestionableType {
  Project = 'Project',
  Reward = 'Reward',
  RewardItem = 'RewardItem'
}

/** An editorialized quiz project for the taste profile quiz. */
export type QuizProject = {
  __typename?: 'QuizProject';
  /** The editorialized version of the project blurb */
  editorializedBlurb: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** All the likeable attributes for a quiz project */
  likeableAttributes: Array<LikeableAttribute>;
};

/** An edge in a connection. */
export type QuizProjectEdge = {
  __typename?: 'QuizProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<QuizProject>;
};

/** The connection type for QuizProject. */
export type QuizProjectsConnection = {
  __typename?: 'QuizProjectsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<QuizProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<QuizProject>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** Buckets of percentage raised */
export enum RaisedBuckets {
  /** Range from 0 to 75 percent */
  Bucket_0 = 'BUCKET_0',
  /** Range from 75 to 100 percent */
  Bucket_1 = 'BUCKET_1',
  /** Range from 100 to Infinity percent */
  Bucket_2 = 'BUCKET_2'
}

/** Score and model from recommendations engine if a project was fetched via recommendations. */
export type Recommendations = {
  __typename?: 'Recommendations';
  /** Model used for these recommendations. */
  modelName?: Maybe<Scalars['String']['output']>;
  /** Raw score from recommendations. */
  rawScore?: Maybe<Scalars['Float']['output']>;
  /** Recommendations score. */
  score?: Maybe<Scalars['Float']['output']>;
};

/** What model to use for project recommendations */
export enum RecommendationsModel {
  Cf = 'CF',
  Lda = 'LDA',
  Lsi = 'LSI'
}

/** What source to use for project recommendations */
export enum RecommendationsSource {
  Backings = 'BACKINGS',
  Project = 'PROJECT',
  TasteProfileDislikes = 'TASTE_PROFILE_DISLIKES',
  TasteProfileLikes = 'TASTE_PROFILE_LIKES',
  Watches = 'WATCHES'
}

/** Autogenerated input type of RefreshSpreadsheetData */
export type RefreshSpreadsheetDataInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RefreshSpreadsheetData */
export type RefreshSpreadsheetDataPayload = {
  __typename?: 'RefreshSpreadsheetDataPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  spreadsheet?: Maybe<Spreadsheet>;
};

/** A refund. */
export type Refund = Node & {
  __typename?: 'Refund';
  /** The associated backing */
  backing: Backing;
  /** The adjustment for the backings reward, addons, and/or bonus amount */
  backingAdjustmentData?: Maybe<RefundAdjustmentData>;
  /** The refund checkout associated with the backing adjustment */
  backingAdjustmentRefundCheckout?: Maybe<RefundCheckout>;
  /** Timestamp at which refund was created */
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** message from the creator associated with this refund */
  message?: Maybe<Scalars['String']['output']>;
  /** The adjustment for the order's addons, shipping taxes, sales taxes, and pledge upgrade */
  orderAdjustmentData?: Maybe<RefundAdjustmentData>;
  /** reason for the refund */
  reason: RefundReasonType;
  /** The refund details path */
  refundDetailsPath: Scalars['String']['output'];
  /** The total refunded from this refund attempt, formatted */
  totalFormatted: Scalars['String']['output'];
};

/** The refund adjustment data for a backing or an order. */
export type RefundAdjustmentData = {
  __typename?: 'RefundAdjustmentData';
  /** The adjustment details for the addons */
  addons: Array<AdjustedReward>;
  /** The adjustment details for the bonus support */
  bonusSupport?: Maybe<Scalars['String']['output']>;
  /** The adjustment details for the reward */
  reward?: Maybe<AdjustedReward>;
  /** The adjustment details for the upgraded reward */
  rewardUpgrade?: Maybe<AdjustedReward>;
  /** Whether the reward was upgraded */
  rewardUpgraded?: Maybe<Scalars['Boolean']['output']>;
  /** The adjustment details for the shipping and shipping tax */
  shipping?: Maybe<Scalars['String']['output']>;
  /** The reason for the adjustment state */
  stateReason?: Maybe<Scalars['String']['output']>;
  /** Whether the adjustment was successfully refunded */
  success: Scalars['Boolean']['output'];
  /** The adjustment details for the sales tax */
  tax?: Maybe<Scalars['String']['output']>;
  /** The adjustment total */
  total: Scalars['String']['output'];
};

/** All types of refund adjustments that can be issued */
export enum RefundAdjustmentType {
  /** refund for bonus support */
  BonusAmount = 'BONUS_AMOUNT',
  /** general refund */
  GeneralRefund = 'GENERAL_REFUND',
  /** refund for an add-on or cross-sell in the order */
  OrderItem = 'ORDER_ITEM',
  /** refund for full reward tier */
  Reward = 'REWARD',
  /** refund for individual item in a reward tier */
  RewardItem = 'REWARD_ITEM',
  /** refund for shipping fees */
  ShippingCredit = 'SHIPPING_CREDIT'
}

/** Intermediary set of changes that have yet to be applied to a backing */
export type RefundCheckout = {
  __typename?: 'RefundCheckout';
  /** The total amount of the refund */
  amount: Money;
  /** The backing associated with the refund */
  backing?: Maybe<Backing>;
  /** If `requires_action` is true, `client_secret` should be used to initiate additional client-side authentication steps */
  clientSecret?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Whether this refund checkout requires additional client-side authentication steps (e.g. 3DS2) */
  requiresAction: Scalars['Boolean']['output'];
  /** The state of the redund checkout */
  state: RefundCheckoutState;
  /** Reason given when state is in a failed state */
  stateReason?: Maybe<Scalars['String']['output']>;
  /** The full URL to redirect to after payment setup via Stripe in refunds */
  stripePaymentSetupRedirectUrl: Scalars['String']['output'];
};

/** All available states for a refund checkout */
export enum RefundCheckoutState {
  Authorizing = 'AUTHORIZING',
  Errored = 'ERRORED',
  Failed = 'FAILED',
  Successful = 'SUCCESSFUL'
}

/** An amount to be refunded as part of an adjustment. */
export type RefundInput = {
  /** amount to be refunded */
  amount: Scalars['Int']['input'];
  /** id of object to be refunded */
  refundItemId?: InputMaybe<Scalars['ID']['input']>;
  /** type of refund */
  type: RefundAdjustmentType;
};

/** Parameters to refund the non-voucher part of an order. */
export type RefundOrderInput = {
  /** Cross sells to be refunded / removed */
  crossSells: Array<OrderOrderableInput>;
  /** Shipments to be refunded */
  shipments: Array<ShipmentInput>;
  /** Upgraded reward to be refunded / removed */
  upgradedReward?: InputMaybe<OrderOrderableInput>;
};

/** Required parameters in order to refund a pledge. */
export type RefundPledgeInput = {
  adjustmentParams: AdjustmentInput;
  amount?: InputMaybe<Scalars['Int']['input']>;
};

/** Reasons for refunds */
export enum RefundReasonType {
  /** Backer requested refund */
  BackerRequest = 'BACKER_REQUEST',
  /** Change of reward or removal of reward item */
  ChangeRemoval = 'CHANGE_REMOVAL',
  /** Creator issued credit */
  Credit = 'CREDIT',
  /** Issues with or delays in fulfillment */
  FulfillmentIssuesDelays = 'FULFILLMENT_ISSUES_DELAYS',
  /** Other reason for refund */
  Other = 'OTHER',
  /** Backer overpaid for reward */
  Overpayment = 'OVERPAYMENT'
}

/** A region inside a country. */
export type Region = {
  __typename?: 'Region';
  /** Region code. */
  code: Scalars['String']['output'];
  /** Region name. */
  name: Scalars['String']['output'];
};

/** An object removed as part of an adjustment */
export type RemovalInput = {
  /** id of object to be removed */
  refundItemId: Scalars['ID']['input'];
  /** id of the reward associated with the removal */
  rewardId: Scalars['Int']['input'];
  /** type of object to be removed (reward, reward item, or order item) */
  type: RefundAdjustmentType;
};

/** Autogenerated input type of RemoveSheetFromProject */
export type RemoveSheetFromProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveSheetFromProject */
export type RemoveSheetFromProjectPayload = {
  __typename?: 'RemoveSheetFromProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  sheetsUrl?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ReportSpam */
export type ReportSpamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  messageId: Scalars['ID']['input'];
};

/** Autogenerated return type of ReportSpam */
export type ReportSpamPayload = {
  __typename?: 'ReportSpamPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  spam: Scalars['Boolean']['output'];
};

/** Autogenerated input type of RequestPasswordReset */
export type RequestPasswordResetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['Email']['input']>;
};

/** Autogenerated return type of RequestPasswordReset */
export type RequestPasswordResetPayload = {
  __typename?: 'RequestPasswordResetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['Email']['output']>;
};

/** Autogenerated input type of ResetBackerSurvey */
export type ResetBackerSurveyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ResetBackerSurvey */
export type ResetBackerSurveyPayload = {
  __typename?: 'ResetBackerSurveyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Succeeds if backer survey responses are reset. */
  success: Scalars['Boolean']['output'];
};

/** Data related to the audience for a particular resource */
export type ResourceAudience = {
  __typename?: 'ResourceAudience';
  audience: AudienceEnum;
  /** True if the resource has access restricted by an access rule */
  secret: Scalars['Boolean']['output'];
  /** Url for sharing reward (absent if accessible to all) */
  shareUrl?: Maybe<Scalars['String']['output']>;
  token?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ReviewPledgeManager */
export type ReviewPledgeManagerInput = {
  approved: Scalars['Boolean']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  pledgeManagerId: Scalars['ID']['input'];
  reviewNote?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ReviewPledgeManager */
export type ReviewPledgeManagerPayload = {
  __typename?: 'ReviewPledgeManagerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** A project reward. */
export type Reward = Node & {
  __typename?: 'Reward';
  /**
   * Add-ons which can be combined with this reward.
   * Uses creator preferences and shipping rules to determine allow-ability.
   * Inclusion in this list does not necessarily indicate that the add-on is available for backing.
   *
   */
  allowedAddons: RewardConnection;
  /**
   * Base rewards which can be combined with this addon.
   * Uses creator preferences and shipping rules to determine allow-ability.
   * Inclusion in this list does not necessarily indicate that the reward is available for backing.
   *
   */
  allowedRewards: RewardConnection;
  /** Amount for claiming this reward. */
  amount: Money;
  /** Data related to who can view/access this reward */
  audienceData: ResourceAudience;
  /** Whether or not the reward is available for new pledges */
  available: Scalars['Boolean']['output'];
  /** Profile images for backers of this reward */
  backerImages?: Maybe<Array<Photo>>;
  /** URL for the Backer Report filtered to only this reward */
  backerReportUrl: Scalars['String']['output'];
  /** count of backers for this reward */
  backersCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Amount for claiming this reward, in the current user's chosen
   *                                                      currency
   */
  convertedAmount: Money;
  /** A reward description. */
  description: Scalars['String']['output'];
  /**
   * A reward's title plus the amount, or a default title (the reward amount) if it doesn't
   *                                  have a title.
   */
  displayName: Scalars['String']['output'];
  /**
   * The same as allowed_addons but with an additional scope that filters out addons with a start date that falls in the future
   *
   */
  displayableAddons: RewardConnection;
  /**
   * For post-campaign enabled rewards, the conditions under which to
   *                                    stop offering the reward.
   */
  endCondition?: Maybe<Scalars['Int']['output']>;
  /** When the reward is scheduled to end in seconds */
  endsAt?: Maybe<Scalars['DateTime']['output']>;
  /** Estimated delivery day. */
  estimatedDeliveryOn?: Maybe<Scalars['Date']['output']>;
  /** Whether or not the reward is featured */
  featured: Scalars['Boolean']['output'];
  /** Whether any has pledged for this reward during the late pledges period */
  hasLatePledgeBackers?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  /** The reward image. */
  image?: Maybe<Photo>;
  /** Is this reward currently accepting post-campaign pledges? */
  inPostCampaignPledgingPhase: Scalars['Boolean']['output'];
  /** Does reward amount meet or exceed maximum pledge for the project */
  isMaxPledge: Scalars['Boolean']['output'];
  /** Items in the reward. */
  items?: Maybe<RewardItemsConnection>;
  /** Amount for claiming this reward after the campaign. */
  latePledgeAmount: Money;
  /** A reward limit. */
  limit?: Maybe<Scalars['Int']['output']>;
  /** Per backer reward limit. */
  limitPerBacker?: Maybe<Scalars['Int']['output']>;
  /**
   * Where the reward can be locally received if local receipt
   *                                                              is selected as the shipping preference
   */
  localReceiptLocation?: Maybe<Location>;
  /**
   * The maximum amount of this add-on in a single pledge selected by any
   *                                                    pledged backer.
   */
  maxPledgedInSingleBacking: Scalars['Int']['output'];
  /** A reward title. */
  name?: Maybe<Scalars['String']['output']>;
  /** Cross-Sells configuration for this Reward */
  orderableConfig?: Maybe<OrderableConfig>;
  /** What state is orderable configuration in for this reward (complete, incomplete, or not_started)? */
  orderableConfigCompletion: PrereqCompletionStatus;
  /** Amount for claiming this reward during the campaign. */
  pledgeAmount: Money;
  /** Should this reward only be shown in Pledgement Management? */
  pledgeManagementOnly: Scalars['Boolean']['output'];
  /** Is this reward available for post-campaign pledges? */
  postCampaignPledgingEnabled: Scalars['Boolean']['output'];
  /** The project */
  project?: Maybe<Project>;
  /** Survey questions asked of all backers of this reward. */
  questions: Array<Question>;
  /** Remaining reward quantity. */
  remainingQuantity?: Maybe<Scalars['Int']['output']>;
  /** The type of the reward - base or addon. */
  rewardType: RewardType;
  /** Whether or not the reward has shipping enabled */
  shippingEnabled: Scalars['Boolean']['output'];
  /** Shipping preference for this reward */
  shippingPreference?: Maybe<ShippingPreference>;
  /** Shipping rates defined by the creator for this reward */
  shippingRates: Array<ShippingRate>;
  /**
   * Whether the shipping rates are filled out and
   *                                                                          not missing fields
   */
  shippingRatesCompletion: PrereqCompletionStatus;
  /**
   * Shipping rates for all shippable countries,
   *                                                                     including those that are children of superregions
   */
  shippingRatesExpanded: Array<ShippingRate>;
  /**
   * Shipping rules defined by the creator for
   *                                                                            this reward
   */
  shippingRules: Array<Maybe<ShippingRule>>;
  /** Shipping rules for all shippable countries. */
  shippingRulesExpanded?: Maybe<RewardShippingRulesConnection>;
  /** A shipping summary */
  shippingSummary?: Maybe<Scalars['String']['output']>;
  /** Reward shipping summary as a sentence */
  shippingSummarySentence?: Maybe<Scalars['String']['output']>;
  /**
   * Simple shipping rules
   *                                                                                                  expanded as a faster alternative to
   *                                                                                                  shippingRulesExpanded since connection
   *                                                                                                  type is slow
   */
  simpleShippingRulesExpanded: Array<Maybe<SimpleShippingRule>>;
  /** Whether or not the reward is out of inventory */
  soldOut: Scalars['Boolean']['output'];
  /**
   * For post-campaign enabled rewards, the conditions under which to
   *                                      start offering the reward.
   */
  startCondition?: Maybe<Scalars['Int']['output']>;
  /** When the reward is scheduled to start */
  startsAt?: Maybe<Scalars['DateTime']['output']>;
};


/** A project reward. */
export type RewardAllowedAddonsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A project reward. */
export type RewardAllowedRewardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A project reward. */
export type RewardBackerImagesArgs = {
  limit: Scalars['Int']['input'];
};


/** A project reward. */
export type RewardBackersCountArgs = {
  excludeInactive?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A project reward. */
export type RewardDisplayableAddonsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A project reward. */
export type RewardItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A project reward. */
export type RewardLimitPerBackerArgs = {
  withFallback?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A project reward. */
export type RewardShippingRulesExpandedArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  forLocation?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Reward. */
export type RewardConnection = {
  __typename?: 'RewardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RewardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Reward>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RewardEdge = {
  __typename?: 'RewardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Reward>;
};

/** A reward item. */
export type RewardItem = Node & {
  __typename?: 'RewardItem';
  /** The add-ons that the item is included in. */
  addOns: Array<Reward>;
  /** The numer of add-ons that the item is included in. */
  addOnsCount: Scalars['Int']['output'];
  /** Whether backers have backed rewards this item belongs to */
  hasBackers: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** The item image */
  image?: Maybe<Photo>;
  /** Variants of this item */
  itemVariants: Array<ItemVariant>;
  /** Item weight related configuration */
  itemWeight?: Maybe<ItemWeight>;
  /** The max amount of this item that may have to be produced based on reward limits. */
  maxInventoryCount?: Maybe<Scalars['Int']['output']>;
  /** An item name. */
  name: Scalars['String']['output'];
  /** Option types tied to this item */
  optionTypes: Array<OptionType>;
  /** The project */
  project?: Maybe<Project>;
  /** Questions tied to this item that will be posed to backers */
  questions: Array<Question>;
  /** The rewards that the item is included in. */
  rewards: Array<Reward>;
  /** The number of rewards that the item is included in. */
  rewardsCount: Scalars['Int']['output'];
  /** Surcharge rules configured for this item */
  surchargeRules: Array<SurchargeRule>;
  /** Tax related configuration */
  taxConfig?: Maybe<ItemTaxConfig>;
  /** Whether the item is completely configured for tax purposes */
  taxConfigCompletionStatus: PrereqCompletionStatus;
};

/** An edge in a connection. */
export type RewardItemEdge = {
  __typename?: 'RewardItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RewardItem>;
  /** The position that an item has been ordered on a reward */
  position?: Maybe<Scalars['Int']['output']>;
  /** The quantity of an item associated with a reward */
  quantity: Scalars['Int']['output'];
};

/** Item for a reward */
export type RewardItemInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  position: Scalars['Int']['input'];
  quantity: Scalars['Int']['input'];
};

/** The connection type for RewardItem. */
export type RewardItemsConnection = {
  __typename?: 'RewardItemsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RewardItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RewardItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** The connection type for ShippingRule. */
export type RewardShippingRulesConnection = {
  __typename?: 'RewardShippingRulesConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ShippingRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ShippingRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** The connection type for Reward. */
export type RewardTotalCountConnection = {
  __typename?: 'RewardTotalCountConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RewardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Reward>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** Describes the purpose of the reward */
export enum RewardType {
  /** A reward that can only be added to a backing for another reward */
  Addon = 'addon',
  /** A reward that cannot be combined with others */
  Base = 'base'
}

/** Itemized rich text */
export type RichText = {
  __typename?: 'RichText';
  items: Array<Maybe<RichTextItem>>;
};

/** An Audio asset */
export type RichTextAudio = {
  __typename?: 'RichTextAudio';
  altText: Scalars['String']['output'];
  asset?: Maybe<AttachedAudio>;
  caption: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

/** A Header 1. <h1> */
export type RichTextHeader1 = {
  __typename?: 'RichTextHeader1';
  html: Scalars['String']['output'];
};

/** A Header 2. <h2> */
export type RichTextHeader2 = {
  __typename?: 'RichTextHeader2';
  html: Scalars['String']['output'];
};

/** A Header 3. <h3> */
export type RichTextHeader3 = {
  __typename?: 'RichTextHeader3';
  html: Scalars['String']['output'];
};

/** A Header 4. <h4> */
export type RichTextHeader4 = {
  __typename?: 'RichTextHeader4';
  html: Scalars['String']['output'];
};

/** Rich text items: Paragraph, Headers, List, Quote, Photo, Audio, Video or Oembed */
export type RichTextItem = RichTextAudio | RichTextHeader1 | RichTextHeader2 | RichTextHeader3 | RichTextHeader4 | RichTextList | RichTextOembed | RichTextParagraph | RichTextPhoto | RichTextQuote | RichTextVideo;

/** A list. <ul> */
export type RichTextList = {
  __typename?: 'RichTextList';
  items: Array<RichTextListItem>;
};

/** A list item. <li> */
export type RichTextListItem = {
  __typename?: 'RichTextListItem';
  html: Scalars['String']['output'];
};

/** An Oembed item */
export type RichTextOembed = {
  __typename?: 'RichTextOembed';
  /** ex: Bryson Lovett */
  authorName: Scalars['String']['output'];
  /** ex: https://www.youtube.com/user/brysonlovett */
  authorUrl: Scalars['String']['output'];
  /** ex: 270 */
  height: Scalars['Int']['output'];
  /** ex: <iframe width="560" height="315" src="https://www.youtube.com/embed/ijeaVn8znJ8?feature=oembed" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe> */
  html: Scalars['String']['output'];
  /** ex: https://www.youtube.com/embed/ijeaVn8znJ8?feature=oembed */
  iframeUrl: Scalars['String']['output'];
  /** ex: https://youtu.be/ijeaVn8znJ8 */
  originalUrl: Scalars['String']['output'];
  /** only for photo */
  photoUrl: Scalars['String']['output'];
  /** Ex: Embedly, Flickr, Kickstarter, Kickstarter Live, Scribd, SoundCloud, Spotify, Sketchfab, Twitter, Vimeo, YouTube */
  providerName: Scalars['String']['output'];
  /** ex: https://www.youtube.com/ */
  providerUrl: Scalars['String']['output'];
  /** ex: 360 */
  thumbnailHeight: Scalars['Int']['output'];
  /** ex: https://i.ytimg.com/vi/ijeaVn8znJ8/hqdefault.jpg */
  thumbnailUrl: Scalars['String']['output'];
  /** ex: 480 */
  thumbnailWidth: Scalars['Int']['output'];
  /** ex: Bird Photo Booth bird feeder kickstarter preview 2 */
  title: Scalars['String']['output'];
  /** one of: photo, video, link, rich */
  type: Scalars['String']['output'];
  /** always "1.0" */
  version: Scalars['String']['output'];
  /** ex: 480 */
  width: Scalars['Int']['output'];
};

/** A Paragraph. <p> */
export type RichTextParagraph = {
  __typename?: 'RichTextParagraph';
  html: Scalars['String']['output'];
};

/** A Photo asset */
export type RichTextPhoto = {
  __typename?: 'RichTextPhoto';
  altText: Scalars['String']['output'];
  asset?: Maybe<Photo>;
  caption: Scalars['String']['output'];
  url: Scalars['String']['output'];
};


/** A Photo asset */
export type RichTextPhotoUrlArgs = {
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** A quote. <blockquote> */
export type RichTextQuote = {
  __typename?: 'RichTextQuote';
  html: Scalars['String']['output'];
};

/** A Video asset */
export type RichTextVideo = {
  __typename?: 'RichTextVideo';
  altText: Scalars['String']['output'];
  asset?: Maybe<AttachedVideo>;
  caption: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

/** Describes the expected input type for a risk category. */
export enum RiskCategoryInput {
  Radio = 'radio',
  Text = 'text'
}

export enum RiskCategoryType {
  AlternativeFulfillmentPath = 'alternative_fulfillment_path',
  Delays = 'delays',
  FulfillmentPlan = 'fulfillment_plan',
  PreviousExperience = 'previous_experience',
  ProjectBudgetContingency = 'project_budget_contingency',
  UnexpectedPledgeVolume = 'unexpected_pledge_volume'
}

/** A category of risk. Each category corresponds to a question in the project Plan. */
export type RiskQuestion = {
  __typename?: 'RiskQuestion';
  /** The input type of the risk category. */
  inputType: RiskCategoryInput;
  /** The question associated with the risk category. */
  question: Scalars['String']['output'];
  /** Whether or not this is a required category. */
  required: Scalars['Boolean']['output'];
  /** The category identifier. */
  type: RiskCategoryType;
};

export type RiskStrategy = {
  __typename?: 'RiskStrategy';
  /** Creator's answer for mitigating this particular risk category. */
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** The type of risk */
  riskCategory: RiskCategoryType;
  /** The question the creator is answering. */
  riskQuestion: RiskQuestion;
};

/** Inputs required to create a risk strategy for a project. */
export type RiskStrategyInput = {
  description: Scalars['String']['input'];
  riskCategory: RiskCategoryType;
};

export enum Route {
  /** Just the path (does not include the domain) */
  Path = 'path',
  /** The entire URL (include the domain) */
  Url = 'url'
}

/** S3 information for an asset. */
export type S3AssetInput = {
  contentType: Scalars['String']['input'];
  fileName: Scalars['String']['input'];
  fileSize: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  s3Key: Scalars['String']['input'];
  updatedAt: Scalars['Int']['input'];
};

/** Saved search segment. */
export type SavedSearchSegment = Node & {
  __typename?: 'SavedSearchSegment';
  /** ID of the saved search segment */
  id: Scalars['ID']['output'];
  /** Body of the saved search segment */
  segmentBody: Scalars['JSON']['output'];
  /** Name of the saved search segment */
  segmentName: Scalars['String']['output'];
  /** Origin of the saved search segment */
  segmentOrigin: Scalars['String']['output'];
};

/** Types that can have access rules to make them secret */
export type SecretResource = Reward;

/** Cross Sell selection to add to an Order */
export type SelectedCrossSellInput = {
  id: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
};

/** Autogenerated input type of SendMessage */
export type SendMessageInput = {
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  gRecaptchaResponse: Scalars['String']['input'];
  projectId: Scalars['ID']['input'];
  recipientId: Scalars['ID']['input'];
};

/** Autogenerated return type of SendMessage */
export type SendMessagePayload = {
  __typename?: 'SendMessagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  conversation?: Maybe<Conversation>;
  message?: Maybe<Message>;
};

/** Autogenerated input type of SendSubmissionMessage */
export type SendSubmissionMessageInput = {
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of SendSubmissionMessage */
export type SendSubmissionMessagePayload = {
  __typename?: 'SendSubmissionMessagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Message>;
};

/** Autogenerated input type of SendSurvey */
export type SendSurveyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  surveyId: Scalars['ID']['input'];
};

/** Autogenerated return type of SendSurvey */
export type SendSurveyPayload = {
  __typename?: 'SendSurveyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated survey. */
  survey: BackerSurvey;
};

/** Autogenerated input type of SetAddressAsPrimary */
export type SetAddressAsPrimaryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  fulfillmentAddressId: Scalars['ID']['input'];
};

/** Autogenerated return type of SetAddressAsPrimary */
export type SetAddressAsPrimaryPayload = {
  __typename?: 'SetAddressAsPrimaryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Success if address was updated successfully */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of SetAddressCollectionEnabled */
export type SetAddressCollectionEnabledInput = {
  addressCollectionEnabled: Scalars['Boolean']['input'];
  addressCollectionForDigitalReward: Scalars['Boolean']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of SetAddressCollectionEnabled */
export type SetAddressCollectionEnabledPayload = {
  __typename?: 'SetAddressCollectionEnabledPayload';
  /** Whether or not the creator has enabled address collection for this project. */
  addressCollectionEnabled: Scalars['Boolean']['output'];
  /** Whether or not addresses should be collected for digital reward backers. */
  addressCollectionForDigitalReward: Scalars['Boolean']['output'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of SetBackingFulfillmentStatuses */
export type SetBackingFulfillmentStatusesInput = {
  actionsTaken?: InputMaybe<Array<Scalars['String']['input']>>;
  addons?: InputMaybe<Array<Scalars['ID']['input']>>;
  amountMax?: InputMaybe<Scalars['Int']['input']>;
  amountMin?: InputMaybe<Scalars['Int']['input']>;
  backingIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  fulfillmentStatus?: InputMaybe<Array<Scalars['String']['input']>>;
  isLatePledge?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  items?: InputMaybe<Array<Scalars['ID']['input']>>;
  locations?: InputMaybe<Array<Scalars['ID']['input']>>;
  newFulfillmentStatus: FulfillmentStatusSelectOptions;
  pledgeRedemptionState?: InputMaybe<Array<Scalars['String']['input']>>;
  pledgedAtMax?: InputMaybe<Scalars['String']['input']>;
  pledgedAtMin?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
  rewards?: InputMaybe<Array<Scalars['ID']['input']>>;
  selectAll?: InputMaybe<Scalars['Boolean']['input']>;
  skus?: InputMaybe<Array<Scalars['ID']['input']>>;
  sqlFilterAddons?: InputMaybe<SqlFilterOperator>;
  sqlFilterItems?: InputMaybe<SqlFilterOperator>;
  sqlFilterSkus?: InputMaybe<SqlFilterOperator>;
  status?: InputMaybe<Array<Scalars['String']['input']>>;
  surveyAnswered?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  term?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Autogenerated return type of SetBackingFulfillmentStatuses */
export type SetBackingFulfillmentStatusesPayload = {
  __typename?: 'SetBackingFulfillmentStatusesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  updatedBackingCount?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of SetBackingNote */
export type SetBackingNoteInput = {
  backingId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  noteBody?: InputMaybe<Scalars['String']['input']>;
  noteType: BackingNoteType;
};

/** Autogenerated return type of SetBackingNote */
export type SetBackingNotePayload = {
  __typename?: 'SetBackingNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  noteBody?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of SetProjectSlug */
export type SetProjectSlugInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of SetProjectSlug */
export type SetProjectSlugPayload = {
  __typename?: 'SetProjectSlugPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of SetProjectStatus */
export type SetProjectStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  nextDueDate: Scalars['ISO8601DateTime']['input'];
  nextStatus?: InputMaybe<Scalars['String']['input']>;
  nowStatus?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of SetProjectStatus */
export type SetProjectStatusPayload = {
  __typename?: 'SetProjectStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  projectStatus?: Maybe<ProjectStatus>;
};

/** Autogenerated input type of SetShippingConfig */
export type SetShippingConfigInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
  shippingType: ShippingTypeEnum;
  shippingUnit?: InputMaybe<ShippingUnitEnum>;
};

/** Autogenerated return type of SetShippingConfig */
export type SetShippingConfigPayload = {
  __typename?: 'SetShippingConfigPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Updated project */
  project: Project;
};

/** Autogenerated input type of SetTaxCategory */
export type SetTaxCategoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The item id */
  itemId: Scalars['ID']['input'];
  /** The tax category id */
  taxCategoryId?: InputMaybe<Scalars['ID']['input']>;
  /** Input for creating or updating a tax category */
  taxCategoryInput?: InputMaybe<TaxCategoryInput>;
};

/** Autogenerated return type of SetTaxCategory */
export type SetTaxCategoryPayload = {
  __typename?: 'SetTaxCategoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated item tax config */
  itemTaxConfig: ItemTaxConfig;
};

/** Selected fields on a SetupIntent from Stripe for a given backing. */
export type SetupIntent = {
  __typename?: 'SetupIntent';
  /** Stripe ID of the SetupIntent. */
  id: Scalars['String']['output'];
  /** The error encountered in the previous SetupIntent confirmation. */
  lastSetupError?: Maybe<SetupIntentError>;
  /** Status of the SetupIntent. */
  status: SetupIntentStatus;
};

export type SetupIntentError = {
  __typename?: 'SetupIntentError';
  /** For some errors that could be handled programmatically, a short string indicating the error code reported. https://stripe.com/docs/error-codes */
  code: Scalars['String']['output'];
  /** A short string indicating the card issuer’s reason for the decline if they provide one. */
  declineCode: Scalars['String']['output'];
  /** A human-readable message providing more details about the error. For card errors, these messages can be shown to your users. */
  message: Scalars['String']['output'];
  /** The type of error returned. */
  type: SetupIntentErrorType;
};

export enum SetupIntentErrorType {
  /** Failure to connect to Stripe's API. */
  ApiConnectionError = 'API_CONNECTION_ERROR',
  /** API errors cover any other type of problem (e.g., a temporary problem with Stripe's servers), and are extremely uncommon. */
  ApiError = 'API_ERROR',
  /** Failure to properly authenticate in the request. */
  AuthenticationError = 'AUTHENTICATION_ERROR',
  /** Card errors are very common and they result when the user enters a card that can't be charged for some reason. */
  CardError = 'CARD_ERROR',
  /** Idempotency errors occur when an Idempotency-Key is re-used on a request that does not match the first request's API endpoint and parameters. */
  IdempotencyError = 'IDEMPOTENCY_ERROR',
  /** Invalid request errors arise when your request has invalid parameters eg., 3DS authentication failed. */
  InvalidRequestError = 'INVALID_REQUEST_ERROR',
  /** Too many requests hit the Stripe API too quickly. */
  RateLimitError = 'RATE_LIMIT_ERROR',
  /** Errors triggered by Stripe's client-side libraries when failing to validate fields (e.g., when a card number or expiration date is invalid or incomplete). */
  ValidationError = 'VALIDATION_ERROR'
}

export enum SetupIntentStatus {
  /** SetupIntent can be canceled at any point before it is processing or succeeded. */
  Canceled = 'CANCELED',
  /** Once required actions are handled, the SetupIntent moves to this status, which can be brief or take a few days depending on the payment method. */
  Processing = 'PROCESSING',
  /** If the setup requires additional actions, such as authenticating with 3D Secure */
  RequiresAction = 'REQUIRES_ACTION',
  /** After the customer provides their payment method information, the SetupIntent is ready to be confirmed. */
  RequiresConfirmation = 'REQUIRES_CONFIRMATION',
  /** When the SetupIntent is created, it has this status until a payment method is attached. If a SetupIntent fails, it will revert to this status. */
  RequiresPaymentMethod = 'REQUIRES_PAYMENT_METHOD',
  /** Setup of payment source was successful. */
  Succeeded = 'SUCCEEDED'
}

/** A shipment included in an Order. */
export type Shipment = {
  __typename?: 'Shipment';
  /** The amount charged for shipping this shipment. */
  amount: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  /** The tracking number for this shipment. */
  trackingNumber?: Maybe<Scalars['String']['output']>;
};

/** Parameters to refund a shipment. */
export type ShipmentInput = {
  /** Amount to refund */
  amount: Scalars['Int']['input'];
  /** ID of the shipment */
  shipmentId: Scalars['Int']['input'];
};

/** Types that can have shipping rates */
export type Shippable = Reward | RewardItem;

/** A project's shipping configuration */
export type ShippingConfig = {
  __typename?: 'ShippingConfig';
  id: Scalars['ID']['output'];
  itemWeightCompletionStats: ItemWeightCompletionStats;
  /** How are shipping rates configured? Either flat rate or weight based */
  shippingType: ShippingTypeEnum;
  /** If shipping is weight based, a unit must be provided, e.g. oz or kg */
  unit?: Maybe<ShippingUnitEnum>;
};

/** A preference for shipping a reward */
export enum ShippingPreference {
  Local = 'local',
  None = 'none',
  Restricted = 'restricted',
  Unrestricted = 'unrestricted'
}

/** A shipping rate for a particular shippable and location */
export type ShippingRate = {
  __typename?: 'ShippingRate';
  /** The shipping cost for this location. */
  cost: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  /** The shipping location for which this shipping rate is defined. */
  location: Location;
  /** The item or reward for which this shipping rate is defined. */
  shippable: Shippable;
};

/** Shipping rule for a reward */
export type ShippingRateInput = {
  cost?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  locationId: Scalars['String']['input'];
};

/** A project reward's shipping rule. */
export type ShippingRule = Node & {
  __typename?: 'ShippingRule';
  /** Number of backers for the Shipping Rule */
  backersCount: Scalars['Int']['output'];
  /** The shipping cost for this location. */
  cost?: Maybe<Money>;
  /** The estimated maximum shipping cost */
  estimatedMax?: Maybe<Money>;
  /** The estimated minimum shipping cost */
  estimatedMin?: Maybe<Money>;
  /** Shipping rule has backers */
  hasBackers: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** The shipping location to which the rule pertains. */
  location: Location;
};

/** An edge in a connection. */
export type ShippingRuleEdge = {
  __typename?: 'ShippingRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ShippingRule>;
};

/** Shipping rule for a reward */
export type ShippingRuleInput = {
  cost: Scalars['Int']['input'];
  estimatedMax?: InputMaybe<Scalars['Int']['input']>;
  estimatedMin?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  locationId: Scalars['String']['input'];
};

/** The type of shipping set up, either flat rate or weight based */
export enum ShippingTypeEnum {
  /** flat_rate */
  FlatRate = 'flat_rate',
  /** weight_based */
  WeightBased = 'weight_based'
}

/** The units that weights will be in, for weight based shipping type */
export enum ShippingUnitEnum {
  /** kg */
  Kg = 'kg',
  /** oz */
  Oz = 'oz'
}

/** A shipping zone configured for a project */
export type ShippingZone = {
  __typename?: 'ShippingZone';
  id: Scalars['ID']['output'];
  /** Whether it has rest of the world location */
  isRoot: Scalars['Boolean']['output'];
  /** The locations included in the zone. */
  locations: Array<Location>;
  /** Optional name for the shipping zone */
  name?: Maybe<Scalars['String']['output']>;
  /** The project the shipping zone belongs */
  project: Project;
  /** Weight ranges with cost, relevant to the zone. */
  weightRanges: Array<WeightRange>;
};

/** An Short Text block for Editorial pages */
export type ShortText = {
  __typename?: 'ShortText';
  /** Hex value of the background color. */
  backgroundColor: Scalars['String']['output'];
  /** The plain text body of the Short Text. May contain line breaks. */
  body: Scalars['String']['output'];
  /** The text of the CTA. Can be an empty string. */
  ctaText: Scalars['String']['output'];
  /** The url the CTA points to. Can be an empty string. */
  ctaUrl: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Hex value of the rule color. */
  ruleColor: Scalars['String']['output'];
  /** The subtitle of the Short Text. Can be an empty string. */
  subtitle: Scalars['String']['output'];
  /** The title of the Short Text. Can be an empty string. */
  title?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of SignInWithApple */
export type SignInWithAppleInput = {
  authCode: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  iosAppId: Scalars['String']['input'];
  lastName?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of SignInWithApple */
export type SignInWithApplePayload = {
  __typename?: 'SignInWithApplePayload';
  apiAccessToken?: Maybe<Scalars['String']['output']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Simple shipping rule for a reward */
export type SimpleShippingRule = {
  __typename?: 'SimpleShippingRule';
  cost?: Maybe<Scalars['String']['output']>;
  country: Scalars['String']['output'];
  currency?: Maybe<Scalars['String']['output']>;
  estimatedMax?: Maybe<Scalars['String']['output']>;
  estimatedMin?: Maybe<Scalars['String']['output']>;
  locationId?: Maybe<Scalars['ID']['output']>;
  locationName?: Maybe<Scalars['String']['output']>;
};

/** Projects that can be shown in article */
export type SingleProjectContainer = {
  __typename?: 'SingleProjectContainer';
  id: Scalars['ID']['output'];
  /** The currently selected project */
  selectedProject: SingleProjectItem;
  /** The selected project items in this collection */
  singleProjectItems: Array<Maybe<SingleProjectItem>>;
};

/** A selected project to be shown in an editorial layout. */
export type SingleProjectItem = {
  __typename?: 'SingleProjectItem';
  /** The project description or, if specified, the project description override */
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** If specified, will override the image of the associated project */
  imageOverride?: Maybe<Scalars['String']['output']>;
  /** The project that is featured */
  project: Project;
  /** The project id (pid) of the featured project */
  projectId: Scalars['Int']['output'];
  /** The see more url for this featured section */
  sectionUrl: Scalars['String']['output'];
  /** The project title or, if specified, the project title override */
  title: Scalars['String']['output'];
};

/** A project spreadsheet, including a url and row data */
export type Spreadsheet = {
  __typename?: 'Spreadsheet';
  /** The data of the Google Sheet associated to this project */
  data?: Maybe<Array<Maybe<SpreadsheetDatum>>>;
  /** When the data for the sheet was last fetched successfully */
  dataLastUpdatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** Can be `amount` or `percent` based on the creator's choice */
  displayMode: Scalars['String']['output'];
  /** Whether a spreadsheet contains the minimum information to render a graphic budget */
  hasDisplayableData: Scalars['Boolean']['output'];
  /** Whether the sheet is shareable with the public */
  public: Scalars['Boolean']['output'];
  /** The URL of the Google Sheet associated to this project */
  url?: Maybe<Scalars['String']['output']>;
};

/** A row of datum for a funding spreadsheet */
export type SpreadsheetDatum = {
  __typename?: 'SpreadsheetDatum';
  /** Expanded description of the purpose of that row */
  description?: Maybe<Scalars['String']['output']>;
  /** The name of the row */
  name?: Maybe<Scalars['String']['output']>;
  /** The funding category of the row */
  phase?: Maybe<Scalars['String']['output']>;
  /** The spreadsheet row number */
  rowNum: Scalars['Int']['output'];
  /** The dollar value of the row */
  value?: Maybe<Scalars['Float']['output']>;
};

/** Operators for SQL filters */
export enum SqlFilterOperator {
  /** Logical AND */
  And = 'AND',
  /** Logical NOT */
  Not = 'NOT',
  /** Logical OR */
  Or = 'OR'
}

/** Location from which a project fulfills */
export type StockLocation = {
  __typename?: 'StockLocation';
  address: Address;
  id: Scalars['ID']['output'];
  project: Project;
  /** Places this stock location ships to */
  stockLocationMappings: Array<StockLocationMapping>;
};

/** A place that a project stock location ships to */
export type StockLocationMapping = {
  __typename?: 'StockLocationMapping';
  id: Scalars['ID']['output'];
  location: Location;
  stockLocation: StockLocation;
};

/** The street address of an individual or company */
export type StreetAddress = {
  __typename?: 'StreetAddress';
  /** 2-letter country code */
  country?: Maybe<Scalars['String']['output']>;
  /** City/District/Suburb/Town/Village */
  locality?: Maybe<Scalars['String']['output']>;
  /** ZIP or postal code */
  postalCode?: Maybe<Scalars['String']['output']>;
  /** State/County/Province/Region. */
  region?: Maybe<Scalars['String']['output']>;
  /** Address line 1 (Street address/PO Box/Company name) */
  street1?: Maybe<Scalars['String']['output']>;
  /** Address line 2 (Apartment/Suite/Unit/Building) */
  street2?: Maybe<Scalars['String']['output']>;
};

/** Different contexts for which stripe intents can be created */
export enum StripeIntentContextTypes {
  CrowdfundingCheckout = 'CROWDFUNDING_CHECKOUT',
  PostCampaignCheckout = 'POST_CAMPAIGN_CHECKOUT',
  ProfileSettings = 'PROFILE_SETTINGS',
  ProjectBuild = 'PROJECT_BUILD'
}

/** A submission for a project on Kickstarter. */
export type Submission = {
  __typename?: 'Submission';
  /** The message from the creator appealing a rejection. */
  appeal?: Maybe<Message>;
  /** If the submission has messages between the creator and KSR staff. */
  hasMessages: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** If the system has processed a submission for review. */
  isProcessed: Scalars['Boolean']['output'];
  /** A submission's messages between the creator and KSR staff. */
  messages?: Maybe<Array<Maybe<Message>>>;
  /** The submission's current state. */
  state: SubmissionState;
  /** When was the project first submitted? */
  submittedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** Various submission states. */
export enum SubmissionState {
  /** Accepted by a reviewer, can launch. */
  Accepted = 'ACCEPTED',
  /** Rejection appealed, asking for re-review. */
  Appealed = 'APPEALED',
  /** Not yet submitted. */
  Draft = 'DRAFT',
  /** Submitted for review, waiting for acception or rejection. */
  Pending = 'PENDING',
  /** Rejected by a reviewer, cannot launch. */
  Rejected = 'REJECTED'
}

/** Autogenerated input type of SubmitPledgeManager */
export type SubmitPledgeManagerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The pledge manager id */
  pledgeManagerId: Scalars['ID']['input'];
};

/** Autogenerated return type of SubmitPledgeManager */
export type SubmitPledgeManagerPayload = {
  __typename?: 'SubmitPledgeManagerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** Autogenerated input type of SubmitProject */
export type SubmitProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of SubmitProject */
export type SubmitProjectPayload = {
  __typename?: 'SubmitProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of SubmitRefundCheckout */
export type SubmitRefundCheckoutInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  paymentSourceId: Scalars['String']['input'];
  refundCheckoutId: Scalars['ID']['input'];
};

/** Autogenerated return type of SubmitRefundCheckout */
export type SubmitRefundCheckoutPayload = {
  __typename?: 'SubmitRefundCheckoutPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  redirectUrl: Scalars['String']['output'];
  refundCheckout: RefundCheckout;
};

/** Autogenerated input type of SubmitResponses */
export type SubmitResponsesInput = {
  addressId?: InputMaybe<Scalars['ID']['input']>;
  backerQuestionAnswers: Array<AnswerInput>;
  cartId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  finalizeOnSubmit?: InputMaybe<Scalars['Boolean']['input']>;
  lineItemUpdates: Array<LineItemInput>;
};

/** Autogenerated return type of SubmitResponses */
export type SubmitResponsesPayload = {
  __typename?: 'SubmitResponsesPayload';
  /** The finalized cart, if submission is successful. */
  cart?: Maybe<Cart>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The delivery address attached to backing. */
  deliveryAddress?: Maybe<Address>;
  /** Succeeds if cart is finalized. */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of SubmitVatNumber */
export type SubmitVatNumberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
  vatNumber: Scalars['String']['input'];
};

/** Autogenerated return type of SubmitVatNumber */
export type SubmitVatNumberPayload = {
  __typename?: 'SubmitVatNumberPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of SucceedOrder */
export type SucceedOrderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The order id */
  orderId: Scalars['ID']['input'];
};

/** Autogenerated return type of SucceedOrder */
export type SucceedOrderPayload = {
  __typename?: 'SucceedOrderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Whether the state transition succeeded */
  success: Scalars['Boolean']['output'];
};

/** A surcharge for a particular item and location combo */
export type SurchargeRule = {
  __typename?: 'SurchargeRule';
  /** The surcharge cost for this location. */
  cost: Scalars['Int']['output'];
  /** The formatted surcharge cost for this location. */
  costFormatted: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  item: RewardItem;
  location: Location;
};

/** A survey */
export type Survey = Node & {
  __typename?: 'Survey';
  id: Scalars['ID']['output'];
};

export type SurveyAnswer = {
  __typename?: 'SurveyAnswer';
  /** The response to the question. */
  answer: Array<Scalars['String']['output']>;
  /** The ID of the answer. */
  id?: Maybe<Scalars['String']['output']>;
  /** The question prompt or template name. */
  question: Scalars['String']['output'];
  /** The type of question, e.g. choices, checkbox, address, etc */
  template: SurveyQuestionTemplateEnum;
};

/** An embedded iframe containing a Survey */
export type SurveyEmbed = {
  __typename?: 'SurveyEmbed';
  /** The url of the survey being embedded */
  embedUrl: Scalars['String']['output'];
  /** Height of the embedded iframe */
  height?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
};

/** Enum describing all the possible templates for survey questions */
export enum SurveyQuestionTemplateEnum {
  /** address */
  Address = 'address',
  /** checkboxes */
  Checkboxes = 'checkboxes',
  /** choices */
  Choices = 'choices',
  /** email */
  Email = 'email',
  /** name */
  Name = 'name',
  /** other */
  Other = 'other'
}

/** The response to a backer survey. */
export type SurveyResponse = {
  __typename?: 'SurveyResponse';
  /** Is the address still editable */
  addressEditable: Scalars['Boolean']['output'];
  /** The date past which no further updates are allowed. */
  answerDeadline?: Maybe<Scalars['DateTime']['output']>;
  /** Is the survey currently unlocked and answerable. */
  answerable: Scalars['Boolean']['output'];
  /** The date on which the backer answered the survey */
  answeredAt?: Maybe<Scalars['DateTime']['output']>;
  /** An array of question and answer data for this survey response */
  answers: Array<SurveyAnswer>;
  /** The date on which the backer edited their survey response */
  editedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** The url used to access the survey */
  url: Scalars['String']['output'];
};

/** An edge in a connection. */
export type SurveyResponseEdge = {
  __typename?: 'SurveyResponseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SurveyResponse>;
};

/** The connection type for SurveyResponse. */
export type SurveyResponsesConnection = {
  __typename?: 'SurveyResponsesConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SurveyResponseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SurveyResponse>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** A project tag. */
export type Tag = Node & {
  __typename?: 'Tag';
  id: Scalars['ID']['output'];
  /** Tag name. */
  name: Scalars['String']['output'];
  /** Projects associated with a tag. */
  projects?: Maybe<TagProjectsConnection>;
  /** Tag slug. */
  slug: Scalars['String']['output'];
  /** A URL for the tag page. */
  url: Scalars['String']['output'];
};


/** A project tag. */
export type TagProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  state: PublicProjectState;
};

/** An edge in a connection. */
export type TagEdge = {
  __typename?: 'TagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Tag>;
};

/** The connection type for Project. */
export type TagProjectsConnection = {
  __typename?: 'TagProjectsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** Various scopes for tags. */
export enum TagScope {
  /** Tags currently available as creative prompts. */
  CreativePrompt = 'CREATIVE_PROMPT',
  /** Tags currently visible in discovery interfaces. */
  Discover = 'DISCOVER'
}

/** The connection type for Tag. */
export type TagsConnection = {
  __typename?: 'TagsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TagEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Tag>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** A project scoped tax category */
export type TaxCategory = {
  __typename?: 'TaxCategory';
  /** Whether or not the category is associated with multiple items */
  associatedWithMultipleItems: Scalars['Boolean']['output'];
  /** Describes what products or services the tax code covers */
  codeDescription?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Whether or not this is a default category managed by Kickstarter */
  ksrManaged: Scalars['Boolean']['output'];
  /** Whether or not the category is nontaxable */
  nontaxable: Scalars['Boolean']['output'];
  /** Third party tax code */
  taxCode: Scalars['String']['output'];
  /** The user assigned label for the vendor tax code */
  userLabel: Scalars['String']['output'];
};

/** Input to create or update a tax category */
export type TaxCategoryInput = {
  taxCode: Scalars['String']['input'];
  userLabel: Scalars['String']['input'];
};

export type ThirdPartyEventItemInput = {
  /** The ID of the item. */
  itemId: Scalars['String']['input'];
  /** The name of the item. */
  itemName: Scalars['String']['input'];
  /** The monetary price of the item, in units of the specified currency parameter. */
  price?: InputMaybe<Scalars['Float']['input']>;
};

/** Types that can be reported by users */
export type TimelineEventData = CreatorInterview | FreeformPost | Project;

/** Autogenerated input type of ToggleCommentPin */
export type ToggleCommentPinInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  commentId: Scalars['ID']['input'];
  pinned: Scalars['Boolean']['input'];
};

/** Autogenerated return type of ToggleCommentPin */
export type ToggleCommentPinPayload = {
  __typename?: 'ToggleCommentPinPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  comment: Comment;
};

/** Autogenerated input type of ToggleProjectMilestone */
export type ToggleProjectMilestoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  milestoneCategory: Scalars['String']['input'];
};

/** Autogenerated return type of ToggleProjectMilestone */
export type ToggleProjectMilestonePayload = {
  __typename?: 'ToggleProjectMilestonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  milestone?: Maybe<ProjectMilestone>;
};

/** Autogenerated input type of ToggleProjectPreview */
export type ToggleProjectPreviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ToggleProjectPreview */
export type ToggleProjectPreviewPayload = {
  __typename?: 'ToggleProjectPreviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** Autogenerated input type of ToggleTariffSurchargesEnabled */
export type ToggleTariffSurchargesEnabledInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The pledge manager id */
  pledgeManagerId: Scalars['ID']['input'];
};

/** Autogenerated return type of ToggleTariffSurchargesEnabled */
export type ToggleTariffSurchargesEnabledPayload = {
  __typename?: 'ToggleTariffSurchargesEnabledPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** Autogenerated input type of TranslateEditorialLayoutType */
export type TranslateEditorialLayoutTypeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Revision for the Editorial Layout */
  revision: Scalars['String']['input'];
  /** Slug for the Editorial Layout */
  slug: Scalars['String']['input'];
};

/** Autogenerated return type of TranslateEditorialLayoutType */
export type TranslateEditorialLayoutTypePayload = {
  __typename?: 'TranslateEditorialLayoutTypePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  layout?: Maybe<Layout>;
};

/** Autogenerated input type of TriggerThirdPartyEvent */
export type TriggerThirdPartyEventInput = {
  appData?: InputMaybe<AppDataInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  deviceId: Scalars['String']['input'];
  eventName: Scalars['String']['input'];
  firebasePreviousScreen?: InputMaybe<Scalars['String']['input']>;
  firebaseScreen?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<Array<ThirdPartyEventItemInput>>;
  pledgeAmount?: InputMaybe<Scalars['Float']['input']>;
  projectId: Scalars['ID']['input'];
  shipping?: InputMaybe<Scalars['Float']['input']>;
  transactionId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of TriggerThirdPartyEvent */
export type TriggerThirdPartyEventPayload = {
  __typename?: 'TriggerThirdPartyEventPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of UnblockUser */
export type UnblockUserInput = {
  blockUserId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UnblockUser */
export type UnblockUserPayload = {
  __typename?: 'UnblockUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  currentUser?: Maybe<User>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of UndislikeProject */
export type UndislikeProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the project that the user has un-disliked */
  id: Scalars['ID']['input'];
  /** The context or page that the user undisliked this project from. Used for tracking */
  trackingContext?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UndislikeProject */
export type UndislikeProjectPayload = {
  __typename?: 'UndislikeProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UnfollowUser */
export type UnfollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UnfollowUser */
export type UnfollowUserPayload = {
  __typename?: 'UnfollowUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UnlikePost */
export type UnlikePostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlikePost */
export type UnlikePostPayload = {
  __typename?: 'UnlikePostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  post?: Maybe<Postable>;
};

/** Autogenerated input type of UnlikeProject */
export type UnlikeProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the project that the user has unliked */
  id: Scalars['ID']['input'];
  /** The context or page that the user unliked this project from. Used for tracking */
  trackingContext?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UnlikeProject */
export type UnlikeProjectPayload = {
  __typename?: 'UnlikeProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UnpinPost */
export type UnpinPostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UnpinPost */
export type UnpinPostPayload = {
  __typename?: 'UnpinPostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  post?: Maybe<Postable>;
};

/** Autogenerated input type of UnpublishEditorialLayoutType */
export type UnpublishEditorialLayoutTypeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Revision for the Editorial Layout */
  revision: Scalars['String']['input'];
  /** Slug for the Editorial Layout */
  slug: Scalars['String']['input'];
};

/** Autogenerated return type of UnpublishEditorialLayoutType */
export type UnpublishEditorialLayoutTypePayload = {
  __typename?: 'UnpublishEditorialLayoutTypePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  layout?: Maybe<Layout>;
};

/** Autogenerated input type of UntagProject */
export type UntagProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  tag: Scalars['String']['input'];
};

/** Autogenerated return type of UntagProject */
export type UntagProjectPayload = {
  __typename?: 'UntagProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of UnwatchProject */
export type UnwatchProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  trackingContext?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UnwatchProject */
export type UnwatchProjectPayload = {
  __typename?: 'UnwatchProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UpdateAcceptsNewBackers */
export type UpdateAcceptsNewBackersInput = {
  /** Whether the pledge manager accepts new backers or not */
  acceptsNewBackers: Scalars['Boolean']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the project related to the pledge manager */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateAcceptsNewBackers */
export type UpdateAcceptsNewBackersPayload = {
  __typename?: 'UpdateAcceptsNewBackersPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Updated project */
  project: Project;
};

/** Autogenerated input type of UpdateBackerCompleted */
export type UpdateBackerCompletedInput = {
  backerCompleted: Scalars['Boolean']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateBackerCompleted */
export type UpdateBackerCompletedPayload = {
  __typename?: 'UpdateBackerCompletedPayload';
  backing?: Maybe<Backing>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateBackerSurveyIntro */
export type UpdateBackerSurveyIntroInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  intro?: InputMaybe<Scalars['HTML']['input']>;
  surveyId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateBackerSurveyIntro */
export type UpdateBackerSurveyIntroPayload = {
  __typename?: 'UpdateBackerSurveyIntroPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated survey. */
  survey: BackerSurvey;
};

/** Autogenerated input type of UpdateBacking */
export type UpdateBackingInput = {
  amount?: InputMaybe<Scalars['String']['input']>;
  applePay?: InputMaybe<ApplePayInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  /** Stripe SetupIntent client secret */
  intentClientSecret?: InputMaybe<Scalars['String']['input']>;
  locationId?: InputMaybe<Scalars['String']['input']>;
  /** new payment source id */
  paymentSourceId?: InputMaybe<Scalars['String']['input']>;
  /** Relay encoded Reward ID - legacy */
  rewardId?: InputMaybe<Scalars['ID']['input']>;
  /** List of Relay encoded Reward/Add-on IDs */
  rewardIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated return type of UpdateBacking */
export type UpdateBackingPayload = {
  __typename?: 'UpdateBackingPayload';
  checkout?: Maybe<Checkout>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateBackingPaymentSource */
export type UpdateBackingPaymentSourceInput = {
  applePay?: InputMaybe<ApplePayInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the backing being updated */
  id: Scalars['ID']['input'];
  /** new payment source id */
  paymentSourceId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateBackingPaymentSource */
export type UpdateBackingPaymentSourcePayload = {
  __typename?: 'UpdateBackingPaymentSourcePayload';
  backing?: Maybe<Backing>;
  checkout?: Maybe<Checkout>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateConsent */
export type UpdateConsentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  consentJson: Scalars['String']['input'];
  userIdentifier: Scalars['String']['input'];
};

/** Autogenerated return type of UpdateConsent */
export type UpdateConsentPayload = {
  __typename?: 'UpdateConsentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UpdateCreatorInterview */
export type UpdateCreatorInterviewInput = {
  answers?: InputMaybe<Array<InterviewAnswerInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  public?: InputMaybe<Scalars['Boolean']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateCreatorInterview */
export type UpdateCreatorInterviewPayload = {
  __typename?: 'UpdateCreatorInterviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  creatorInterview?: Maybe<CreatorInterview>;
};

/** Autogenerated input type of UpdateCrossSellsOnOrder */
export type UpdateCrossSellsOnOrderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  crossSells: Array<SelectedCrossSellInput>;
  /** Order ID that the Cross Sells are being added onto */
  orderId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateCrossSellsOnOrder */
export type UpdateCrossSellsOnOrderPayload = {
  __typename?: 'UpdateCrossSellsOnOrderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The Order that has been updated */
  order: Order;
};

/** Autogenerated input type of UpdateFulfillmentModalDismissedAt */
export type UpdateFulfillmentModalDismissedAtInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateFulfillmentModalDismissedAt */
export type UpdateFulfillmentModalDismissedAtPayload = {
  __typename?: 'UpdateFulfillmentModalDismissedAtPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of UpdateFulfillmentStatus */
export type UpdateFulfillmentStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  fulfillmentStatus: FulfillmentStatus;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateFulfillmentStatus */
export type UpdateFulfillmentStatusPayload = {
  __typename?: 'UpdateFulfillmentStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of UpdateItemVariants */
export type UpdateItemVariantsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  itemVariants?: InputMaybe<Array<ItemVariantInput>>;
};

/** Autogenerated return type of UpdateItemVariants */
export type UpdateItemVariantsPayload = {
  __typename?: 'UpdateItemVariantsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated item variants */
  itemVariants?: Maybe<Array<ItemVariant>>;
};

/** Autogenerated input type of UpdateItemWeights */
export type UpdateItemWeightsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  itemWeightInputs: Array<ItemWeightInput>;
  projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateItemWeights */
export type UpdateItemWeightsPayload = {
  __typename?: 'UpdateItemWeightsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Updated project */
  project: Project;
};

/** Autogenerated input type of UpdateOption */
export type UpdateOptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  optionTypeId: Scalars['ID']['input'];
  prompt?: InputMaybe<Scalars['String']['input']>;
  values: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateOption */
export type UpdateOptionPayload = {
  __typename?: 'UpdateOptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  optionType?: Maybe<OptionType>;
};

/** Autogenerated input type of UpdateOrderableConfig */
export type UpdateOrderableConfigInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Price for cross-sells */
  crossSellPrice?: InputMaybe<Scalars['Int']['input']>;
  /** Available for cross-sells or not */
  enabled: Scalars['Boolean']['input'];
  /** How many are cross-sellable total */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** How many a backer can add to their order */
  limitPerOrder?: InputMaybe<Scalars['Int']['input']>;
  /** Kickstarter BackerReward id (for now) */
  orderableId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateOrderableConfig */
export type UpdateOrderableConfigPayload = {
  __typename?: 'UpdateOrderableConfigPayload';
  /** The updated BackerReward */
  addOn: Reward;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdatePledgeManagementReward */
export type UpdatePledgeManagementRewardInput = {
  altText?: InputMaybe<Scalars['String']['input']>;
  amount: Scalars['Int']['input'];
  audienceData?: InputMaybe<AudienceInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  deleteAsset?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
  image?: InputMaybe<S3AssetInput>;
  items?: InputMaybe<Array<InputMaybe<RewardItemInput>>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  limitPerOrder?: InputMaybe<Scalars['Int']['input']>;
  localReceiptLocationId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  shippingPreference: ShippingPreference;
  shippingRules?: InputMaybe<Array<InputMaybe<ShippingRuleInput>>>;
};

/** Autogenerated return type of UpdatePledgeManagementReward */
export type UpdatePledgeManagementRewardPayload = {
  __typename?: 'UpdatePledgeManagementRewardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of UpdatePost */
export type UpdatePostInput = {
  body?: InputMaybe<Scalars['HTML']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  public?: InputMaybe<Scalars['Boolean']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdatePost */
export type UpdatePostPayload = {
  __typename?: 'UpdatePostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  post?: Maybe<FreeformPost>;
};

/** Autogenerated input type of UpdateProjectCollaborator */
export type UpdateProjectCollaboratorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Updated permissions granted to the collaborator */
  permissions: Array<CollaboratorPermission>;
  /** ID of project updating the collaborator */
  projectId: Scalars['ID']['input'];
  /** Title of the collaborator */
  title: Scalars['String']['input'];
  /** ID of the collaborator */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProjectCollaborator */
export type UpdateProjectCollaboratorPayload = {
  __typename?: 'UpdateProjectCollaboratorPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** Autogenerated input type of UpdateProject */
export type UpdateProjectInput = {
  additionalSubcategoryId?: InputMaybe<Scalars['ID']['input']>;
  aiDisclosure?: InputMaybe<AiDisclosureInput>;
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  chargeShippingInPledgeManager?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<CurrencyCode>;
  deadline?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  /** Duration of campaign, in days. */
  duration?: InputMaybe<Scalars['Int']['input']>;
  environmentalCommitments?: InputMaybe<Array<InputMaybe<EnvironmentalCommitmentInput>>>;
  faqs?: InputMaybe<Array<FaqInput>>;
  goal?: InputMaybe<Scalars['Int']['input']>;
  googleAnalyticsApiSecret?: InputMaybe<Scalars['String']['input']>;
  googleAnalyticsTrackingId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  locationId?: InputMaybe<Scalars['ID']['input']>;
  metaCapiAccessToken?: InputMaybe<Scalars['String']['input']>;
  metaPixelId?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentSourceId?: InputMaybe<Scalars['String']['input']>;
  pledgeOverTimeEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  postCampaignPledgesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  prelaunchStory?: InputMaybe<Scalars['HTML']['input']>;
  risks?: InputMaybe<Scalars['String']['input']>;
  story?: InputMaybe<Scalars['HTML']['input']>;
  storyRteVersion?: InputMaybe<Scalars['String']['input']>;
  targetLaunchDate?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
};

/** Autogenerated return type of UpdateProject */
export type UpdateProjectPayload = {
  __typename?: 'UpdateProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of UpdateProjectPaymentSource */
export type UpdateProjectPaymentSourceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  paymentSourceId: Scalars['String']['input'];
};

/** Autogenerated return type of UpdateProjectPaymentSource */
export type UpdateProjectPaymentSourcePayload = {
  __typename?: 'UpdateProjectPaymentSourcePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  paymentSource?: Maybe<CreditCard>;
};

/** Autogenerated input type of UpdateProjectRiskStrategies */
export type UpdateProjectRiskStrategiesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
  riskStrategies: Array<RiskStrategyInput>;
};

/** Autogenerated return type of UpdateProjectRiskStrategies */
export type UpdateProjectRiskStrategiesPayload = {
  __typename?: 'UpdateProjectRiskStrategiesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  updatedRiskStrategies?: Maybe<Array<RiskStrategy>>;
};

/** Autogenerated input type of UpdateProjectVerifiedCreatorName */
export type UpdateProjectVerifiedCreatorNameInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

/** Autogenerated return type of UpdateProjectVerifiedCreatorName */
export type UpdateProjectVerifiedCreatorNamePayload = {
  __typename?: 'UpdateProjectVerifiedCreatorNamePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project: Project;
};

/** Autogenerated input type of UpdateQuestion */
export type UpdateQuestionInput = {
  choiceSelectionLimit?: InputMaybe<Scalars['Int']['input']>;
  choices?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  optional: Scalars['Boolean']['input'];
  prompt: Scalars['String']['input'];
  questionId: Scalars['ID']['input'];
  type: QuestionType;
};

/** Autogenerated return type of UpdateQuestion */
export type UpdateQuestionPayload = {
  __typename?: 'UpdateQuestionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  question?: Maybe<Question>;
};

/** Autogenerated input type of UpdateResourceAudience */
export type UpdateResourceAudienceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  removeRestrictions?: InputMaybe<Scalars['Boolean']['input']>;
  /** The resource id */
  resourceId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateResourceAudience */
export type UpdateResourceAudiencePayload = {
  __typename?: 'UpdateResourceAudiencePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  resource: SecretResource;
};

/** Autogenerated input type of UpdateReward */
export type UpdateRewardInput = {
  altText?: InputMaybe<Scalars['String']['input']>;
  amount?: InputMaybe<Scalars['Int']['input']>;
  audienceData?: InputMaybe<AudienceInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  deleteAsset?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endCondition?: InputMaybe<Scalars['Int']['input']>;
  endsAt?: InputMaybe<Scalars['Int']['input']>;
  estimatedDeliveryOn?: InputMaybe<Scalars['Date']['input']>;
  id: Scalars['ID']['input'];
  image?: InputMaybe<S3AssetInput>;
  items?: InputMaybe<Array<InputMaybe<RewardItemInput>>>;
  latePledgeAmount?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  limitPerBacker?: InputMaybe<Scalars['Int']['input']>;
  localReceiptLocationId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  rewardType?: InputMaybe<RewardType>;
  shippingPreference?: InputMaybe<ShippingPreference>;
  shippingRules?: InputMaybe<Array<InputMaybe<ShippingRuleInput>>>;
  startCondition?: InputMaybe<Scalars['Int']['input']>;
  startsAt?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UpdateRewardItem */
export type UpdateRewardItemInput = {
  altText?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  deleteAsset?: InputMaybe<Scalars['Boolean']['input']>;
  deliveryType?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  image?: InputMaybe<S3AssetInput>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateRewardItem */
export type UpdateRewardItemPayload = {
  __typename?: 'UpdateRewardItemPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  item?: Maybe<RewardItem>;
};

/** Autogenerated return type of UpdateReward */
export type UpdateRewardPayload = {
  __typename?: 'UpdateRewardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
};

/** Autogenerated input type of UpdateRewardShippingRates */
export type UpdateRewardShippingRatesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Kickstarter BackerReward (base or addon) id */
  rewardId: Scalars['ID']['input'];
  shippingRates: Array<ShippingRateInput>;
};

/** Autogenerated return type of UpdateRewardShippingRates */
export type UpdateRewardShippingRatesPayload = {
  __typename?: 'UpdateRewardShippingRatesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated BackerReward */
  reward: Reward;
};

/** Autogenerated input type of UpdateSpreadsheetToggles */
export type UpdateSpreadsheetTogglesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  displayMode?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  public?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of UpdateSpreadsheetToggles */
export type UpdateSpreadsheetTogglesPayload = {
  __typename?: 'UpdateSpreadsheetTogglesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  spreadsheet?: Maybe<Spreadsheet>;
};

/** Autogenerated input type of UpdateUserAccount */
export type UpdateUserAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  currentPassword?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['Email']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  passwordConfirmation?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateUserAccount */
export type UpdateUserAccountPayload = {
  __typename?: 'UpdateUserAccountPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UpdateUserNotificationFrequency */
export type UpdateUserNotificationFrequencyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  frequency: UserNotificationFrequency;
  topic: UserNotificationTopic;
};

/** Autogenerated return type of UpdateUserNotificationFrequency */
export type UpdateUserNotificationFrequencyPayload = {
  __typename?: 'UpdateUserNotificationFrequencyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  userNotification?: Maybe<Notification>;
};

/** Autogenerated input type of UpdateUserNotification */
export type UpdateUserNotificationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  kind: UserNotificationKind;
  topic: UserNotificationTopic;
  value: Scalars['Boolean']['input'];
};

/** Autogenerated return type of UpdateUserNotification */
export type UpdateUserNotificationPayload = {
  __typename?: 'UpdateUserNotificationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  userNotification?: Maybe<Notification>;
};

/** Autogenerated input type of UpdateUserProfile */
export type UpdateUserProfileInput = {
  biography?: InputMaybe<Scalars['String']['input']>;
  chosenCurrency?: InputMaybe<CurrencyCode>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  locationId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateUserProfile */
export type UpdateUserProfilePayload = {
  __typename?: 'UpdateUserProfilePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UpdateUserSetting */
export type UpdateUserSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  enable?: InputMaybe<Scalars['Boolean']['input']>;
  setting: UserSetting;
};

/** Autogenerated return type of UpdateUserSetting */
export type UpdateUserSettingPayload = {
  __typename?: 'UpdateUserSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UpgradeRewardOnOrder */
export type UpgradeRewardOnOrderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the location the backer selected */
  locationId?: InputMaybe<Scalars['ID']['input']>;
  /** ID of the order that the upgrade is being applied to */
  orderId: Scalars['ID']['input'];
  /** ID of the reward to upgrade to */
  rewardUpgradeId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of UpgradeRewardOnOrder */
export type UpgradeRewardOnOrderPayload = {
  __typename?: 'UpgradeRewardOnOrderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The order that has been updated */
  order: Order;
};

/** A maximum valid filesize for an upload. */
export type UploadLimit = {
  __typename?: 'UploadLimit';
  /** An array of the valid content types for an upload of this type. */
  contentTypes: Array<Maybe<Scalars['String']['output']>>;
  /** Maximum file size in the provided units. */
  fileSize: Scalars['Int']['output'];
};


/** A maximum valid filesize for an upload. */
export type UploadLimitFileSizeArgs = {
  unit: UploadLimitFileSizeUnit;
};

/** The unit of file size the return the upload limit in. */
export enum UploadLimitFileSizeUnit {
  /** Bytes. */
  Bytes = 'BYTES',
  /** Kilobytes. */
  Kilobytes = 'KILOBYTES',
  /** Megabytes. */
  Megabytes = 'MEGABYTES'
}

/** The type of file we are checking the upload limit of. */
export enum UploadLimitFiletype {
  /** An asset video file. */
  AssetVideo = 'ASSET_VIDEO',
  /** An audio file. */
  Audio = 'AUDIO',
  /** A photo file. */
  Photo = 'PHOTO',
  /** A smaller video file. */
  SmallerVideo = 'SMALLER_VIDEO',
  /** A sound file */
  Sound = 'SOUND',
  /** A video file. */
  Video = 'VIDEO'
}

/** Informs how USD currencies should be rendered, based on user's location */
export enum UsdType {
  /** The user has chosen USD as their currency and they are in the US */
  Domestic = 'domestic',
  /** The user has chosen USD as their currency but they are not in the US */
  International = 'international'
}

/** A member of Kickstarter. */
export type User = Node & {
  __typename?: 'User';
  /** A user's active backings of live projects */
  activeBackings: UserBackingsConnection;
  /** Projects a user has created or is an active collaborator on */
  activeProjects?: Maybe<UserActiveProjectsConnection>;
  /** This user's saved shipping addresses */
  addresses?: Maybe<AddressConnection>;
  /** Indicates whether or not the user allows other Kickstarter users to follow them */
  allowsFollows: Scalars['Boolean']['output'];
  /** Projects a user has backed. */
  backedProjects?: Maybe<UserBackedProjectsConnection>;
  /** Count of pledges with pending action */
  backingActionCount?: Maybe<Scalars['Int']['output']>;
  /** A user's backings. */
  backings?: Maybe<UserBackingsConnection>;
  /** Number of backings for this user. */
  backingsCount: Scalars['Int']['output'];
  /** A description of the user's background. */
  biography?: Maybe<Scalars['String']['output']>;
  /** List of users blocked by current user */
  blockedUsers?: Maybe<Array<User>>;
  /** Whether or not the user can curate pages */
  canCurate?: Maybe<Scalars['Boolean']['output']>;
  /** Whether a user is trusted to configure prelaunch early. */
  canPrelaunchEarly: Scalars['Boolean']['output'];
  /** Whether user can see the confirmation modal that appears after the user likes or dislike a project for the first time */
  canSeeConfirmSignalModal?: Maybe<Scalars['Boolean']['output']>;
  /** Whether user can see the confirmation modal that appears after the user watches a project for the first time */
  canSeeConfirmWatchModal?: Maybe<Scalars['Boolean']['output']>;
  /** Whether user can see PYL toast notification */
  canSeePylToast?: Maybe<Scalars['Boolean']['output']>;
  /** Whether user can see the reward images toast notification that appears on build pages */
  canSeeRewardImagesToast?: Maybe<Scalars['Boolean']['output']>;
  /** Whether user can see the taste profile toast notification that appears on the thanks page */
  canSeeTasteProfileToast?: Maybe<Scalars['Boolean']['output']>;
  /** The user's chosen currency */
  chosenCurrency?: Maybe<Scalars['String']['output']>;
  /** Conversations the user had */
  conversations?: Maybe<UserConversationsConnection>;
  /** Projects a user has created. */
  createdProjects?: Maybe<UserCreatedProjectsConnection>;
  /** Pages curated by the user */
  curatedPages?: Maybe<UserCuratedPagesConnection>;
  /** Digital Access Resources provided by a creator to fulfill digital rewards */
  digitalAccessResources: Array<DigitalAccessResource>;
  /** A user's email address. */
  email?: Maybe<Scalars['String']['output']>;
  enabledFeatures: Array<Feature>;
  /** Users following a user. */
  followers?: Maybe<UserFollowersConnection>;
  /** Users a user is following. */
  following?: Maybe<UserFollowingConnection>;
  /**
   * Projects a user has launched that are successful,
   *           but have not completed fulfillment
   */
  fulfillingProjects: Array<Project>;
  /** If the user has uploaded an avatar. */
  hasImage: Scalars['Boolean']['output'];
  /** Whether or not the user has a password. */
  hasPassword?: Maybe<Scalars['Boolean']['output']>;
  /** Whether a user has their slug set. */
  hasSlug: Scalars['Boolean']['output'];
  /** Whether or not a user has unread messages. */
  hasUnreadMessages?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not a user has unseen activity. */
  hasUnseenActivity?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not a user has unseen saved projects activity. */
  hasUnseenSavedProjectsActivity?: Maybe<Scalars['Boolean']['output']>;
  /** The highest sentiment for successful projects for a user */
  highestProjectSentiment?: Maybe<Scalars['Float']['output']>;
  id: Scalars['ID']['output'];
  /** The user's avatar. */
  imageUrl: Scalars['String']['output'];
  /** Projects a user has been invited to collaborate on */
  invitedProjects?: Maybe<UserInvitedProjectsConnection>;
  /** Whether or not the user has authenticated with Apple. */
  isAppleConnected?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the user (as a creator) is a Backer Favorite */
  isBackerFavorite: Scalars['Boolean']['output'];
  /** Is user blocked by current user */
  isBlocked?: Maybe<Scalars['Boolean']['output']>;
  /** Whether a user is a creator of any project */
  isCreator?: Maybe<Scalars['Boolean']['output']>;
  /** Whether a user's email address is deliverable */
  isDeliverable?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not the user's email is verified. */
  isEmailVerified?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not the user is connected to Facebook. */
  isFacebookConnected?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not you are following the user. */
  isFollowing: Scalars['Boolean']['output'];
  /** Whether a KSR admin is ghosting as another user */
  isGhosting?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not you are a KSR admin. */
  isKsrAdmin?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the user is registered */
  isRegistered: Scalars['Boolean']['output'];
  /** Whether the user can create SEPA account payment sources */
  isSepaEligible: Scalars['Boolean']['output'];
  /** Whether a user's entered slug is valid. */
  isSlugValid: Validation;
  /** Whether or not the user is either Facebook connected or has follows/followings. */
  isSocializing?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the user is a superbacker */
  isSuperbacker: Scalars['Boolean']['output'];
  /** The timestamp of when the user joined Kickstarter */
  joinedOn: Scalars['ISO8601DateTime']['output'];
  /** The last time a user logged in, time since epoch */
  lastLogin?: Maybe<Scalars['DateTime']['output']>;
  /** The most recent successful project that has a positive sentiment and a qualifying backer coverage rate */
  latestBackerFavoriteProject?: Maybe<Project>;
  /** Projects a user has launched. */
  launchedProjects?: Maybe<ProjectsConnectionWithTotalCount>;
  /** Where the user is based. */
  location?: Maybe<Location>;
  /** Projects the user has collaborated on. */
  membershipProjects?: Maybe<MembershipProjectsConnection>;
  /** The user's provided name. */
  name: Scalars['String']['output'];
  /** Does the user to refresh their facebook token? */
  needsFreshFacebookToken?: Maybe<Scalars['Boolean']['output']>;
  /** Which newsleters are the users subscribed to */
  newsletterSubscriptions?: Maybe<NewsletterSubscriptions>;
  /** All of a user's notifications */
  notifications?: Maybe<Array<Notification>>;
  /** Is the user opted out from receiving recommendations */
  optedOutOfRecommendations?: Maybe<Scalars['Boolean']['output']>;
  /** Organizations a user is a member of */
  organizations?: Maybe<UserOrganizationsConnection>;
  /** Whether backer has any action in PPO */
  ppoHasAction?: Maybe<Scalars['Boolean']['output']>;
  /** A user's project notification settings */
  projectNotifications?: Maybe<Array<Notification>>;
  /** Projects a user has saved. */
  savedProjects?: Maybe<UserSavedProjectsConnection>;
  /** Is the user's profile public */
  showPublicProfile?: Maybe<Scalars['Boolean']['output']>;
  /** The user's slug. */
  slug: Scalars['String']['output'];
  /** SEPA accounts stored for this user. */
  storedBankAccounts?: Maybe<BankAccountConnection>;
  /** Stored Cards */
  storedCards?: Maybe<UserCreditCardTypeConnection>;
  /** A user's backings of successful projects */
  successfulBackings: UserBackingsConnection;
  /** Projects a user has launched that are successful. */
  successfulProjects?: Maybe<ProjectsConnectionWithTotalCount>;
  /** This user's survey responses */
  surveyResponses?: Maybe<SurveyResponsesConnection>;
  /** The total number of backers across all the user's projects */
  totalBackersAcrossProjects: Scalars['Int']['output'];
  /** The total number of projects the user has created that are staff picked */
  totalProjectsWeLove: Scalars['Int']['output'];
  /** A user's uid */
  uid: Scalars['String']['output'];
  /** A user's backings that are cancelled or for unsuccessful projects */
  unsuccessfulBackings: UserBackingsConnection;
  /** A URL to the user's profile. */
  url: Scalars['String']['output'];
  /** Details about a user's restrictions */
  userRestrictions?: Maybe<Array<UserRestriction>>;
  /** List of VAT ids used by the user */
  vatNumbers: Array<Scalars['String']['output']>;
  /** A user's websites */
  websites?: Maybe<Array<Maybe<UserUrl>>>;
};


/** A member of Kickstarter. */
export type UserActiveBackingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserActiveProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserAddressesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserBackedProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserBackingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<BackingState>;
};


/** A member of Kickstarter. */
export type UserConversationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  mailbox?: InputMaybe<MailboxType>;
  project_id?: InputMaybe<Scalars['String']['input']>;
};


/** A member of Kickstarter. */
export type UserCreatedProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<OrderDirection>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
};


/** A member of Kickstarter. */
export type UserCuratedPagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserDigitalAccessResourcesArgs = {
  pid: Scalars['Int']['input'];
};


/** A member of Kickstarter. */
export type UserFollowersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserFollowingArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserImageUrlArgs = {
  blur?: InputMaybe<Scalars['Boolean']['input']>;
  width: Scalars['Int']['input'];
};


/** A member of Kickstarter. */
export type UserInvitedProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserIsSlugValidArgs = {
  slug: Scalars['String']['input'];
};


/** A member of Kickstarter. */
export type UserLaunchedProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  excludePids?: InputMaybe<Array<Scalars['Int']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<OrderDirection>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
};


/** A member of Kickstarter. */
export type UserMembershipProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<OrganizationMembershipState>;
};


/** A member of Kickstarter. */
export type UserSavedProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deadlineAfter?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineBefore?: InputMaybe<Scalars['DateTime']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  launched?: InputMaybe<Scalars['Boolean']['input']>;
  state?: InputMaybe<PublicProjectState>;
  upcoming?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A member of Kickstarter. */
export type UserStoredBankAccountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeExpired?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserStoredCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserSuccessfulBackingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserSuccessfulProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserSurveyResponsesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  answered?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A member of Kickstarter. */
export type UserUnsuccessfulBackingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Project. */
export type UserActiveProjectsConnection = {
  __typename?: 'UserActiveProjectsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** The connection type for Project. */
export type UserBackedProjectsConnection = {
  __typename?: 'UserBackedProjectsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** @deprecated Please use backingsCount instead. */
  totalCount: Scalars['Int']['output'];
};

/** The connection type for Backing. */
export type UserBackingsConnection = {
  __typename?: 'UserBackingsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BackingEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Backing>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** @deprecated Please use backingsCount instead. */
  totalCount: Scalars['Int']['output'];
};

/** The connection type for User. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** The connection type for Conversation. */
export type UserConversationsConnection = {
  __typename?: 'UserConversationsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConversationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Conversation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** The connection type for Project. */
export type UserCreatedProjectsConnection = {
  __typename?: 'UserCreatedProjectsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** The connection type for CreditCard. */
export type UserCreditCardTypeConnection = {
  __typename?: 'UserCreditCardTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CreditCardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CreditCard>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** The connection type for CuratedPage. */
export type UserCuratedPagesConnection = {
  __typename?: 'UserCuratedPagesConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CuratedPageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CuratedPage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** The connection type for User. */
export type UserFollowersConnection = {
  __typename?: 'UserFollowersConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** The connection type for User. */
export type UserFollowingConnection = {
  __typename?: 'UserFollowingConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** A named group of users used for reporting, batch actions, or limiting resource access */
export type UserGroup = {
  __typename?: 'UserGroup';
  /** The rules that give the group access to certain resources */
  accessRules: Array<AccessRule>;
  id: Scalars['ID']['output'];
  /** The user group name */
  name: Scalars['String']['output'];
  /** Total number of users in the group */
  userCount: Scalars['Int']['output'];
  users: Array<User>;
};

/** The connection type for Project. */
export type UserInvitedProjectsConnection = {
  __typename?: 'UserInvitedProjectsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** User notification frequencies */
export enum UserNotificationFrequency {
  OnceADay = 'once_a_day',
  TwiceADay = 'twice_a_day'
}

/** User notification kind */
export enum UserNotificationKind {
  /** Email */
  Email = 'email',
  /** Mobile */
  Mobile = 'mobile'
}

/** User notification topics */
export enum UserNotificationTopic {
  Backings = 'backings',
  CommentReplies = 'comment_replies',
  Comments = 'comments',
  CreatorDigest = 'creator_digest',
  CreatorEdu = 'creator_edu',
  Follower = 'follower',
  FriendActivity = 'friend_activity',
  FriendSignup = 'friend_signup',
  MarketingUpdate = 'marketing_update',
  Messages = 'messages',
  ProjectLaunch = 'project_launch',
  Updates = 'updates'
}

/** The connection type for Organization. */
export type UserOrganizationsConnection = {
  __typename?: 'UserOrganizationsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Organization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** A user's restrictions */
export type UserRestriction = {
  __typename?: 'UserRestriction';
  /** Date when the restriction will be lifted. If null, the restriction is indefinite. */
  releaseAt?: Maybe<Scalars['DateTime']['output']>;
  /** Type of restriction a user has */
  restriction: UserRestrictionKind;
};

/** Various restriction states, e.g. messaging, commenting */
export enum UserRestrictionKind {
  Commenting = 'commenting',
  EditSpotlightPages = 'edit_spotlight_pages',
  Messaging = 'messaging',
  Phone = 'phone',
  Pledging = 'pledging',
  PrelaunchEarly = 'prelaunch_early',
  Submitting = 'submitting'
}

/** The connection type for Project. */
export type UserSavedProjectsConnection = {
  __typename?: 'UserSavedProjectsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** Autogenerated input type of UserSendEmailVerification */
export type UserSendEmailVerificationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UserSendEmailVerification */
export type UserSendEmailVerificationPayload = {
  __typename?: 'UserSendEmailVerificationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Possible user settings */
export enum UserSetting {
  AdminMessageBadge = 'admin_message_badge',
  ConfirmedSignalNotice = 'confirmed_signal_notice',
  ConfirmedWatchNotice = 'confirmed_watch_notice',
  DismissedPylToast = 'dismissed_pyl_toast',
  DismissedRewardImagesToast = 'dismissed_reward_images_toast',
  DismissedTasteProfileToast = 'dismissed_taste_profile_toast',
  ManualPlayVideos = 'manual_play_videos',
  OptInKsrResearch = 'opt_in_ksr_research',
  OptedOutOfRecommendations = 'opted_out_of_recommendations',
  ShowPublicProfile = 'show_public_profile',
  SuperbackerNotVisible = 'superbacker_not_visible',
  VizNotification = 'viz_notification'
}

/** A user's websites */
export type UserUrl = Node & {
  __typename?: 'UserUrl';
  /** The domain of a user's website */
  domain?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The URL of a user's website */
  url?: Maybe<Scalars['String']['output']>;
};

/** Validity and associated messages. */
export type Validation = {
  __typename?: 'Validation';
  /** Error keys for validation error, if any */
  errorTypes?: Maybe<Array<Scalars['String']['output']>>;
  /** Error messages associated with the value */
  messages: Array<Scalars['String']['output']>;
  /** Whether a value is valid. */
  valid: Scalars['Boolean']['output'];
};

/** Status returned from an address validation */
export enum ValidationStatus {
  Error = 'error',
  Exact = 'exact',
  NotFound = 'not_found',
  Suggestion = 'suggestion'
}

/** The possible locations for a VatConfig. */
export enum VatConfigLocationEnum {
  /** European Union */
  Eu = 'EU',
  /** United Kingdom */
  Uk = 'UK'
}

/** A project video */
export type Video = Node & {
  __typename?: 'Video';
  id: Scalars['ID']['output'];
  /** Preview image url for the video */
  previewImageUrl?: Maybe<Scalars['String']['output']>;
  /** Upload status of the video */
  status: VideoState;
  /** A video's tracks */
  tracks?: Maybe<VideoTracksConnection>;
  /** A video's sources (hls, high, base) */
  videoSources?: Maybe<VideoSources>;
};


/** A project video */
export type VideoTracksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The details of a video's source */
export type VideoSourceInfo = {
  __typename?: 'VideoSourceInfo';
  src?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

/** A video's sources */
export type VideoSources = {
  __typename?: 'VideoSources';
  base?: Maybe<VideoSourceInfo>;
  high?: Maybe<VideoSourceInfo>;
  hls?: Maybe<VideoSourceInfo>;
};

/** All available video states */
export enum VideoState {
  /** Processing the video file failed */
  Failed = 'FAILED',
  /** Initial, incomplete status of a video */
  Processing = 'PROCESSING',
  /** Processing the video file successfully completed */
  Successful = 'SUCCESSFUL'
}

/** A video caption */
export type VideoTrack = Node & {
  __typename?: 'VideoTrack';
  /** A video track's cues (individaul caption with timestamp) */
  cues?: Maybe<VideoTrackCuesConnection>;
  id: Scalars['ID']['output'];
  /** Import status of a video track */
  importStatus: VideoTrackState;
  /** The type of a video track (caption, subtitle) */
  kind: Scalars['String']['output'];
  /** The language of the video track */
  language: CaptionLanguage;
  /** A video track public ID */
  tid: Scalars['Int']['output'];
  trackSourceUrl: Scalars['String']['output'];
};


/** A video caption */
export type VideoTrackCuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A single video track caption with timestamp */
export type VideoTrackCue = Node & {
  __typename?: 'VideoTrackCue';
  id: Scalars['ID']['output'];
};

/** An edge in a connection. */
export type VideoTrackCueEdge = {
  __typename?: 'VideoTrackCueEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VideoTrackCue>;
};

/** The connection type for VideoTrackCue. */
export type VideoTrackCuesConnection = {
  __typename?: 'VideoTrackCuesConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VideoTrackCueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VideoTrackCue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type VideoTrackEdge = {
  __typename?: 'VideoTrackEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VideoTrack>;
};

/** All possible import states for a video track */
export enum VideoTrackState {
  /** An import attempt was unsuccessful */
  Failure = 'FAILURE',
  /** An import is in progress */
  Importing = 'IMPORTING',
  /** Not import exists */
  None = 'NONE',
  /** An import was successful */
  Success = 'SUCCESS'
}

/** The connection type for VideoTrack. */
export type VideoTracksConnection = {
  __typename?: 'VideoTracksConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VideoTrackEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VideoTrack>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** Autogenerated input type of WatchProject */
export type WatchProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  trackingContext?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of WatchProject */
export type WatchProjectPayload = {
  __typename?: 'WatchProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Project>;
  user?: Maybe<User>;
};

/** A min and max weight range with associated cost */
export type WeightRange = {
  __typename?: 'WeightRange';
  /** The cost for this weight range. */
  cost: Scalars['Int']['output'];
  /** The cost for this weight range, formatted. */
  costFormatted: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** The max of the weight range (optional) */
  max?: Maybe<Scalars['Float']['output']>;
  /** The min of the weight range */
  min: Scalars['Float']['output'];
};

/** Input to create or update weight ranges */
export type WeightRangeInput = {
  cost: Scalars['Int']['input'];
  max?: InputMaybe<Scalars['Float']['input']>;
  min: Scalars['Float']['input'];
};

export type BackerDashboardProjectCellFragmentFragment = { __typename?: 'Project', id: string, name: string, description: string, state: ProjectState, deadlineAt?: any | null, launchedAt?: any | null, backersCount: number, category?: { __typename?: 'Category', id: string, name: string } | null, creator?: { __typename?: 'User', id: string, name: string } | null, pledged: { __typename?: 'Money', amount?: string | null, currency?: CurrencyCode | null }, goal?: { __typename?: 'Money', amount?: string | null, currency?: CurrencyCode | null } | null };

export type ProjectAnalyticsFragmentFragment = { __typename?: 'Project', id: string };

export type ProjectCardFragmentFragment = { __typename?: 'Project', id: string, name: string, description: string, state: ProjectState, deadlineAt?: any | null, launchedAt?: any | null, backersCount: number, category?: { __typename?: 'Category', id: string, name: string } | null, creator?: { __typename?: 'User', id: string, name: string } | null, pledged: { __typename?: 'Money', amount?: string | null, currency?: CurrencyCode | null }, goal?: { __typename?: 'Money', amount?: string | null, currency?: CurrencyCode | null } | null, lastUploadedVideo?: { __typename?: 'Video', videoSources?: { __typename?: 'VideoSources', hls?: { __typename?: 'VideoSourceInfo', src?: string | null } | null } | null } | null, image?: { __typename?: 'Photo', url: string } | null, rewards?: { __typename?: 'ProjectRewardConnection', nodes?: Array<{ __typename?: 'Reward', id: string, name?: string | null, description: string, backersCount?: number | null, amount: { __typename?: 'Money', amount?: string | null, currency?: CurrencyCode | null } } | null> | null } | null };

export type SearchQueryVariables = Exact<{
  term?: InputMaybe<Scalars['String']['input']>;
  sort?: InputMaybe<ProjectSort>;
  categoryId?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<PublicProjectState>;
  first?: InputMaybe<Scalars['Int']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type SearchQuery = { __typename?: 'Query', projects?: { __typename?: 'ProjectsConnectionWithTotalCount', totalCount: number, nodes?: Array<{ __typename?: 'Project', id: string, name: string, description: string, state: ProjectState, deadlineAt?: any | null, launchedAt?: any | null, backersCount: number, category?: { __typename?: 'Category', id: string, name: string } | null, creator?: { __typename?: 'User', id: string, name: string } | null, pledged: { __typename?: 'Money', amount?: string | null, currency?: CurrencyCode | null }, goal?: { __typename?: 'Money', amount?: string | null, currency?: CurrencyCode | null } | null, lastUploadedVideo?: { __typename?: 'Video', videoSources?: { __typename?: 'VideoSources', hls?: { __typename?: 'VideoSourceInfo', src?: string | null } | null } | null } | null, image?: { __typename?: 'Photo', url: string } | null, rewards?: { __typename?: 'ProjectRewardConnection', nodes?: Array<{ __typename?: 'Reward', id: string, name?: string | null, description: string, backersCount?: number | null, amount: { __typename?: 'Money', amount?: string | null, currency?: CurrencyCode | null } } | null> | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', endCursor?: string | null, hasNextPage: boolean } } | null };

export const BackerDashboardProjectCellFragmentFragmentDoc = gql`
    fragment BackerDashboardProjectCellFragment on Project {
  id
  name
  description
  state
  category {
    id
    name
  }
  creator {
    id
    name
  }
  pledged {
    amount
    currency
  }
  goal {
    amount
    currency
  }
  deadlineAt
  launchedAt
  backersCount
}
    `;
export const ProjectAnalyticsFragmentFragmentDoc = gql`
    fragment ProjectAnalyticsFragment on Project {
  id
}
    `;
export const ProjectCardFragmentFragmentDoc = gql`
    fragment ProjectCardFragment on Project {
  id
  name
  description
  state
  category {
    id
    name
  }
  creator {
    id
    name
  }
  pledged {
    amount
    currency
  }
  goal {
    amount
    currency
  }
  deadlineAt
  launchedAt
  backersCount
  lastUploadedVideo {
    videoSources {
      hls {
        src
      }
    }
  }
  image {
    url(width: 800)
  }
  rewards {
    nodes {
      id
      name
      description
      amount {
        amount
        currency
      }
      backersCount
    }
  }
}
    `;
export const SearchDocument = gql`
    query Search($term: String, $sort: ProjectSort, $categoryId: String, $state: PublicProjectState, $first: Int, $cursor: String) {
  projects(
    term: $term
    sort: $sort
    categoryId: $categoryId
    state: $state
    after: $cursor
    first: $first
  ) {
    nodes {
      ...BackerDashboardProjectCellFragment
      ...ProjectAnalyticsFragment
      ...ProjectCardFragment
    }
    totalCount
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}
    ${BackerDashboardProjectCellFragmentFragmentDoc}
${ProjectAnalyticsFragmentFragmentDoc}
${ProjectCardFragmentFragmentDoc}`;

/**
 * __useSearchQuery__
 *
 * To run a query within a React component, call `useSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchQuery({
 *   variables: {
 *      term: // value for 'term'
 *      sort: // value for 'sort'
 *      categoryId: // value for 'categoryId'
 *      state: // value for 'state'
 *      first: // value for 'first'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useSearchQuery(baseOptions?: Apollo.QueryHookOptions<SearchQuery, SearchQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchQuery, SearchQueryVariables>(SearchDocument, options);
      }
export function useSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchQuery, SearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchQuery, SearchQueryVariables>(SearchDocument, options);
        }
export function useSearchSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SearchQuery, SearchQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SearchQuery, SearchQueryVariables>(SearchDocument, options);
        }
export type SearchQueryHookResult = ReturnType<typeof useSearchQuery>;
export type SearchLazyQueryHookResult = ReturnType<typeof useSearchLazyQuery>;
export type SearchSuspenseQueryHookResult = ReturnType<typeof useSearchSuspenseQuery>;
export type SearchQueryResult = Apollo.QueryResult<SearchQuery, SearchQueryVariables>;